package slack

// Auto-generated by internal/cmd/genmethods/genmethods.go (generateServiceDetailsFile). DO NOT EDIT!

import (
	"context"
	"encoding/json"
	"net/url"
	"strconv"
	"strings"

	"github.com/lestrrat-go/slack/objects"
	"github.com/pkg/errors"
)

var _ = strconv.Itoa
var _ = strings.Index
var _ = json.Marshal
var _ = objects.EpochTime(0)

// UsersDeletePhotoCall is created by UsersService.DeletePhoto method call
type UsersDeletePhotoCall struct {
	service *UsersService
}

// UsersGetPresenceCall is created by UsersService.GetPresence method call
type UsersGetPresenceCall struct {
	service *UsersService
	user    string
}

// UsersIdentityCall is created by UsersService.Identity method call
type UsersIdentityCall struct {
	service *UsersService
}

// UsersInfoCall is created by UsersService.Info method call
type UsersInfoCall struct {
	service       *UsersService
	includeLocale bool
	user          string
}

// UsersListCall is created by UsersService.List method call
type UsersListCall struct {
	service       *UsersService
	includeLocale bool
	limit         int
	presence      bool
}

// UsersLookupByEmailCall is created by UsersService.LookupByEmail method call
type UsersLookupByEmailCall struct {
	service *UsersService
	email   string
}

// UsersSetActiveCall is created by UsersService.SetActive method call
type UsersSetActiveCall struct {
	service *UsersService
}

// UsersSetPresenceCall is created by UsersService.SetPresence method call
type UsersSetPresenceCall struct {
	service  *UsersService
	presence string
}

// DeletePhoto creates a UsersDeletePhotoCall object in preparation for accessing the users.deletePhoto endpoint
func (s *UsersService) DeletePhoto() *UsersDeletePhotoCall {
	var call UsersDeletePhotoCall
	call.service = s
	return &call
}

// ValidateArgs checks that all required fields are set in the UsersDeletePhotoCall object
func (c *UsersDeletePhotoCall) ValidateArgs() error {
	return nil
}

// Values returns the UsersDeletePhotoCall object as url.Values
func (c *UsersDeletePhotoCall) Values() (url.Values, error) {
	if err := c.ValidateArgs(); err != nil {
		return nil, errors.Wrap(err, `failed validation`)
	}
	v := url.Values{}
	v.Set(`token`, c.service.token)
	return v, nil
}

type UsersDeletePhotoCallResponse struct {
	OK        bool                   `json:"ok"`
	ReplyTo   int                    `json:"reply_to"`
	Error     *objects.ErrorResponse `json:"error"`
	Timestamp string                 `json:"ts"`
	Payload0  json.RawMessage        `json:"-"`
}

func (r *UsersDeletePhotoCallResponse) parse(data []byte) error {
	if err := json.Unmarshal(data, r); err != nil {
		return errors.Wrap(err, `failed to unmarshal UsersDeletePhotoCallResponse`)
	}
	r.Payload0 = data
	return nil
}

// Do executes the call to access users.deletePhoto endpoint
func (c *UsersDeletePhotoCall) Do(ctx context.Context) error {
	const endpoint = "users.deletePhoto"
	v, err := c.Values()
	if err != nil {
		return err
	}
	var res UsersDeletePhotoCallResponse
	if err := c.service.client.postForm(ctx, endpoint, v, &res); err != nil {
		return errors.Wrap(err, `failed to post to users.deletePhoto`)
	}
	if !res.OK {
		var err error
		if errresp := res.Error; errresp != nil {
			err = errors.New(errresp.String())
		} else {
			err = errors.New(`unknown error while posting to users.deletePhoto`)
		}
		return err
	}

	return nil
}

// FromValues parses the data in v and populates `c`
func (c *UsersDeletePhotoCall) FromValues(v url.Values) error {
	var tmp UsersDeletePhotoCall
	*c = tmp
	return nil
}

// GetPresence creates a UsersGetPresenceCall object in preparation for accessing the users.getPresence endpoint
func (s *UsersService) GetPresence(user string) *UsersGetPresenceCall {
	var call UsersGetPresenceCall
	call.service = s
	call.user = user
	return &call
}

// ValidateArgs checks that all required fields are set in the UsersGetPresenceCall object
func (c *UsersGetPresenceCall) ValidateArgs() error {
	if len(c.user) <= 0 {
		return errors.New(`required field user not initialized`)
	}
	return nil
}

// Values returns the UsersGetPresenceCall object as url.Values
func (c *UsersGetPresenceCall) Values() (url.Values, error) {
	if err := c.ValidateArgs(); err != nil {
		return nil, errors.Wrap(err, `failed validation`)
	}
	v := url.Values{}
	v.Set(`token`, c.service.token)

	v.Set("user", c.user)
	return v, nil
}

type UsersGetPresenceCallResponse struct {
	OK        bool                   `json:"ok"`
	ReplyTo   int                    `json:"reply_to"`
	Error     *objects.ErrorResponse `json:"error"`
	Timestamp string                 `json:"ts"`
	Payload0  json.RawMessage        `json:"-"`
}

func (r *UsersGetPresenceCallResponse) parse(data []byte) error {
	if err := json.Unmarshal(data, r); err != nil {
		return errors.Wrap(err, `failed to unmarshal UsersGetPresenceCallResponse`)
	}
	r.Payload0 = data
	return nil
}
func (r *UsersGetPresenceCallResponse) payload() (*objects.UserPresence, error) {
	var res0 objects.UserPresence
	if err := json.Unmarshal(r.Payload0, &res0); err != nil {
		return nil, errors.Wrap(err, `failed to ummarshal objects.UserPresence from response`)
	}
	return &res0, nil
}

// Do executes the call to access users.getPresence endpoint
func (c *UsersGetPresenceCall) Do(ctx context.Context) (*objects.UserPresence, error) {
	const endpoint = "users.getPresence"
	v, err := c.Values()
	if err != nil {
		return nil, err
	}
	var res UsersGetPresenceCallResponse
	if err := c.service.client.postForm(ctx, endpoint, v, &res); err != nil {
		return nil, errors.Wrap(err, `failed to post to users.getPresence`)
	}
	if !res.OK {
		var err error
		if errresp := res.Error; errresp != nil {
			err = errors.New(errresp.String())
		} else {
			err = errors.New(`unknown error while posting to users.getPresence`)
		}
		return nil, err
	}

	return res.payload()
}

// FromValues parses the data in v and populates `c`
func (c *UsersGetPresenceCall) FromValues(v url.Values) error {
	var tmp UsersGetPresenceCall
	if raw := strings.TrimSpace(v.Get("user")); len(raw) > 0 {
		tmp.user = raw
	}
	*c = tmp
	return nil
}

// Identity creates a UsersIdentityCall object in preparation for accessing the users.identity endpoint
func (s *UsersService) Identity() *UsersIdentityCall {
	var call UsersIdentityCall
	call.service = s
	return &call
}

// ValidateArgs checks that all required fields are set in the UsersIdentityCall object
func (c *UsersIdentityCall) ValidateArgs() error {
	return nil
}

// Values returns the UsersIdentityCall object as url.Values
func (c *UsersIdentityCall) Values() (url.Values, error) {
	if err := c.ValidateArgs(); err != nil {
		return nil, errors.Wrap(err, `failed validation`)
	}
	v := url.Values{}
	v.Set(`token`, c.service.token)
	return v, nil
}

type UsersIdentityCallResponse struct {
	OK        bool                   `json:"ok"`
	ReplyTo   int                    `json:"reply_to"`
	Error     *objects.ErrorResponse `json:"error"`
	Timestamp string                 `json:"ts"`
	Payload0  json.RawMessage        `json:"-"`
	Payload1  json.RawMessage        `json:"user"`
	Payload2  json.RawMessage        `json:"team"`
}

func (r *UsersIdentityCallResponse) parse(data []byte) error {
	if err := json.Unmarshal(data, r); err != nil {
		return errors.Wrap(err, `failed to unmarshal UsersIdentityCallResponse`)
	}
	r.Payload0 = data
	return nil
}
func (r *UsersIdentityCallResponse) payload() (*objects.UserProfile, *objects.Team, error) {
	var res1 objects.UserProfile
	if err := json.Unmarshal(r.Payload1, &res1); err != nil {
		return nil, nil, errors.Wrap(err, `failed to ummarshal objects.UserProfile from response`)
	}
	var res2 objects.Team
	if err := json.Unmarshal(r.Payload2, &res2); err != nil {
		return nil, nil, errors.Wrap(err, `failed to ummarshal objects.Team from response`)
	}
	return &res1, &res2, nil
}

// Do executes the call to access users.identity endpoint
func (c *UsersIdentityCall) Do(ctx context.Context) (*objects.UserProfile, *objects.Team, error) {
	const endpoint = "users.identity"
	v, err := c.Values()
	if err != nil {
		return nil, nil, err
	}
	var res UsersIdentityCallResponse
	if err := c.service.client.postForm(ctx, endpoint, v, &res); err != nil {
		return nil, nil, errors.Wrap(err, `failed to post to users.identity`)
	}
	if !res.OK {
		var err error
		if errresp := res.Error; errresp != nil {
			err = errors.New(errresp.String())
		} else {
			err = errors.New(`unknown error while posting to users.identity`)
		}
		return nil, nil, err
	}

	return res.payload()
}

// FromValues parses the data in v and populates `c`
func (c *UsersIdentityCall) FromValues(v url.Values) error {
	var tmp UsersIdentityCall
	*c = tmp
	return nil
}

// Info creates a UsersInfoCall object in preparation for accessing the users.info endpoint
func (s *UsersService) Info(user string) *UsersInfoCall {
	var call UsersInfoCall
	call.service = s
	call.user = user
	return &call
}

// IncludeLocale sets the value for optional includeLocale parameter
func (c *UsersInfoCall) IncludeLocale(includeLocale bool) *UsersInfoCall {
	c.includeLocale = includeLocale
	return c
}

// ValidateArgs checks that all required fields are set in the UsersInfoCall object
func (c *UsersInfoCall) ValidateArgs() error {
	if len(c.user) <= 0 {
		return errors.New(`required field user not initialized`)
	}
	return nil
}

// Values returns the UsersInfoCall object as url.Values
func (c *UsersInfoCall) Values() (url.Values, error) {
	if err := c.ValidateArgs(); err != nil {
		return nil, errors.Wrap(err, `failed validation`)
	}
	v := url.Values{}
	v.Set(`token`, c.service.token)

	if c.includeLocale {
		v.Set("include_locale", "true")
	}

	v.Set("user", c.user)
	return v, nil
}

type UsersInfoCallResponse struct {
	OK        bool                   `json:"ok"`
	ReplyTo   int                    `json:"reply_to"`
	Error     *objects.ErrorResponse `json:"error"`
	Timestamp string                 `json:"ts"`
	Payload0  json.RawMessage        `json:"-"`
	Payload1  json.RawMessage        `json:"user"`
}

func (r *UsersInfoCallResponse) parse(data []byte) error {
	if err := json.Unmarshal(data, r); err != nil {
		return errors.Wrap(err, `failed to unmarshal UsersInfoCallResponse`)
	}
	r.Payload0 = data
	return nil
}
func (r *UsersInfoCallResponse) payload() (*objects.User, error) {
	var res1 objects.User
	if err := json.Unmarshal(r.Payload1, &res1); err != nil {
		return nil, errors.Wrap(err, `failed to ummarshal objects.User from response`)
	}
	return &res1, nil
}

// Do executes the call to access users.info endpoint
func (c *UsersInfoCall) Do(ctx context.Context) (*objects.User, error) {
	const endpoint = "users.info"
	v, err := c.Values()
	if err != nil {
		return nil, err
	}
	var res UsersInfoCallResponse
	if err := c.service.client.postForm(ctx, endpoint, v, &res); err != nil {
		return nil, errors.Wrap(err, `failed to post to users.info`)
	}
	if !res.OK {
		var err error
		if errresp := res.Error; errresp != nil {
			err = errors.New(errresp.String())
		} else {
			err = errors.New(`unknown error while posting to users.info`)
		}
		return nil, err
	}

	return res.payload()
}

// FromValues parses the data in v and populates `c`
func (c *UsersInfoCall) FromValues(v url.Values) error {
	var tmp UsersInfoCall
	if raw := strings.TrimSpace(v.Get("include_locale")); len(raw) > 0 {
		parsed, err := strconv.ParseBool(raw)
		if err != nil {
			return errors.Wrap(err, `failed to parse boolean value "include_locale"`)
		}
		tmp.includeLocale = parsed
	}
	if raw := strings.TrimSpace(v.Get("user")); len(raw) > 0 {
		tmp.user = raw
	}
	*c = tmp
	return nil
}

// List creates a UsersListCall object in preparation for accessing the users.list endpoint
func (s *UsersService) List() *UsersListCall {
	var call UsersListCall
	call.service = s
	return &call
}

// IncludeLocale sets the value for optional includeLocale parameter
func (c *UsersListCall) IncludeLocale(includeLocale bool) *UsersListCall {
	c.includeLocale = includeLocale
	return c
}

// Limit sets the value for optional limit parameter
func (c *UsersListCall) Limit(limit int) *UsersListCall {
	c.limit = limit
	return c
}

// Presence sets the value for optional presence parameter
func (c *UsersListCall) Presence(presence bool) *UsersListCall {
	c.presence = presence
	return c
}

// ValidateArgs checks that all required fields are set in the UsersListCall object
func (c *UsersListCall) ValidateArgs() error {
	return nil
}

// Values returns the UsersListCall object as url.Values
func (c *UsersListCall) Values() (url.Values, error) {
	if err := c.ValidateArgs(); err != nil {
		return nil, errors.Wrap(err, `failed validation`)
	}
	v := url.Values{}
	v.Set(`token`, c.service.token)

	if c.includeLocale {
		v.Set("include_locale", "true")
	}

	if c.limit > 0 {
		v.Set("limit", strconv.Itoa(c.limit))
	}

	if c.presence {
		v.Set("presence", "true")
	}
	return v, nil
}

type UsersListCallResponse struct {
	OK        bool                   `json:"ok"`
	ReplyTo   int                    `json:"reply_to"`
	Error     *objects.ErrorResponse `json:"error"`
	Timestamp string                 `json:"ts"`
	Payload0  json.RawMessage        `json:"-"`
	Payload1  json.RawMessage        `json:"members"`
}

func (r *UsersListCallResponse) parse(data []byte) error {
	if err := json.Unmarshal(data, r); err != nil {
		return errors.Wrap(err, `failed to unmarshal UsersListCallResponse`)
	}
	r.Payload0 = data
	return nil
}
func (r *UsersListCallResponse) payload() (objects.UserList, error) {
	var res1 objects.UserList
	if err := json.Unmarshal(r.Payload1, &res1); err != nil {
		return nil, errors.Wrap(err, `failed to ummarshal objects.UserList from response`)
	}
	return res1, nil
}

// Do executes the call to access users.list endpoint
func (c *UsersListCall) Do(ctx context.Context) (objects.UserList, error) {
	const endpoint = "users.list"
	v, err := c.Values()
	if err != nil {
		return nil, err
	}
	var res UsersListCallResponse
	if err := c.service.client.postForm(ctx, endpoint, v, &res); err != nil {
		return nil, errors.Wrap(err, `failed to post to users.list`)
	}
	if !res.OK {
		var err error
		if errresp := res.Error; errresp != nil {
			err = errors.New(errresp.String())
		} else {
			err = errors.New(`unknown error while posting to users.list`)
		}
		return nil, err
	}

	return res.payload()
}

// FromValues parses the data in v and populates `c`
func (c *UsersListCall) FromValues(v url.Values) error {
	var tmp UsersListCall
	if raw := strings.TrimSpace(v.Get("include_locale")); len(raw) > 0 {
		parsed, err := strconv.ParseBool(raw)
		if err != nil {
			return errors.Wrap(err, `failed to parse boolean value "include_locale"`)
		}
		tmp.includeLocale = parsed
	}
	if raw := strings.TrimSpace(v.Get("limit")); len(raw) > 0 {
		parsed, err := strconv.ParseInt(raw, 10, 64)
		if err != nil {
			return errors.Wrap(err, `failed to parse integer value "limit"`)
		}
		tmp.limit = int(parsed)
	}
	if raw := strings.TrimSpace(v.Get("presence")); len(raw) > 0 {
		parsed, err := strconv.ParseBool(raw)
		if err != nil {
			return errors.Wrap(err, `failed to parse boolean value "presence"`)
		}
		tmp.presence = parsed
	}
	*c = tmp
	return nil
}

// LookupByEmail creates a UsersLookupByEmailCall object in preparation for accessing the users.lookupByEmail endpoint
func (s *UsersService) LookupByEmail(email string) *UsersLookupByEmailCall {
	var call UsersLookupByEmailCall
	call.service = s
	call.email = email
	return &call
}

// ValidateArgs checks that all required fields are set in the UsersLookupByEmailCall object
func (c *UsersLookupByEmailCall) ValidateArgs() error {
	if len(c.email) <= 0 {
		return errors.New(`required field email not initialized`)
	}
	return nil
}

// Values returns the UsersLookupByEmailCall object as url.Values
func (c *UsersLookupByEmailCall) Values() (url.Values, error) {
	if err := c.ValidateArgs(); err != nil {
		return nil, errors.Wrap(err, `failed validation`)
	}
	v := url.Values{}
	v.Set(`token`, c.service.token)

	v.Set("email", c.email)
	return v, nil
}

type UsersLookupByEmailCallResponse struct {
	OK        bool                   `json:"ok"`
	ReplyTo   int                    `json:"reply_to"`
	Error     *objects.ErrorResponse `json:"error"`
	Timestamp string                 `json:"ts"`
	Payload0  json.RawMessage        `json:"-"`
	Payload1  json.RawMessage        `json:"user"`
}

func (r *UsersLookupByEmailCallResponse) parse(data []byte) error {
	if err := json.Unmarshal(data, r); err != nil {
		return errors.Wrap(err, `failed to unmarshal UsersLookupByEmailCallResponse`)
	}
	r.Payload0 = data
	return nil
}
func (r *UsersLookupByEmailCallResponse) payload() (*objects.User, error) {
	var res1 objects.User
	if err := json.Unmarshal(r.Payload1, &res1); err != nil {
		return nil, errors.Wrap(err, `failed to ummarshal objects.User from response`)
	}
	return &res1, nil
}

// Do executes the call to access users.lookupByEmail endpoint
func (c *UsersLookupByEmailCall) Do(ctx context.Context) (*objects.User, error) {
	const endpoint = "users.lookupByEmail"
	v, err := c.Values()
	if err != nil {
		return nil, err
	}
	var res UsersLookupByEmailCallResponse
	if err := c.service.client.postForm(ctx, endpoint, v, &res); err != nil {
		return nil, errors.Wrap(err, `failed to post to users.lookupByEmail`)
	}
	if !res.OK {
		var err error
		if errresp := res.Error; errresp != nil {
			err = errors.New(errresp.String())
		} else {
			err = errors.New(`unknown error while posting to users.lookupByEmail`)
		}
		return nil, err
	}

	return res.payload()
}

// FromValues parses the data in v and populates `c`
func (c *UsersLookupByEmailCall) FromValues(v url.Values) error {
	var tmp UsersLookupByEmailCall
	if raw := strings.TrimSpace(v.Get("email")); len(raw) > 0 {
		tmp.email = raw
	}
	*c = tmp
	return nil
}

// SetActive creates a UsersSetActiveCall object in preparation for accessing the users.setActive endpoint
func (s *UsersService) SetActive() *UsersSetActiveCall {
	var call UsersSetActiveCall
	call.service = s
	return &call
}

// ValidateArgs checks that all required fields are set in the UsersSetActiveCall object
func (c *UsersSetActiveCall) ValidateArgs() error {
	return nil
}

// Values returns the UsersSetActiveCall object as url.Values
func (c *UsersSetActiveCall) Values() (url.Values, error) {
	if err := c.ValidateArgs(); err != nil {
		return nil, errors.Wrap(err, `failed validation`)
	}
	v := url.Values{}
	v.Set(`token`, c.service.token)
	return v, nil
}

type UsersSetActiveCallResponse struct {
	OK        bool                   `json:"ok"`
	ReplyTo   int                    `json:"reply_to"`
	Error     *objects.ErrorResponse `json:"error"`
	Timestamp string                 `json:"ts"`
	Payload0  json.RawMessage        `json:"-"`
}

func (r *UsersSetActiveCallResponse) parse(data []byte) error {
	if err := json.Unmarshal(data, r); err != nil {
		return errors.Wrap(err, `failed to unmarshal UsersSetActiveCallResponse`)
	}
	r.Payload0 = data
	return nil
}

// Do executes the call to access users.setActive endpoint
func (c *UsersSetActiveCall) Do(ctx context.Context) error {
	const endpoint = "users.setActive"
	v, err := c.Values()
	if err != nil {
		return err
	}
	var res UsersSetActiveCallResponse
	if err := c.service.client.postForm(ctx, endpoint, v, &res); err != nil {
		return errors.Wrap(err, `failed to post to users.setActive`)
	}
	if !res.OK {
		var err error
		if errresp := res.Error; errresp != nil {
			err = errors.New(errresp.String())
		} else {
			err = errors.New(`unknown error while posting to users.setActive`)
		}
		return err
	}

	return nil
}

// FromValues parses the data in v and populates `c`
func (c *UsersSetActiveCall) FromValues(v url.Values) error {
	var tmp UsersSetActiveCall
	*c = tmp
	return nil
}

// SetPresence creates a UsersSetPresenceCall object in preparation for accessing the users.setPresence endpoint
func (s *UsersService) SetPresence(presence string) *UsersSetPresenceCall {
	var call UsersSetPresenceCall
	call.service = s
	call.presence = presence
	return &call
}

// ValidateArgs checks that all required fields are set in the UsersSetPresenceCall object
func (c *UsersSetPresenceCall) ValidateArgs() error {
	if len(c.presence) <= 0 {
		return errors.New(`required field presence not initialized`)
	}
	return nil
}

// Values returns the UsersSetPresenceCall object as url.Values
func (c *UsersSetPresenceCall) Values() (url.Values, error) {
	if err := c.ValidateArgs(); err != nil {
		return nil, errors.Wrap(err, `failed validation`)
	}
	v := url.Values{}
	v.Set(`token`, c.service.token)

	v.Set("presence", c.presence)
	return v, nil
}

type UsersSetPresenceCallResponse struct {
	OK        bool                   `json:"ok"`
	ReplyTo   int                    `json:"reply_to"`
	Error     *objects.ErrorResponse `json:"error"`
	Timestamp string                 `json:"ts"`
	Payload0  json.RawMessage        `json:"-"`
}

func (r *UsersSetPresenceCallResponse) parse(data []byte) error {
	if err := json.Unmarshal(data, r); err != nil {
		return errors.Wrap(err, `failed to unmarshal UsersSetPresenceCallResponse`)
	}
	r.Payload0 = data
	return nil
}

// Do executes the call to access users.setPresence endpoint
func (c *UsersSetPresenceCall) Do(ctx context.Context) error {
	const endpoint = "users.setPresence"
	v, err := c.Values()
	if err != nil {
		return err
	}
	var res UsersSetPresenceCallResponse
	if err := c.service.client.postForm(ctx, endpoint, v, &res); err != nil {
		return errors.Wrap(err, `failed to post to users.setPresence`)
	}
	if !res.OK {
		var err error
		if errresp := res.Error; errresp != nil {
			err = errors.New(errresp.String())
		} else {
			err = errors.New(`unknown error while posting to users.setPresence`)
		}
		return err
	}

	return nil
}

// FromValues parses the data in v and populates `c`
func (c *UsersSetPresenceCall) FromValues(v url.Values) error {
	var tmp UsersSetPresenceCall
	if raw := strings.TrimSpace(v.Get("presence")); len(raw) > 0 {
		tmp.presence = raw
	}
	*c = tmp
	return nil
}
