package slack

// Auto-generated by internal/cmd/genmethods/genmethods.go (generateServiceDetailsFile). DO NOT EDIT!

import (
	"context"
	"encoding/json"
	"net/url"
	"strconv"
	"strings"

	"github.com/lestrrat-go/slack/objects"
	"github.com/pkg/errors"
)

var _ = strconv.Itoa
var _ = strings.Index
var _ = json.Marshal
var _ = objects.EpochTime(0)

// ReactionsAddCall is created by ReactionsService.Add method call
type ReactionsAddCall struct {
	service     *ReactionsService
	channel     string
	file        string
	fileComment string
	name        string
	timestamp   string
}

// ReactionsGetCall is created by ReactionsService.Get method call
type ReactionsGetCall struct {
	service     *ReactionsService
	channel     string
	file        string
	fileComment string
	full        bool
	timestamp   string
}

// ReactionsListCall is created by ReactionsService.List method call
type ReactionsListCall struct {
	service *ReactionsService
	count   int
	full    bool
	page    int
	user    string
}

// ReactionsRemoveCall is created by ReactionsService.Remove method call
type ReactionsRemoveCall struct {
	service     *ReactionsService
	channel     string
	file        string
	fileComment string
	name        string
	timestamp   string
}

// Add creates a ReactionsAddCall object in preparation for accessing the reactions.add endpoint
func (s *ReactionsService) Add(name string) *ReactionsAddCall {
	var call ReactionsAddCall
	call.service = s
	call.name = name
	return &call
}

// Channel sets the value for optional channel parameter
func (c *ReactionsAddCall) Channel(channel string) *ReactionsAddCall {
	c.channel = channel
	return c
}

// File sets the value for optional file parameter
func (c *ReactionsAddCall) File(file string) *ReactionsAddCall {
	c.file = file
	return c
}

// FileComment sets the value for optional fileComment parameter
func (c *ReactionsAddCall) FileComment(fileComment string) *ReactionsAddCall {
	c.fileComment = fileComment
	return c
}

// Timestamp sets the value for optional timestamp parameter
func (c *ReactionsAddCall) Timestamp(timestamp string) *ReactionsAddCall {
	c.timestamp = timestamp
	return c
}

// ValidateArgs checks that all required fields are set in the ReactionsAddCall object
func (c *ReactionsAddCall) ValidateArgs() error {
	if len(c.name) <= 0 {
		return errors.New(`required field name not initialized`)
	}
	return nil
}

// Values returns the ReactionsAddCall object as url.Values
func (c *ReactionsAddCall) Values() (url.Values, error) {
	if err := c.ValidateArgs(); err != nil {
		return nil, errors.Wrap(err, `failed validation`)
	}
	v := url.Values{}
	v.Set(`token`, c.service.token)

	if len(c.channel) > 0 {
		v.Set("channel", c.channel)
	}

	if len(c.file) > 0 {
		v.Set("file", c.file)
	}

	if len(c.fileComment) > 0 {
		v.Set("fileComment", c.fileComment)
	}

	v.Set("name", c.name)

	if len(c.timestamp) > 0 {
		v.Set("timestamp", c.timestamp)
	}
	return v, nil
}

type ReactionsAddCallResponse interface {
	OK() bool
	ReplyTo() int
	Error() *objects.ErrorResponse
	Timestamp() string
}

type reactionsAddCallResponseProxy struct {
	OK        bool                   `json:"ok"`
	ReplyTo   int                    `json:"reply_to"`
	Error     *objects.ErrorResponse `json:"error"`
	Timestamp string                 `json:"ts"`
	Payload0  json.RawMessage        `json:"-"`
}
type reactionsAddCallResponse struct {
	ok      bool
	replyTo int
	error   *objects.ErrorResponse
	ts      string
}
type ReactionsAddCallResponseBuilder struct {
	resp *reactionsAddCallResponse
}

func BuildReactionsAddCallResponse() *ReactionsAddCallResponseBuilder {
	return &ReactionsAddCallResponseBuilder{resp: &reactionsAddCallResponse{}}
}
func (v *reactionsAddCallResponse) OK() bool {
	return v.ok
}
func (v *reactionsAddCallResponse) ReplyTo() int {
	return v.replyTo
}
func (v *reactionsAddCallResponse) Error() *objects.ErrorResponse {
	return v.error
}
func (v *reactionsAddCallResponse) Timestamp() string {
	return v.ts
}
func (b *ReactionsAddCallResponseBuilder) OK(v bool) *ReactionsAddCallResponseBuilder {
	b.resp.ok = v
	return b
}
func (b *ReactionsAddCallResponseBuilder) ReplyTo(v int) *ReactionsAddCallResponseBuilder {
	b.resp.replyTo = v
	return b
}
func (b *ReactionsAddCallResponseBuilder) Error(v *objects.ErrorResponse) *ReactionsAddCallResponseBuilder {
	b.resp.error = v
	return b
}
func (b *ReactionsAddCallResponseBuilder) Timestamp(v string) *ReactionsAddCallResponseBuilder {
	b.resp.ts = v
	return b
}
func (b *ReactionsAddCallResponseBuilder) Build() ReactionsAddCallResponse {
	v := b.resp
	b.resp = &reactionsAddCallResponse{}
	return v
}
func (r *reactionsAddCallResponseProxy) parse(data []byte) error {
	if err := json.Unmarshal(data, r); err != nil {
		return errors.Wrap(err, `failed to unmarshal ReactionsAddCallResponse`)
	}
	r.Payload0 = data
	return nil
}
func (r *reactionsAddCallResponse) MarshalJSON() ([]byte, error) {
	var p reactionsAddCallResponseProxy
	p.OK = r.ok
	p.ReplyTo = r.replyTo
	p.Error = r.error
	p.Timestamp = r.ts
	return json.Marshal(p)
}

// Do executes the call to access reactions.add endpoint
func (c *ReactionsAddCall) Do(ctx context.Context) error {
	const endpoint = "reactions.add"
	v, err := c.Values()
	if err != nil {
		return err
	}
	var res reactionsAddCallResponseProxy
	if err := c.service.client.postForm(ctx, endpoint, v, &res); err != nil {
		return errors.Wrap(err, `failed to post to reactions.add`)
	}
	if !res.OK {
		var err error
		if errresp := res.Error; errresp != nil {
			err = errors.New(errresp.String())
		} else {
			err = errors.New(`unknown error while posting to reactions.add`)
		}
		return err
	}

	return nil
}

// FromValues parses the data in v and populates `c`
func (c *ReactionsAddCall) FromValues(v url.Values) error {
	var tmp ReactionsAddCall
	if raw := strings.TrimSpace(v.Get("channel")); len(raw) > 0 {
		tmp.channel = raw
	}
	if raw := strings.TrimSpace(v.Get("file")); len(raw) > 0 {
		tmp.file = raw
	}
	if raw := strings.TrimSpace(v.Get("fileComment")); len(raw) > 0 {
		tmp.fileComment = raw
	}
	if raw := strings.TrimSpace(v.Get("name")); len(raw) > 0 {
		tmp.name = raw
	}
	if raw := strings.TrimSpace(v.Get("timestamp")); len(raw) > 0 {
		tmp.timestamp = raw
	}
	*c = tmp
	return nil
}

// Get creates a ReactionsGetCall object in preparation for accessing the reactions.get endpoint
func (s *ReactionsService) Get() *ReactionsGetCall {
	var call ReactionsGetCall
	call.service = s
	return &call
}

// Channel sets the value for optional channel parameter
func (c *ReactionsGetCall) Channel(channel string) *ReactionsGetCall {
	c.channel = channel
	return c
}

// File sets the value for optional file parameter
func (c *ReactionsGetCall) File(file string) *ReactionsGetCall {
	c.file = file
	return c
}

// FileComment sets the value for optional fileComment parameter
func (c *ReactionsGetCall) FileComment(fileComment string) *ReactionsGetCall {
	c.fileComment = fileComment
	return c
}

// Full sets the value for optional full parameter
func (c *ReactionsGetCall) Full(full bool) *ReactionsGetCall {
	c.full = full
	return c
}

// Timestamp sets the value for optional timestamp parameter
func (c *ReactionsGetCall) Timestamp(timestamp string) *ReactionsGetCall {
	c.timestamp = timestamp
	return c
}

// ValidateArgs checks that all required fields are set in the ReactionsGetCall object
func (c *ReactionsGetCall) ValidateArgs() error {
	return nil
}

// Values returns the ReactionsGetCall object as url.Values
func (c *ReactionsGetCall) Values() (url.Values, error) {
	if err := c.ValidateArgs(); err != nil {
		return nil, errors.Wrap(err, `failed validation`)
	}
	v := url.Values{}
	v.Set(`token`, c.service.token)

	if len(c.channel) > 0 {
		v.Set("channel", c.channel)
	}

	if len(c.file) > 0 {
		v.Set("file", c.file)
	}

	if len(c.fileComment) > 0 {
		v.Set("fileComment", c.fileComment)
	}

	if c.full {
		v.Set("full", "true")
	}

	if len(c.timestamp) > 0 {
		v.Set("timestamp", c.timestamp)
	}
	return v, nil
}

type ReactionsGetCallResponse interface {
	OK() bool
	ReplyTo() int
	Error() *objects.ErrorResponse
	Timestamp() string
}

type reactionsGetCallResponseProxy struct {
	OK        bool                   `json:"ok"`
	ReplyTo   int                    `json:"reply_to"`
	Error     *objects.ErrorResponse `json:"error"`
	Timestamp string                 `json:"ts"`
	Payload0  json.RawMessage        `json:"-"`
}
type reactionsGetCallResponse struct {
	ok      bool
	replyTo int
	error   *objects.ErrorResponse
	ts      string
}
type ReactionsGetCallResponseBuilder struct {
	resp *reactionsGetCallResponse
}

func BuildReactionsGetCallResponse() *ReactionsGetCallResponseBuilder {
	return &ReactionsGetCallResponseBuilder{resp: &reactionsGetCallResponse{}}
}
func (v *reactionsGetCallResponse) OK() bool {
	return v.ok
}
func (v *reactionsGetCallResponse) ReplyTo() int {
	return v.replyTo
}
func (v *reactionsGetCallResponse) Error() *objects.ErrorResponse {
	return v.error
}
func (v *reactionsGetCallResponse) Timestamp() string {
	return v.ts
}
func (b *ReactionsGetCallResponseBuilder) OK(v bool) *ReactionsGetCallResponseBuilder {
	b.resp.ok = v
	return b
}
func (b *ReactionsGetCallResponseBuilder) ReplyTo(v int) *ReactionsGetCallResponseBuilder {
	b.resp.replyTo = v
	return b
}
func (b *ReactionsGetCallResponseBuilder) Error(v *objects.ErrorResponse) *ReactionsGetCallResponseBuilder {
	b.resp.error = v
	return b
}
func (b *ReactionsGetCallResponseBuilder) Timestamp(v string) *ReactionsGetCallResponseBuilder {
	b.resp.ts = v
	return b
}
func (b *ReactionsGetCallResponseBuilder) Build() ReactionsGetCallResponse {
	v := b.resp
	b.resp = &reactionsGetCallResponse{}
	return v
}
func (r *reactionsGetCallResponseProxy) parse(data []byte) error {
	if err := json.Unmarshal(data, r); err != nil {
		return errors.Wrap(err, `failed to unmarshal ReactionsGetCallResponse`)
	}
	r.Payload0 = data
	return nil
}
func (r *reactionsGetCallResponseProxy) payload() (*objects.ReactionsGetResponse, error) {
	var res0 objects.ReactionsGetResponse
	if err := json.Unmarshal(r.Payload0, &res0); err != nil {
		return nil, errors.Wrap(err, `failed to ummarshal objects.ReactionsGetResponse from response`)
	}
	return &res0, nil
}
func (r *reactionsGetCallResponse) MarshalJSON() ([]byte, error) {
	var p reactionsGetCallResponseProxy
	p.OK = r.ok
	p.ReplyTo = r.replyTo
	p.Error = r.error
	p.Timestamp = r.ts
	return json.Marshal(p)
}

// Do executes the call to access reactions.get endpoint
func (c *ReactionsGetCall) Do(ctx context.Context) (*objects.ReactionsGetResponse, error) {
	const endpoint = "reactions.get"
	v, err := c.Values()
	if err != nil {
		return nil, err
	}
	var res reactionsGetCallResponseProxy
	if err := c.service.client.postForm(ctx, endpoint, v, &res); err != nil {
		return nil, errors.Wrap(err, `failed to post to reactions.get`)
	}
	if !res.OK {
		var err error
		if errresp := res.Error; errresp != nil {
			err = errors.New(errresp.String())
		} else {
			err = errors.New(`unknown error while posting to reactions.get`)
		}
		return nil, err
	}

	return res.payload()
}

// FromValues parses the data in v and populates `c`
func (c *ReactionsGetCall) FromValues(v url.Values) error {
	var tmp ReactionsGetCall
	if raw := strings.TrimSpace(v.Get("channel")); len(raw) > 0 {
		tmp.channel = raw
	}
	if raw := strings.TrimSpace(v.Get("file")); len(raw) > 0 {
		tmp.file = raw
	}
	if raw := strings.TrimSpace(v.Get("fileComment")); len(raw) > 0 {
		tmp.fileComment = raw
	}
	if raw := strings.TrimSpace(v.Get("full")); len(raw) > 0 {
		parsed, err := strconv.ParseBool(raw)
		if err != nil {
			return errors.Wrap(err, `failed to parse boolean value "full"`)
		}
		tmp.full = parsed
	}
	if raw := strings.TrimSpace(v.Get("timestamp")); len(raw) > 0 {
		tmp.timestamp = raw
	}
	*c = tmp
	return nil
}

// List creates a ReactionsListCall object in preparation for accessing the reactions.list endpoint
func (s *ReactionsService) List() *ReactionsListCall {
	var call ReactionsListCall
	call.service = s
	return &call
}

// Count sets the value for optional count parameter
func (c *ReactionsListCall) Count(count int) *ReactionsListCall {
	c.count = count
	return c
}

// Full sets the value for optional full parameter
func (c *ReactionsListCall) Full(full bool) *ReactionsListCall {
	c.full = full
	return c
}

// Page sets the value for optional page parameter
func (c *ReactionsListCall) Page(page int) *ReactionsListCall {
	c.page = page
	return c
}

// User sets the value for optional user parameter
func (c *ReactionsListCall) User(user string) *ReactionsListCall {
	c.user = user
	return c
}

// ValidateArgs checks that all required fields are set in the ReactionsListCall object
func (c *ReactionsListCall) ValidateArgs() error {
	return nil
}

// Values returns the ReactionsListCall object as url.Values
func (c *ReactionsListCall) Values() (url.Values, error) {
	if err := c.ValidateArgs(); err != nil {
		return nil, errors.Wrap(err, `failed validation`)
	}
	v := url.Values{}
	v.Set(`token`, c.service.token)

	if c.count > 0 {
		v.Set("count", strconv.Itoa(c.count))
	}

	if c.full {
		v.Set("full", "true")
	}

	if c.page > 0 {
		v.Set("page", strconv.Itoa(c.page))
	}

	if len(c.user) > 0 {
		v.Set("user", c.user)
	}
	return v, nil
}

type ReactionsListCallResponse interface {
	OK() bool
	ReplyTo() int
	Error() *objects.ErrorResponse
	Timestamp() string
}

type reactionsListCallResponseProxy struct {
	OK        bool                   `json:"ok"`
	ReplyTo   int                    `json:"reply_to"`
	Error     *objects.ErrorResponse `json:"error"`
	Timestamp string                 `json:"ts"`
	Payload0  json.RawMessage        `json:"-"`
}
type reactionsListCallResponse struct {
	ok      bool
	replyTo int
	error   *objects.ErrorResponse
	ts      string
}
type ReactionsListCallResponseBuilder struct {
	resp *reactionsListCallResponse
}

func BuildReactionsListCallResponse() *ReactionsListCallResponseBuilder {
	return &ReactionsListCallResponseBuilder{resp: &reactionsListCallResponse{}}
}
func (v *reactionsListCallResponse) OK() bool {
	return v.ok
}
func (v *reactionsListCallResponse) ReplyTo() int {
	return v.replyTo
}
func (v *reactionsListCallResponse) Error() *objects.ErrorResponse {
	return v.error
}
func (v *reactionsListCallResponse) Timestamp() string {
	return v.ts
}
func (b *ReactionsListCallResponseBuilder) OK(v bool) *ReactionsListCallResponseBuilder {
	b.resp.ok = v
	return b
}
func (b *ReactionsListCallResponseBuilder) ReplyTo(v int) *ReactionsListCallResponseBuilder {
	b.resp.replyTo = v
	return b
}
func (b *ReactionsListCallResponseBuilder) Error(v *objects.ErrorResponse) *ReactionsListCallResponseBuilder {
	b.resp.error = v
	return b
}
func (b *ReactionsListCallResponseBuilder) Timestamp(v string) *ReactionsListCallResponseBuilder {
	b.resp.ts = v
	return b
}
func (b *ReactionsListCallResponseBuilder) Build() ReactionsListCallResponse {
	v := b.resp
	b.resp = &reactionsListCallResponse{}
	return v
}
func (r *reactionsListCallResponseProxy) parse(data []byte) error {
	if err := json.Unmarshal(data, r); err != nil {
		return errors.Wrap(err, `failed to unmarshal ReactionsListCallResponse`)
	}
	r.Payload0 = data
	return nil
}
func (r *reactionsListCallResponseProxy) payload() (*objects.ReactionsListResponse, error) {
	var res0 objects.ReactionsListResponse
	if err := json.Unmarshal(r.Payload0, &res0); err != nil {
		return nil, errors.Wrap(err, `failed to ummarshal objects.ReactionsListResponse from response`)
	}
	return &res0, nil
}
func (r *reactionsListCallResponse) MarshalJSON() ([]byte, error) {
	var p reactionsListCallResponseProxy
	p.OK = r.ok
	p.ReplyTo = r.replyTo
	p.Error = r.error
	p.Timestamp = r.ts
	return json.Marshal(p)
}

// Do executes the call to access reactions.list endpoint
func (c *ReactionsListCall) Do(ctx context.Context) (*objects.ReactionsListResponse, error) {
	const endpoint = "reactions.list"
	v, err := c.Values()
	if err != nil {
		return nil, err
	}
	var res reactionsListCallResponseProxy
	if err := c.service.client.postForm(ctx, endpoint, v, &res); err != nil {
		return nil, errors.Wrap(err, `failed to post to reactions.list`)
	}
	if !res.OK {
		var err error
		if errresp := res.Error; errresp != nil {
			err = errors.New(errresp.String())
		} else {
			err = errors.New(`unknown error while posting to reactions.list`)
		}
		return nil, err
	}

	return res.payload()
}

// FromValues parses the data in v and populates `c`
func (c *ReactionsListCall) FromValues(v url.Values) error {
	var tmp ReactionsListCall
	if raw := strings.TrimSpace(v.Get("count")); len(raw) > 0 {
		parsed, err := strconv.ParseInt(raw, 10, 64)
		if err != nil {
			return errors.Wrap(err, `failed to parse integer value "count"`)
		}
		tmp.count = int(parsed)
	}
	if raw := strings.TrimSpace(v.Get("full")); len(raw) > 0 {
		parsed, err := strconv.ParseBool(raw)
		if err != nil {
			return errors.Wrap(err, `failed to parse boolean value "full"`)
		}
		tmp.full = parsed
	}
	if raw := strings.TrimSpace(v.Get("page")); len(raw) > 0 {
		parsed, err := strconv.ParseInt(raw, 10, 64)
		if err != nil {
			return errors.Wrap(err, `failed to parse integer value "page"`)
		}
		tmp.page = int(parsed)
	}
	if raw := strings.TrimSpace(v.Get("user")); len(raw) > 0 {
		tmp.user = raw
	}
	*c = tmp
	return nil
}

// Remove creates a ReactionsRemoveCall object in preparation for accessing the reactions.remove endpoint
func (s *ReactionsService) Remove(name string) *ReactionsRemoveCall {
	var call ReactionsRemoveCall
	call.service = s
	call.name = name
	return &call
}

// Channel sets the value for optional channel parameter
func (c *ReactionsRemoveCall) Channel(channel string) *ReactionsRemoveCall {
	c.channel = channel
	return c
}

// File sets the value for optional file parameter
func (c *ReactionsRemoveCall) File(file string) *ReactionsRemoveCall {
	c.file = file
	return c
}

// FileComment sets the value for optional fileComment parameter
func (c *ReactionsRemoveCall) FileComment(fileComment string) *ReactionsRemoveCall {
	c.fileComment = fileComment
	return c
}

// Timestamp sets the value for optional timestamp parameter
func (c *ReactionsRemoveCall) Timestamp(timestamp string) *ReactionsRemoveCall {
	c.timestamp = timestamp
	return c
}

// ValidateArgs checks that all required fields are set in the ReactionsRemoveCall object
func (c *ReactionsRemoveCall) ValidateArgs() error {
	if len(c.name) <= 0 {
		return errors.New(`required field name not initialized`)
	}
	return nil
}

// Values returns the ReactionsRemoveCall object as url.Values
func (c *ReactionsRemoveCall) Values() (url.Values, error) {
	if err := c.ValidateArgs(); err != nil {
		return nil, errors.Wrap(err, `failed validation`)
	}
	v := url.Values{}
	v.Set(`token`, c.service.token)

	if len(c.channel) > 0 {
		v.Set("channel", c.channel)
	}

	if len(c.file) > 0 {
		v.Set("file", c.file)
	}

	if len(c.fileComment) > 0 {
		v.Set("fileComment", c.fileComment)
	}

	v.Set("name", c.name)

	if len(c.timestamp) > 0 {
		v.Set("timestamp", c.timestamp)
	}
	return v, nil
}

type ReactionsRemoveCallResponse interface {
	OK() bool
	ReplyTo() int
	Error() *objects.ErrorResponse
	Timestamp() string
}

type reactionsRemoveCallResponseProxy struct {
	OK        bool                   `json:"ok"`
	ReplyTo   int                    `json:"reply_to"`
	Error     *objects.ErrorResponse `json:"error"`
	Timestamp string                 `json:"ts"`
	Payload0  json.RawMessage        `json:"-"`
}
type reactionsRemoveCallResponse struct {
	ok      bool
	replyTo int
	error   *objects.ErrorResponse
	ts      string
}
type ReactionsRemoveCallResponseBuilder struct {
	resp *reactionsRemoveCallResponse
}

func BuildReactionsRemoveCallResponse() *ReactionsRemoveCallResponseBuilder {
	return &ReactionsRemoveCallResponseBuilder{resp: &reactionsRemoveCallResponse{}}
}
func (v *reactionsRemoveCallResponse) OK() bool {
	return v.ok
}
func (v *reactionsRemoveCallResponse) ReplyTo() int {
	return v.replyTo
}
func (v *reactionsRemoveCallResponse) Error() *objects.ErrorResponse {
	return v.error
}
func (v *reactionsRemoveCallResponse) Timestamp() string {
	return v.ts
}
func (b *ReactionsRemoveCallResponseBuilder) OK(v bool) *ReactionsRemoveCallResponseBuilder {
	b.resp.ok = v
	return b
}
func (b *ReactionsRemoveCallResponseBuilder) ReplyTo(v int) *ReactionsRemoveCallResponseBuilder {
	b.resp.replyTo = v
	return b
}
func (b *ReactionsRemoveCallResponseBuilder) Error(v *objects.ErrorResponse) *ReactionsRemoveCallResponseBuilder {
	b.resp.error = v
	return b
}
func (b *ReactionsRemoveCallResponseBuilder) Timestamp(v string) *ReactionsRemoveCallResponseBuilder {
	b.resp.ts = v
	return b
}
func (b *ReactionsRemoveCallResponseBuilder) Build() ReactionsRemoveCallResponse {
	v := b.resp
	b.resp = &reactionsRemoveCallResponse{}
	return v
}
func (r *reactionsRemoveCallResponseProxy) parse(data []byte) error {
	if err := json.Unmarshal(data, r); err != nil {
		return errors.Wrap(err, `failed to unmarshal ReactionsRemoveCallResponse`)
	}
	r.Payload0 = data
	return nil
}
func (r *reactionsRemoveCallResponse) MarshalJSON() ([]byte, error) {
	var p reactionsRemoveCallResponseProxy
	p.OK = r.ok
	p.ReplyTo = r.replyTo
	p.Error = r.error
	p.Timestamp = r.ts
	return json.Marshal(p)
}

// Do executes the call to access reactions.remove endpoint
func (c *ReactionsRemoveCall) Do(ctx context.Context) error {
	const endpoint = "reactions.remove"
	v, err := c.Values()
	if err != nil {
		return err
	}
	var res reactionsRemoveCallResponseProxy
	if err := c.service.client.postForm(ctx, endpoint, v, &res); err != nil {
		return errors.Wrap(err, `failed to post to reactions.remove`)
	}
	if !res.OK {
		var err error
		if errresp := res.Error; errresp != nil {
			err = errors.New(errresp.String())
		} else {
			err = errors.New(`unknown error while posting to reactions.remove`)
		}
		return err
	}

	return nil
}

// FromValues parses the data in v and populates `c`
func (c *ReactionsRemoveCall) FromValues(v url.Values) error {
	var tmp ReactionsRemoveCall
	if raw := strings.TrimSpace(v.Get("channel")); len(raw) > 0 {
		tmp.channel = raw
	}
	if raw := strings.TrimSpace(v.Get("file")); len(raw) > 0 {
		tmp.file = raw
	}
	if raw := strings.TrimSpace(v.Get("fileComment")); len(raw) > 0 {
		tmp.fileComment = raw
	}
	if raw := strings.TrimSpace(v.Get("name")); len(raw) > 0 {
		tmp.name = raw
	}
	if raw := strings.TrimSpace(v.Get("timestamp")); len(raw) > 0 {
		tmp.timestamp = raw
	}
	*c = tmp
	return nil
}
