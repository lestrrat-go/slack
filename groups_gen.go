package slack

// Auto-generated by internal/cmd/genmethods/genmethods.go (generateServiceDetailsFile). DO NOT EDIT!

import (
	"context"
	"encoding/json"
	"net/url"
	"strconv"
	"strings"

	"github.com/lestrrat-go/slack/objects"
	"github.com/pkg/errors"
)

var _ = strconv.Itoa
var _ = strings.Index
var _ = json.Marshal
var _ = objects.EpochTime(0)

// GroupsArchiveCall is created by GroupsService.Archive method call
type GroupsArchiveCall struct {
	service *GroupsService
	channel string
}

// GroupsCreateCall is created by GroupsService.Create method call
type GroupsCreateCall struct {
	service  *GroupsService
	name     string
	validate bool
}

// GroupsCreateChildCall is created by GroupsService.CreateChild method call
type GroupsCreateChildCall struct {
	service *GroupsService
	channel string
}

// GroupsHistoryCall is created by GroupsService.History method call
type GroupsHistoryCall struct {
	service   *GroupsService
	channel   string
	count     int
	inclusive bool
	latest    string
	oldest    string
	unreads   bool
}

// GroupsInfoCall is created by GroupsService.Info method call
type GroupsInfoCall struct {
	service       *GroupsService
	channel       string
	includeLocale bool
}

// GroupsInviteCall is created by GroupsService.Invite method call
type GroupsInviteCall struct {
	service *GroupsService
	channel string
	user    string
}

// GroupsKickCall is created by GroupsService.Kick method call
type GroupsKickCall struct {
	service *GroupsService
	channel string
	user    string
}

// GroupsLeaveCall is created by GroupsService.Leave method call
type GroupsLeaveCall struct {
	service *GroupsService
	channel string
}

// GroupsListCall is created by GroupsService.List method call
type GroupsListCall struct {
	service         *GroupsService
	excludeArchived bool
	excludeMembers  bool
}

// GroupsMarkCall is created by GroupsService.Mark method call
type GroupsMarkCall struct {
	service   *GroupsService
	channel   string
	timestamp string
}

// GroupsOpenCall is created by GroupsService.Open method call
type GroupsOpenCall struct {
	service *GroupsService
	channel string
}

// GroupsRenameCall is created by GroupsService.Rename method call
type GroupsRenameCall struct {
	service  *GroupsService
	channel  string
	name     string
	validate bool
}

// GroupsRepliesCall is created by GroupsService.Replies method call
type GroupsRepliesCall struct {
	service         *GroupsService
	channel         string
	threadTimestamp string
}

// GroupsSetPurposeCall is created by GroupsService.SetPurpose method call
type GroupsSetPurposeCall struct {
	service *GroupsService
	channel string
	purpose string
}

// GroupsSetTopicCall is created by GroupsService.SetTopic method call
type GroupsSetTopicCall struct {
	service *GroupsService
	channel string
	topic   string
}

// GroupsUnarchiveCall is created by GroupsService.Unarchive method call
type GroupsUnarchiveCall struct {
	service *GroupsService
	channel string
}

// Archive creates a GroupsArchiveCall object in preparation for accessing the groups.archive endpoint
func (s *GroupsService) Archive(channel string) *GroupsArchiveCall {
	var call GroupsArchiveCall
	call.service = s
	call.channel = channel
	return &call
}

// ValidateArgs checks that all required fields are set in the GroupsArchiveCall object
func (c *GroupsArchiveCall) ValidateArgs() error {
	if len(c.channel) <= 0 {
		return errors.New(`required field channel not initialized`)
	}
	return nil
}

// Values returns the GroupsArchiveCall object as url.Values
func (c *GroupsArchiveCall) Values() (url.Values, error) {
	if err := c.ValidateArgs(); err != nil {
		return nil, errors.Wrap(err, `failed validation`)
	}
	v := url.Values{}
	v.Set(`token`, c.service.token)

	v.Set("channel", c.channel)
	return v, nil
}

type GroupsArchiveCallResponse interface {
	OK() bool
	ReplyTo() int
	Error() *objects.ErrorResponse
	Timestamp() string
}

type groupsArchiveCallResponseProxy struct {
	OK        bool                   `json:"ok"`
	ReplyTo   int                    `json:"reply_to"`
	Error     *objects.ErrorResponse `json:"error"`
	Timestamp string                 `json:"ts"`
	Payload0  json.RawMessage        `json:"-"`
}
type groupsArchiveCallResponse struct {
	ok      bool
	replyTo int
	error   *objects.ErrorResponse
	ts      string
}
type GroupsArchiveCallResponseBuilder struct {
	resp *groupsArchiveCallResponse
}

func BuildGroupsArchiveCallResponse() *GroupsArchiveCallResponseBuilder {
	return &GroupsArchiveCallResponseBuilder{resp: &groupsArchiveCallResponse{}}
}
func (v *groupsArchiveCallResponse) OK() bool {
	return v.ok
}
func (v *groupsArchiveCallResponse) ReplyTo() int {
	return v.replyTo
}
func (v *groupsArchiveCallResponse) Error() *objects.ErrorResponse {
	return v.error
}
func (v *groupsArchiveCallResponse) Timestamp() string {
	return v.ts
}
func (b *GroupsArchiveCallResponseBuilder) OK(v bool) *GroupsArchiveCallResponseBuilder {
	b.resp.ok = v
	return b
}
func (b *GroupsArchiveCallResponseBuilder) ReplyTo(v int) *GroupsArchiveCallResponseBuilder {
	b.resp.replyTo = v
	return b
}
func (b *GroupsArchiveCallResponseBuilder) Error(v *objects.ErrorResponse) *GroupsArchiveCallResponseBuilder {
	b.resp.error = v
	return b
}
func (b *GroupsArchiveCallResponseBuilder) Timestamp(v string) *GroupsArchiveCallResponseBuilder {
	b.resp.ts = v
	return b
}
func (b *GroupsArchiveCallResponseBuilder) Build() GroupsArchiveCallResponse {
	v := b.resp
	b.resp = &groupsArchiveCallResponse{}
	return v
}
func (r *groupsArchiveCallResponseProxy) parse(data []byte) error {
	if err := json.Unmarshal(data, r); err != nil {
		return errors.Wrap(err, `failed to unmarshal GroupsArchiveCallResponse`)
	}
	r.Payload0 = data
	return nil
}
func (r *groupsArchiveCallResponse) MarshalJSON() ([]byte, error) {
	var p groupsArchiveCallResponseProxy
	p.OK = r.ok
	p.ReplyTo = r.replyTo
	p.Error = r.error
	p.Timestamp = r.ts
	return json.Marshal(p)
}

// Do executes the call to access groups.archive endpoint
func (c *GroupsArchiveCall) Do(ctx context.Context) error {
	const endpoint = "groups.archive"
	v, err := c.Values()
	if err != nil {
		return err
	}
	var res groupsArchiveCallResponseProxy
	if err := c.service.client.postForm(ctx, endpoint, v, &res); err != nil {
		return errors.Wrap(err, `failed to post to groups.archive`)
	}
	if !res.OK {
		var err error
		if errresp := res.Error; errresp != nil {
			err = errors.New(errresp.String())
		} else {
			err = errors.New(`unknown error while posting to groups.archive`)
		}
		return err
	}

	return nil
}

// FromValues parses the data in v and populates `c`
func (c *GroupsArchiveCall) FromValues(v url.Values) error {
	var tmp GroupsArchiveCall
	if raw := strings.TrimSpace(v.Get("channel")); len(raw) > 0 {
		tmp.channel = raw
	}
	*c = tmp
	return nil
}

// Create creates a GroupsCreateCall object in preparation for accessing the groups.create endpoint
func (s *GroupsService) Create(name string) *GroupsCreateCall {
	var call GroupsCreateCall
	call.service = s
	call.name = name
	return &call
}

// Validate sets the value for optional validate parameter
func (c *GroupsCreateCall) Validate(validate bool) *GroupsCreateCall {
	c.validate = validate
	return c
}

// ValidateArgs checks that all required fields are set in the GroupsCreateCall object
func (c *GroupsCreateCall) ValidateArgs() error {
	if len(c.name) <= 0 {
		return errors.New(`required field name not initialized`)
	}
	return nil
}

// Values returns the GroupsCreateCall object as url.Values
func (c *GroupsCreateCall) Values() (url.Values, error) {
	if err := c.ValidateArgs(); err != nil {
		return nil, errors.Wrap(err, `failed validation`)
	}
	v := url.Values{}
	v.Set(`token`, c.service.token)

	v.Set("name", c.name)

	if c.validate {
		v.Set("validate", "true")
	}
	return v, nil
}

type GroupsCreateCallResponse interface {
	OK() bool
	ReplyTo() int
	Error() *objects.ErrorResponse
	Timestamp() string
	Group() *objects.Group
}

type groupsCreateCallResponseProxy struct {
	OK        bool                   `json:"ok"`
	ReplyTo   int                    `json:"reply_to"`
	Error     *objects.ErrorResponse `json:"error"`
	Timestamp string                 `json:"ts"`
	Payload0  json.RawMessage        `json:"-"`
	Payload1  json.RawMessage        `json:"group"`
}
type groupsCreateCallResponse struct {
	ok      bool
	replyTo int
	error   *objects.ErrorResponse
	ts      string
	group   *objects.Group
}
type GroupsCreateCallResponseBuilder struct {
	resp *groupsCreateCallResponse
}

func BuildGroupsCreateCallResponse() *GroupsCreateCallResponseBuilder {
	return &GroupsCreateCallResponseBuilder{resp: &groupsCreateCallResponse{}}
}
func (v *groupsCreateCallResponse) OK() bool {
	return v.ok
}
func (v *groupsCreateCallResponse) ReplyTo() int {
	return v.replyTo
}
func (v *groupsCreateCallResponse) Error() *objects.ErrorResponse {
	return v.error
}
func (v *groupsCreateCallResponse) Timestamp() string {
	return v.ts
}
func (v *groupsCreateCallResponse) Group() *objects.Group {
	return v.group
}
func (b *GroupsCreateCallResponseBuilder) OK(v bool) *GroupsCreateCallResponseBuilder {
	b.resp.ok = v
	return b
}
func (b *GroupsCreateCallResponseBuilder) ReplyTo(v int) *GroupsCreateCallResponseBuilder {
	b.resp.replyTo = v
	return b
}
func (b *GroupsCreateCallResponseBuilder) Error(v *objects.ErrorResponse) *GroupsCreateCallResponseBuilder {
	b.resp.error = v
	return b
}
func (b *GroupsCreateCallResponseBuilder) Timestamp(v string) *GroupsCreateCallResponseBuilder {
	b.resp.ts = v
	return b
}
func (b *GroupsCreateCallResponseBuilder) Group(v *objects.Group) *GroupsCreateCallResponseBuilder {
	b.resp.group = v
	return b
}
func (b *GroupsCreateCallResponseBuilder) Build() GroupsCreateCallResponse {
	v := b.resp
	b.resp = &groupsCreateCallResponse{}
	return v
}
func (r *groupsCreateCallResponseProxy) parse(data []byte) error {
	if err := json.Unmarshal(data, r); err != nil {
		return errors.Wrap(err, `failed to unmarshal GroupsCreateCallResponse`)
	}
	r.Payload0 = data
	return nil
}
func (r *groupsCreateCallResponseProxy) payload() (*objects.Group, error) {
	var res1 objects.Group
	if err := json.Unmarshal(r.Payload1, &res1); err != nil {
		return nil, errors.Wrap(err, `failed to ummarshal objects.Group from response`)
	}
	return &res1, nil
}
func (r *groupsCreateCallResponse) MarshalJSON() ([]byte, error) {
	var p groupsCreateCallResponseProxy
	p.OK = r.ok
	p.ReplyTo = r.replyTo
	p.Error = r.error
	p.Timestamp = r.ts
	payload1, err := json.Marshal(r.group)
	if err != nil {
		return nil, errors.Wrap(err, `failed to marshal 'group' field`)
	}
	p.Payload1 = payload1
	return json.Marshal(p)
}

// Do executes the call to access groups.create endpoint
func (c *GroupsCreateCall) Do(ctx context.Context) (*objects.Group, error) {
	const endpoint = "groups.create"
	v, err := c.Values()
	if err != nil {
		return nil, err
	}
	var res groupsCreateCallResponseProxy
	if err := c.service.client.postForm(ctx, endpoint, v, &res); err != nil {
		return nil, errors.Wrap(err, `failed to post to groups.create`)
	}
	if !res.OK {
		var err error
		if errresp := res.Error; errresp != nil {
			err = errors.New(errresp.String())
		} else {
			err = errors.New(`unknown error while posting to groups.create`)
		}
		return nil, err
	}

	return res.payload()
}

// FromValues parses the data in v and populates `c`
func (c *GroupsCreateCall) FromValues(v url.Values) error {
	var tmp GroupsCreateCall
	if raw := strings.TrimSpace(v.Get("name")); len(raw) > 0 {
		tmp.name = raw
	}
	if raw := strings.TrimSpace(v.Get("validate")); len(raw) > 0 {
		parsed, err := strconv.ParseBool(raw)
		if err != nil {
			return errors.Wrap(err, `failed to parse boolean value "validate"`)
		}
		tmp.validate = parsed
	}
	*c = tmp
	return nil
}

// CreateChild creates a GroupsCreateChildCall object in preparation for accessing the groups.createChild endpoint
func (s *GroupsService) CreateChild(channel string) *GroupsCreateChildCall {
	var call GroupsCreateChildCall
	call.service = s
	call.channel = channel
	return &call
}

// ValidateArgs checks that all required fields are set in the GroupsCreateChildCall object
func (c *GroupsCreateChildCall) ValidateArgs() error {
	if len(c.channel) <= 0 {
		return errors.New(`required field channel not initialized`)
	}
	return nil
}

// Values returns the GroupsCreateChildCall object as url.Values
func (c *GroupsCreateChildCall) Values() (url.Values, error) {
	if err := c.ValidateArgs(); err != nil {
		return nil, errors.Wrap(err, `failed validation`)
	}
	v := url.Values{}
	v.Set(`token`, c.service.token)

	v.Set("channel", c.channel)
	return v, nil
}

type GroupsCreateChildCallResponse interface {
	OK() bool
	ReplyTo() int
	Error() *objects.ErrorResponse
	Timestamp() string
	Group() *objects.Group
}

type groupsCreateChildCallResponseProxy struct {
	OK        bool                   `json:"ok"`
	ReplyTo   int                    `json:"reply_to"`
	Error     *objects.ErrorResponse `json:"error"`
	Timestamp string                 `json:"ts"`
	Payload0  json.RawMessage        `json:"-"`
	Payload1  json.RawMessage        `json:"group"`
}
type groupsCreateChildCallResponse struct {
	ok      bool
	replyTo int
	error   *objects.ErrorResponse
	ts      string
	group   *objects.Group
}
type GroupsCreateChildCallResponseBuilder struct {
	resp *groupsCreateChildCallResponse
}

func BuildGroupsCreateChildCallResponse() *GroupsCreateChildCallResponseBuilder {
	return &GroupsCreateChildCallResponseBuilder{resp: &groupsCreateChildCallResponse{}}
}
func (v *groupsCreateChildCallResponse) OK() bool {
	return v.ok
}
func (v *groupsCreateChildCallResponse) ReplyTo() int {
	return v.replyTo
}
func (v *groupsCreateChildCallResponse) Error() *objects.ErrorResponse {
	return v.error
}
func (v *groupsCreateChildCallResponse) Timestamp() string {
	return v.ts
}
func (v *groupsCreateChildCallResponse) Group() *objects.Group {
	return v.group
}
func (b *GroupsCreateChildCallResponseBuilder) OK(v bool) *GroupsCreateChildCallResponseBuilder {
	b.resp.ok = v
	return b
}
func (b *GroupsCreateChildCallResponseBuilder) ReplyTo(v int) *GroupsCreateChildCallResponseBuilder {
	b.resp.replyTo = v
	return b
}
func (b *GroupsCreateChildCallResponseBuilder) Error(v *objects.ErrorResponse) *GroupsCreateChildCallResponseBuilder {
	b.resp.error = v
	return b
}
func (b *GroupsCreateChildCallResponseBuilder) Timestamp(v string) *GroupsCreateChildCallResponseBuilder {
	b.resp.ts = v
	return b
}
func (b *GroupsCreateChildCallResponseBuilder) Group(v *objects.Group) *GroupsCreateChildCallResponseBuilder {
	b.resp.group = v
	return b
}
func (b *GroupsCreateChildCallResponseBuilder) Build() GroupsCreateChildCallResponse {
	v := b.resp
	b.resp = &groupsCreateChildCallResponse{}
	return v
}
func (r *groupsCreateChildCallResponseProxy) parse(data []byte) error {
	if err := json.Unmarshal(data, r); err != nil {
		return errors.Wrap(err, `failed to unmarshal GroupsCreateChildCallResponse`)
	}
	r.Payload0 = data
	return nil
}
func (r *groupsCreateChildCallResponseProxy) payload() (*objects.Group, error) {
	var res1 objects.Group
	if err := json.Unmarshal(r.Payload1, &res1); err != nil {
		return nil, errors.Wrap(err, `failed to ummarshal objects.Group from response`)
	}
	return &res1, nil
}
func (r *groupsCreateChildCallResponse) MarshalJSON() ([]byte, error) {
	var p groupsCreateChildCallResponseProxy
	p.OK = r.ok
	p.ReplyTo = r.replyTo
	p.Error = r.error
	p.Timestamp = r.ts
	payload1, err := json.Marshal(r.group)
	if err != nil {
		return nil, errors.Wrap(err, `failed to marshal 'group' field`)
	}
	p.Payload1 = payload1
	return json.Marshal(p)
}

// Do executes the call to access groups.createChild endpoint
func (c *GroupsCreateChildCall) Do(ctx context.Context) (*objects.Group, error) {
	const endpoint = "groups.createChild"
	v, err := c.Values()
	if err != nil {
		return nil, err
	}
	var res groupsCreateChildCallResponseProxy
	if err := c.service.client.postForm(ctx, endpoint, v, &res); err != nil {
		return nil, errors.Wrap(err, `failed to post to groups.createChild`)
	}
	if !res.OK {
		var err error
		if errresp := res.Error; errresp != nil {
			err = errors.New(errresp.String())
		} else {
			err = errors.New(`unknown error while posting to groups.createChild`)
		}
		return nil, err
	}

	return res.payload()
}

// FromValues parses the data in v and populates `c`
func (c *GroupsCreateChildCall) FromValues(v url.Values) error {
	var tmp GroupsCreateChildCall
	if raw := strings.TrimSpace(v.Get("channel")); len(raw) > 0 {
		tmp.channel = raw
	}
	*c = tmp
	return nil
}

// History creates a GroupsHistoryCall object in preparation for accessing the groups.history endpoint
func (s *GroupsService) History(channel string) *GroupsHistoryCall {
	var call GroupsHistoryCall
	call.service = s
	call.channel = channel
	return &call
}

// Count sets the value for optional count parameter
func (c *GroupsHistoryCall) Count(count int) *GroupsHistoryCall {
	c.count = count
	return c
}

// Inclusive sets the value for optional inclusive parameter
func (c *GroupsHistoryCall) Inclusive(inclusive bool) *GroupsHistoryCall {
	c.inclusive = inclusive
	return c
}

// Latest sets the value for optional latest parameter
func (c *GroupsHistoryCall) Latest(latest string) *GroupsHistoryCall {
	c.latest = latest
	return c
}

// Oldest sets the value for optional oldest parameter
func (c *GroupsHistoryCall) Oldest(oldest string) *GroupsHistoryCall {
	c.oldest = oldest
	return c
}

// Unreads sets the value for optional unreads parameter
func (c *GroupsHistoryCall) Unreads(unreads bool) *GroupsHistoryCall {
	c.unreads = unreads
	return c
}

// ValidateArgs checks that all required fields are set in the GroupsHistoryCall object
func (c *GroupsHistoryCall) ValidateArgs() error {
	if len(c.channel) <= 0 {
		return errors.New(`required field channel not initialized`)
	}
	return nil
}

// Values returns the GroupsHistoryCall object as url.Values
func (c *GroupsHistoryCall) Values() (url.Values, error) {
	if err := c.ValidateArgs(); err != nil {
		return nil, errors.Wrap(err, `failed validation`)
	}
	v := url.Values{}
	v.Set(`token`, c.service.token)

	v.Set("channel", c.channel)

	if c.count > 0 {
		v.Set("count", strconv.Itoa(c.count))
	}

	if c.inclusive {
		v.Set("inclusive", "true")
	}

	if len(c.latest) > 0 {
		v.Set("latest", c.latest)
	}

	if len(c.oldest) > 0 {
		v.Set("oldest", c.oldest)
	}

	if c.unreads {
		v.Set("unreads", "true")
	}
	return v, nil
}

type GroupsHistoryCallResponse interface {
	OK() bool
	ReplyTo() int
	Error() *objects.ErrorResponse
	Timestamp() string
	Latest() string
	Messages() objects.MessageList
}

type groupsHistoryCallResponseProxy struct {
	OK        bool                   `json:"ok"`
	ReplyTo   int                    `json:"reply_to"`
	Error     *objects.ErrorResponse `json:"error"`
	Timestamp string                 `json:"ts"`
	Payload0  json.RawMessage        `json:"-"`
	Payload1  json.RawMessage        `json:"latest"`
	Payload2  json.RawMessage        `json:"messages"`
}
type groupsHistoryCallResponse struct {
	ok       bool
	replyTo  int
	error    *objects.ErrorResponse
	ts       string
	latest   string
	messages objects.MessageList
}
type GroupsHistoryCallResponseBuilder struct {
	resp *groupsHistoryCallResponse
}

func BuildGroupsHistoryCallResponse() *GroupsHistoryCallResponseBuilder {
	return &GroupsHistoryCallResponseBuilder{resp: &groupsHistoryCallResponse{}}
}
func (v *groupsHistoryCallResponse) OK() bool {
	return v.ok
}
func (v *groupsHistoryCallResponse) ReplyTo() int {
	return v.replyTo
}
func (v *groupsHistoryCallResponse) Error() *objects.ErrorResponse {
	return v.error
}
func (v *groupsHistoryCallResponse) Timestamp() string {
	return v.ts
}
func (v *groupsHistoryCallResponse) Latest() string {
	return v.latest
}
func (v *groupsHistoryCallResponse) Messages() objects.MessageList {
	return v.messages
}
func (b *GroupsHistoryCallResponseBuilder) OK(v bool) *GroupsHistoryCallResponseBuilder {
	b.resp.ok = v
	return b
}
func (b *GroupsHistoryCallResponseBuilder) ReplyTo(v int) *GroupsHistoryCallResponseBuilder {
	b.resp.replyTo = v
	return b
}
func (b *GroupsHistoryCallResponseBuilder) Error(v *objects.ErrorResponse) *GroupsHistoryCallResponseBuilder {
	b.resp.error = v
	return b
}
func (b *GroupsHistoryCallResponseBuilder) Timestamp(v string) *GroupsHistoryCallResponseBuilder {
	b.resp.ts = v
	return b
}
func (b *GroupsHistoryCallResponseBuilder) Latest(v string) *GroupsHistoryCallResponseBuilder {
	b.resp.latest = v
	return b
}
func (b *GroupsHistoryCallResponseBuilder) Messages(v objects.MessageList) *GroupsHistoryCallResponseBuilder {
	b.resp.messages = v
	return b
}
func (b *GroupsHistoryCallResponseBuilder) Build() GroupsHistoryCallResponse {
	v := b.resp
	b.resp = &groupsHistoryCallResponse{}
	return v
}
func (r *groupsHistoryCallResponseProxy) parse(data []byte) error {
	if err := json.Unmarshal(data, r); err != nil {
		return errors.Wrap(err, `failed to unmarshal GroupsHistoryCallResponse`)
	}
	r.Payload0 = data
	return nil
}
func (r *groupsHistoryCallResponseProxy) payload() (string, objects.MessageList, error) {
	var res1 string
	if err := json.Unmarshal(r.Payload1, &res1); err != nil {
		return "", nil, errors.Wrap(err, `failed to ummarshal string from response`)
	}
	var res2 objects.MessageList
	if err := json.Unmarshal(r.Payload2, &res2); err != nil {
		return "", nil, errors.Wrap(err, `failed to ummarshal objects.MessageList from response`)
	}
	return res1, res2, nil
}
func (r *groupsHistoryCallResponse) MarshalJSON() ([]byte, error) {
	var p groupsHistoryCallResponseProxy
	p.OK = r.ok
	p.ReplyTo = r.replyTo
	p.Error = r.error
	p.Timestamp = r.ts
	payload1, err := json.Marshal(r.latest)
	if err != nil {
		return nil, errors.Wrap(err, `failed to marshal 'latest' field`)
	}
	p.Payload1 = payload1
	payload2, err := json.Marshal(r.messages)
	if err != nil {
		return nil, errors.Wrap(err, `failed to marshal 'messages' field`)
	}
	p.Payload2 = payload2
	return json.Marshal(p)
}

// Do executes the call to access groups.history endpoint
func (c *GroupsHistoryCall) Do(ctx context.Context) (string, objects.MessageList, error) {
	const endpoint = "groups.history"
	v, err := c.Values()
	if err != nil {
		return "", nil, err
	}
	var res groupsHistoryCallResponseProxy
	if err := c.service.client.postForm(ctx, endpoint, v, &res); err != nil {
		return "", nil, errors.Wrap(err, `failed to post to groups.history`)
	}
	if !res.OK {
		var err error
		if errresp := res.Error; errresp != nil {
			err = errors.New(errresp.String())
		} else {
			err = errors.New(`unknown error while posting to groups.history`)
		}
		return "", nil, err
	}

	return res.payload()
}

// FromValues parses the data in v and populates `c`
func (c *GroupsHistoryCall) FromValues(v url.Values) error {
	var tmp GroupsHistoryCall
	if raw := strings.TrimSpace(v.Get("channel")); len(raw) > 0 {
		tmp.channel = raw
	}
	if raw := strings.TrimSpace(v.Get("count")); len(raw) > 0 {
		parsed, err := strconv.ParseInt(raw, 10, 64)
		if err != nil {
			return errors.Wrap(err, `failed to parse integer value "count"`)
		}
		tmp.count = int(parsed)
	}
	if raw := strings.TrimSpace(v.Get("inclusive")); len(raw) > 0 {
		parsed, err := strconv.ParseBool(raw)
		if err != nil {
			return errors.Wrap(err, `failed to parse boolean value "inclusive"`)
		}
		tmp.inclusive = parsed
	}
	if raw := strings.TrimSpace(v.Get("latest")); len(raw) > 0 {
		tmp.latest = raw
	}
	if raw := strings.TrimSpace(v.Get("oldest")); len(raw) > 0 {
		tmp.oldest = raw
	}
	if raw := strings.TrimSpace(v.Get("unreads")); len(raw) > 0 {
		parsed, err := strconv.ParseBool(raw)
		if err != nil {
			return errors.Wrap(err, `failed to parse boolean value "unreads"`)
		}
		tmp.unreads = parsed
	}
	*c = tmp
	return nil
}

// Info creates a GroupsInfoCall object in preparation for accessing the groups.info endpoint
func (s *GroupsService) Info(channel string) *GroupsInfoCall {
	var call GroupsInfoCall
	call.service = s
	call.channel = channel
	return &call
}

// IncludeLocale sets the value for optional includeLocale parameter
func (c *GroupsInfoCall) IncludeLocale(includeLocale bool) *GroupsInfoCall {
	c.includeLocale = includeLocale
	return c
}

// ValidateArgs checks that all required fields are set in the GroupsInfoCall object
func (c *GroupsInfoCall) ValidateArgs() error {
	if len(c.channel) <= 0 {
		return errors.New(`required field channel not initialized`)
	}
	return nil
}

// Values returns the GroupsInfoCall object as url.Values
func (c *GroupsInfoCall) Values() (url.Values, error) {
	if err := c.ValidateArgs(); err != nil {
		return nil, errors.Wrap(err, `failed validation`)
	}
	v := url.Values{}
	v.Set(`token`, c.service.token)

	v.Set("channel", c.channel)

	if c.includeLocale {
		v.Set("include_locale", "true")
	}
	return v, nil
}

type GroupsInfoCallResponse interface {
	OK() bool
	ReplyTo() int
	Error() *objects.ErrorResponse
	Timestamp() string
	Group() *objects.Group
}

type groupsInfoCallResponseProxy struct {
	OK        bool                   `json:"ok"`
	ReplyTo   int                    `json:"reply_to"`
	Error     *objects.ErrorResponse `json:"error"`
	Timestamp string                 `json:"ts"`
	Payload0  json.RawMessage        `json:"-"`
	Payload1  json.RawMessage        `json:"group"`
}
type groupsInfoCallResponse struct {
	ok      bool
	replyTo int
	error   *objects.ErrorResponse
	ts      string
	group   *objects.Group
}
type GroupsInfoCallResponseBuilder struct {
	resp *groupsInfoCallResponse
}

func BuildGroupsInfoCallResponse() *GroupsInfoCallResponseBuilder {
	return &GroupsInfoCallResponseBuilder{resp: &groupsInfoCallResponse{}}
}
func (v *groupsInfoCallResponse) OK() bool {
	return v.ok
}
func (v *groupsInfoCallResponse) ReplyTo() int {
	return v.replyTo
}
func (v *groupsInfoCallResponse) Error() *objects.ErrorResponse {
	return v.error
}
func (v *groupsInfoCallResponse) Timestamp() string {
	return v.ts
}
func (v *groupsInfoCallResponse) Group() *objects.Group {
	return v.group
}
func (b *GroupsInfoCallResponseBuilder) OK(v bool) *GroupsInfoCallResponseBuilder {
	b.resp.ok = v
	return b
}
func (b *GroupsInfoCallResponseBuilder) ReplyTo(v int) *GroupsInfoCallResponseBuilder {
	b.resp.replyTo = v
	return b
}
func (b *GroupsInfoCallResponseBuilder) Error(v *objects.ErrorResponse) *GroupsInfoCallResponseBuilder {
	b.resp.error = v
	return b
}
func (b *GroupsInfoCallResponseBuilder) Timestamp(v string) *GroupsInfoCallResponseBuilder {
	b.resp.ts = v
	return b
}
func (b *GroupsInfoCallResponseBuilder) Group(v *objects.Group) *GroupsInfoCallResponseBuilder {
	b.resp.group = v
	return b
}
func (b *GroupsInfoCallResponseBuilder) Build() GroupsInfoCallResponse {
	v := b.resp
	b.resp = &groupsInfoCallResponse{}
	return v
}
func (r *groupsInfoCallResponseProxy) parse(data []byte) error {
	if err := json.Unmarshal(data, r); err != nil {
		return errors.Wrap(err, `failed to unmarshal GroupsInfoCallResponse`)
	}
	r.Payload0 = data
	return nil
}
func (r *groupsInfoCallResponseProxy) payload() (*objects.Group, error) {
	var res1 objects.Group
	if err := json.Unmarshal(r.Payload1, &res1); err != nil {
		return nil, errors.Wrap(err, `failed to ummarshal objects.Group from response`)
	}
	return &res1, nil
}
func (r *groupsInfoCallResponse) MarshalJSON() ([]byte, error) {
	var p groupsInfoCallResponseProxy
	p.OK = r.ok
	p.ReplyTo = r.replyTo
	p.Error = r.error
	p.Timestamp = r.ts
	payload1, err := json.Marshal(r.group)
	if err != nil {
		return nil, errors.Wrap(err, `failed to marshal 'group' field`)
	}
	p.Payload1 = payload1
	return json.Marshal(p)
}

// Do executes the call to access groups.info endpoint
func (c *GroupsInfoCall) Do(ctx context.Context) (*objects.Group, error) {
	const endpoint = "groups.info"
	v, err := c.Values()
	if err != nil {
		return nil, err
	}
	var res groupsInfoCallResponseProxy
	if err := c.service.client.postForm(ctx, endpoint, v, &res); err != nil {
		return nil, errors.Wrap(err, `failed to post to groups.info`)
	}
	if !res.OK {
		var err error
		if errresp := res.Error; errresp != nil {
			err = errors.New(errresp.String())
		} else {
			err = errors.New(`unknown error while posting to groups.info`)
		}
		return nil, err
	}

	return res.payload()
}

// FromValues parses the data in v and populates `c`
func (c *GroupsInfoCall) FromValues(v url.Values) error {
	var tmp GroupsInfoCall
	if raw := strings.TrimSpace(v.Get("channel")); len(raw) > 0 {
		tmp.channel = raw
	}
	if raw := strings.TrimSpace(v.Get("include_locale")); len(raw) > 0 {
		parsed, err := strconv.ParseBool(raw)
		if err != nil {
			return errors.Wrap(err, `failed to parse boolean value "include_locale"`)
		}
		tmp.includeLocale = parsed
	}
	*c = tmp
	return nil
}

// Invite creates a GroupsInviteCall object in preparation for accessing the groups.invite endpoint
func (s *GroupsService) Invite(channel string, user string) *GroupsInviteCall {
	var call GroupsInviteCall
	call.service = s
	call.channel = channel
	call.user = user
	return &call
}

// ValidateArgs checks that all required fields are set in the GroupsInviteCall object
func (c *GroupsInviteCall) ValidateArgs() error {
	if len(c.channel) <= 0 {
		return errors.New(`required field channel not initialized`)
	}
	if len(c.user) <= 0 {
		return errors.New(`required field user not initialized`)
	}
	return nil
}

// Values returns the GroupsInviteCall object as url.Values
func (c *GroupsInviteCall) Values() (url.Values, error) {
	if err := c.ValidateArgs(); err != nil {
		return nil, errors.Wrap(err, `failed validation`)
	}
	v := url.Values{}
	v.Set(`token`, c.service.token)

	v.Set("channel", c.channel)

	v.Set("user", c.user)
	return v, nil
}

type GroupsInviteCallResponse interface {
	OK() bool
	ReplyTo() int
	Error() *objects.ErrorResponse
	Timestamp() string
	Group() *objects.Group
	AlreadyInGroup() bool
}

type groupsInviteCallResponseProxy struct {
	OK        bool                   `json:"ok"`
	ReplyTo   int                    `json:"reply_to"`
	Error     *objects.ErrorResponse `json:"error"`
	Timestamp string                 `json:"ts"`
	Payload0  json.RawMessage        `json:"-"`
	Payload1  json.RawMessage        `json:"group"`
	Payload2  json.RawMessage        `json:"already_in_group"`
}
type groupsInviteCallResponse struct {
	ok               bool
	replyTo          int
	error            *objects.ErrorResponse
	ts               string
	group            *objects.Group
	already_in_group bool
}
type GroupsInviteCallResponseBuilder struct {
	resp *groupsInviteCallResponse
}

func BuildGroupsInviteCallResponse() *GroupsInviteCallResponseBuilder {
	return &GroupsInviteCallResponseBuilder{resp: &groupsInviteCallResponse{}}
}
func (v *groupsInviteCallResponse) OK() bool {
	return v.ok
}
func (v *groupsInviteCallResponse) ReplyTo() int {
	return v.replyTo
}
func (v *groupsInviteCallResponse) Error() *objects.ErrorResponse {
	return v.error
}
func (v *groupsInviteCallResponse) Timestamp() string {
	return v.ts
}
func (v *groupsInviteCallResponse) Group() *objects.Group {
	return v.group
}
func (v *groupsInviteCallResponse) AlreadyInGroup() bool {
	return v.already_in_group
}
func (b *GroupsInviteCallResponseBuilder) OK(v bool) *GroupsInviteCallResponseBuilder {
	b.resp.ok = v
	return b
}
func (b *GroupsInviteCallResponseBuilder) ReplyTo(v int) *GroupsInviteCallResponseBuilder {
	b.resp.replyTo = v
	return b
}
func (b *GroupsInviteCallResponseBuilder) Error(v *objects.ErrorResponse) *GroupsInviteCallResponseBuilder {
	b.resp.error = v
	return b
}
func (b *GroupsInviteCallResponseBuilder) Timestamp(v string) *GroupsInviteCallResponseBuilder {
	b.resp.ts = v
	return b
}
func (b *GroupsInviteCallResponseBuilder) Group(v *objects.Group) *GroupsInviteCallResponseBuilder {
	b.resp.group = v
	return b
}
func (b *GroupsInviteCallResponseBuilder) AlreadyInGroup(v bool) *GroupsInviteCallResponseBuilder {
	b.resp.already_in_group = v
	return b
}
func (b *GroupsInviteCallResponseBuilder) Build() GroupsInviteCallResponse {
	v := b.resp
	b.resp = &groupsInviteCallResponse{}
	return v
}
func (r *groupsInviteCallResponseProxy) parse(data []byte) error {
	if err := json.Unmarshal(data, r); err != nil {
		return errors.Wrap(err, `failed to unmarshal GroupsInviteCallResponse`)
	}
	r.Payload0 = data
	return nil
}
func (r *groupsInviteCallResponseProxy) payload() (*objects.Group, bool, error) {
	var res1 objects.Group
	if err := json.Unmarshal(r.Payload1, &res1); err != nil {
		return nil, false, errors.Wrap(err, `failed to ummarshal objects.Group from response`)
	}
	var res2 bool
	if err := json.Unmarshal(r.Payload2, &res2); err != nil {
		return nil, false, errors.Wrap(err, `failed to ummarshal bool from response`)
	}
	return &res1, res2, nil
}
func (r *groupsInviteCallResponse) MarshalJSON() ([]byte, error) {
	var p groupsInviteCallResponseProxy
	p.OK = r.ok
	p.ReplyTo = r.replyTo
	p.Error = r.error
	p.Timestamp = r.ts
	payload1, err := json.Marshal(r.group)
	if err != nil {
		return nil, errors.Wrap(err, `failed to marshal 'group' field`)
	}
	p.Payload1 = payload1
	payload2, err := json.Marshal(r.already_in_group)
	if err != nil {
		return nil, errors.Wrap(err, `failed to marshal 'already_in_group' field`)
	}
	p.Payload2 = payload2
	return json.Marshal(p)
}

// Do executes the call to access groups.invite endpoint
func (c *GroupsInviteCall) Do(ctx context.Context) (*objects.Group, bool, error) {
	const endpoint = "groups.invite"
	v, err := c.Values()
	if err != nil {
		return nil, false, err
	}
	var res groupsInviteCallResponseProxy
	if err := c.service.client.postForm(ctx, endpoint, v, &res); err != nil {
		return nil, false, errors.Wrap(err, `failed to post to groups.invite`)
	}
	if !res.OK {
		var err error
		if errresp := res.Error; errresp != nil {
			err = errors.New(errresp.String())
		} else {
			err = errors.New(`unknown error while posting to groups.invite`)
		}
		return nil, false, err
	}

	return res.payload()
}

// FromValues parses the data in v and populates `c`
func (c *GroupsInviteCall) FromValues(v url.Values) error {
	var tmp GroupsInviteCall
	if raw := strings.TrimSpace(v.Get("channel")); len(raw) > 0 {
		tmp.channel = raw
	}
	if raw := strings.TrimSpace(v.Get("user")); len(raw) > 0 {
		tmp.user = raw
	}
	*c = tmp
	return nil
}

// Kick creates a GroupsKickCall object in preparation for accessing the groups.kick endpoint
func (s *GroupsService) Kick(channel string, user string) *GroupsKickCall {
	var call GroupsKickCall
	call.service = s
	call.channel = channel
	call.user = user
	return &call
}

// ValidateArgs checks that all required fields are set in the GroupsKickCall object
func (c *GroupsKickCall) ValidateArgs() error {
	if len(c.channel) <= 0 {
		return errors.New(`required field channel not initialized`)
	}
	if len(c.user) <= 0 {
		return errors.New(`required field user not initialized`)
	}
	return nil
}

// Values returns the GroupsKickCall object as url.Values
func (c *GroupsKickCall) Values() (url.Values, error) {
	if err := c.ValidateArgs(); err != nil {
		return nil, errors.Wrap(err, `failed validation`)
	}
	v := url.Values{}
	v.Set(`token`, c.service.token)

	v.Set("channel", c.channel)

	v.Set("user", c.user)
	return v, nil
}

type GroupsKickCallResponse interface {
	OK() bool
	ReplyTo() int
	Error() *objects.ErrorResponse
	Timestamp() string
}

type groupsKickCallResponseProxy struct {
	OK        bool                   `json:"ok"`
	ReplyTo   int                    `json:"reply_to"`
	Error     *objects.ErrorResponse `json:"error"`
	Timestamp string                 `json:"ts"`
	Payload0  json.RawMessage        `json:"-"`
}
type groupsKickCallResponse struct {
	ok      bool
	replyTo int
	error   *objects.ErrorResponse
	ts      string
}
type GroupsKickCallResponseBuilder struct {
	resp *groupsKickCallResponse
}

func BuildGroupsKickCallResponse() *GroupsKickCallResponseBuilder {
	return &GroupsKickCallResponseBuilder{resp: &groupsKickCallResponse{}}
}
func (v *groupsKickCallResponse) OK() bool {
	return v.ok
}
func (v *groupsKickCallResponse) ReplyTo() int {
	return v.replyTo
}
func (v *groupsKickCallResponse) Error() *objects.ErrorResponse {
	return v.error
}
func (v *groupsKickCallResponse) Timestamp() string {
	return v.ts
}
func (b *GroupsKickCallResponseBuilder) OK(v bool) *GroupsKickCallResponseBuilder {
	b.resp.ok = v
	return b
}
func (b *GroupsKickCallResponseBuilder) ReplyTo(v int) *GroupsKickCallResponseBuilder {
	b.resp.replyTo = v
	return b
}
func (b *GroupsKickCallResponseBuilder) Error(v *objects.ErrorResponse) *GroupsKickCallResponseBuilder {
	b.resp.error = v
	return b
}
func (b *GroupsKickCallResponseBuilder) Timestamp(v string) *GroupsKickCallResponseBuilder {
	b.resp.ts = v
	return b
}
func (b *GroupsKickCallResponseBuilder) Build() GroupsKickCallResponse {
	v := b.resp
	b.resp = &groupsKickCallResponse{}
	return v
}
func (r *groupsKickCallResponseProxy) parse(data []byte) error {
	if err := json.Unmarshal(data, r); err != nil {
		return errors.Wrap(err, `failed to unmarshal GroupsKickCallResponse`)
	}
	r.Payload0 = data
	return nil
}
func (r *groupsKickCallResponse) MarshalJSON() ([]byte, error) {
	var p groupsKickCallResponseProxy
	p.OK = r.ok
	p.ReplyTo = r.replyTo
	p.Error = r.error
	p.Timestamp = r.ts
	return json.Marshal(p)
}

// Do executes the call to access groups.kick endpoint
func (c *GroupsKickCall) Do(ctx context.Context) error {
	const endpoint = "groups.kick"
	v, err := c.Values()
	if err != nil {
		return err
	}
	var res groupsKickCallResponseProxy
	if err := c.service.client.postForm(ctx, endpoint, v, &res); err != nil {
		return errors.Wrap(err, `failed to post to groups.kick`)
	}
	if !res.OK {
		var err error
		if errresp := res.Error; errresp != nil {
			err = errors.New(errresp.String())
		} else {
			err = errors.New(`unknown error while posting to groups.kick`)
		}
		return err
	}

	return nil
}

// FromValues parses the data in v and populates `c`
func (c *GroupsKickCall) FromValues(v url.Values) error {
	var tmp GroupsKickCall
	if raw := strings.TrimSpace(v.Get("channel")); len(raw) > 0 {
		tmp.channel = raw
	}
	if raw := strings.TrimSpace(v.Get("user")); len(raw) > 0 {
		tmp.user = raw
	}
	*c = tmp
	return nil
}

// Leave creates a GroupsLeaveCall object in preparation for accessing the groups.leave endpoint
func (s *GroupsService) Leave(channel string) *GroupsLeaveCall {
	var call GroupsLeaveCall
	call.service = s
	call.channel = channel
	return &call
}

// ValidateArgs checks that all required fields are set in the GroupsLeaveCall object
func (c *GroupsLeaveCall) ValidateArgs() error {
	if len(c.channel) <= 0 {
		return errors.New(`required field channel not initialized`)
	}
	return nil
}

// Values returns the GroupsLeaveCall object as url.Values
func (c *GroupsLeaveCall) Values() (url.Values, error) {
	if err := c.ValidateArgs(); err != nil {
		return nil, errors.Wrap(err, `failed validation`)
	}
	v := url.Values{}
	v.Set(`token`, c.service.token)

	v.Set("channel", c.channel)
	return v, nil
}

type GroupsLeaveCallResponse interface {
	OK() bool
	ReplyTo() int
	Error() *objects.ErrorResponse
	Timestamp() string
}

type groupsLeaveCallResponseProxy struct {
	OK        bool                   `json:"ok"`
	ReplyTo   int                    `json:"reply_to"`
	Error     *objects.ErrorResponse `json:"error"`
	Timestamp string                 `json:"ts"`
	Payload0  json.RawMessage        `json:"-"`
}
type groupsLeaveCallResponse struct {
	ok      bool
	replyTo int
	error   *objects.ErrorResponse
	ts      string
}
type GroupsLeaveCallResponseBuilder struct {
	resp *groupsLeaveCallResponse
}

func BuildGroupsLeaveCallResponse() *GroupsLeaveCallResponseBuilder {
	return &GroupsLeaveCallResponseBuilder{resp: &groupsLeaveCallResponse{}}
}
func (v *groupsLeaveCallResponse) OK() bool {
	return v.ok
}
func (v *groupsLeaveCallResponse) ReplyTo() int {
	return v.replyTo
}
func (v *groupsLeaveCallResponse) Error() *objects.ErrorResponse {
	return v.error
}
func (v *groupsLeaveCallResponse) Timestamp() string {
	return v.ts
}
func (b *GroupsLeaveCallResponseBuilder) OK(v bool) *GroupsLeaveCallResponseBuilder {
	b.resp.ok = v
	return b
}
func (b *GroupsLeaveCallResponseBuilder) ReplyTo(v int) *GroupsLeaveCallResponseBuilder {
	b.resp.replyTo = v
	return b
}
func (b *GroupsLeaveCallResponseBuilder) Error(v *objects.ErrorResponse) *GroupsLeaveCallResponseBuilder {
	b.resp.error = v
	return b
}
func (b *GroupsLeaveCallResponseBuilder) Timestamp(v string) *GroupsLeaveCallResponseBuilder {
	b.resp.ts = v
	return b
}
func (b *GroupsLeaveCallResponseBuilder) Build() GroupsLeaveCallResponse {
	v := b.resp
	b.resp = &groupsLeaveCallResponse{}
	return v
}
func (r *groupsLeaveCallResponseProxy) parse(data []byte) error {
	if err := json.Unmarshal(data, r); err != nil {
		return errors.Wrap(err, `failed to unmarshal GroupsLeaveCallResponse`)
	}
	r.Payload0 = data
	return nil
}
func (r *groupsLeaveCallResponse) MarshalJSON() ([]byte, error) {
	var p groupsLeaveCallResponseProxy
	p.OK = r.ok
	p.ReplyTo = r.replyTo
	p.Error = r.error
	p.Timestamp = r.ts
	return json.Marshal(p)
}

// Do executes the call to access groups.leave endpoint
func (c *GroupsLeaveCall) Do(ctx context.Context) error {
	const endpoint = "groups.leave"
	v, err := c.Values()
	if err != nil {
		return err
	}
	var res groupsLeaveCallResponseProxy
	if err := c.service.client.postForm(ctx, endpoint, v, &res); err != nil {
		return errors.Wrap(err, `failed to post to groups.leave`)
	}
	if !res.OK {
		var err error
		if errresp := res.Error; errresp != nil {
			err = errors.New(errresp.String())
		} else {
			err = errors.New(`unknown error while posting to groups.leave`)
		}
		return err
	}

	return nil
}

// FromValues parses the data in v and populates `c`
func (c *GroupsLeaveCall) FromValues(v url.Values) error {
	var tmp GroupsLeaveCall
	if raw := strings.TrimSpace(v.Get("channel")); len(raw) > 0 {
		tmp.channel = raw
	}
	*c = tmp
	return nil
}

// List creates a GroupsListCall object in preparation for accessing the groups.list endpoint
func (s *GroupsService) List() *GroupsListCall {
	var call GroupsListCall
	call.service = s
	return &call
}

// ExcludeArchived sets the value for optional excludeArchived parameter
func (c *GroupsListCall) ExcludeArchived(excludeArchived bool) *GroupsListCall {
	c.excludeArchived = excludeArchived
	return c
}

// ExcludeMembers sets the value for optional excludeMembers parameter
func (c *GroupsListCall) ExcludeMembers(excludeMembers bool) *GroupsListCall {
	c.excludeMembers = excludeMembers
	return c
}

// ValidateArgs checks that all required fields are set in the GroupsListCall object
func (c *GroupsListCall) ValidateArgs() error {
	return nil
}

// Values returns the GroupsListCall object as url.Values
func (c *GroupsListCall) Values() (url.Values, error) {
	if err := c.ValidateArgs(); err != nil {
		return nil, errors.Wrap(err, `failed validation`)
	}
	v := url.Values{}
	v.Set(`token`, c.service.token)

	if c.excludeArchived {
		v.Set("exclude_archived", "true")
	}

	if c.excludeMembers {
		v.Set("exclude_members", "true")
	}
	return v, nil
}

type GroupsListCallResponse interface {
	OK() bool
	ReplyTo() int
	Error() *objects.ErrorResponse
	Timestamp() string
	Groups() objects.GroupList
}

type groupsListCallResponseProxy struct {
	OK        bool                   `json:"ok"`
	ReplyTo   int                    `json:"reply_to"`
	Error     *objects.ErrorResponse `json:"error"`
	Timestamp string                 `json:"ts"`
	Payload0  json.RawMessage        `json:"-"`
	Payload1  json.RawMessage        `json:"groups"`
}
type groupsListCallResponse struct {
	ok      bool
	replyTo int
	error   *objects.ErrorResponse
	ts      string
	groups  objects.GroupList
}
type GroupsListCallResponseBuilder struct {
	resp *groupsListCallResponse
}

func BuildGroupsListCallResponse() *GroupsListCallResponseBuilder {
	return &GroupsListCallResponseBuilder{resp: &groupsListCallResponse{}}
}
func (v *groupsListCallResponse) OK() bool {
	return v.ok
}
func (v *groupsListCallResponse) ReplyTo() int {
	return v.replyTo
}
func (v *groupsListCallResponse) Error() *objects.ErrorResponse {
	return v.error
}
func (v *groupsListCallResponse) Timestamp() string {
	return v.ts
}
func (v *groupsListCallResponse) Groups() objects.GroupList {
	return v.groups
}
func (b *GroupsListCallResponseBuilder) OK(v bool) *GroupsListCallResponseBuilder {
	b.resp.ok = v
	return b
}
func (b *GroupsListCallResponseBuilder) ReplyTo(v int) *GroupsListCallResponseBuilder {
	b.resp.replyTo = v
	return b
}
func (b *GroupsListCallResponseBuilder) Error(v *objects.ErrorResponse) *GroupsListCallResponseBuilder {
	b.resp.error = v
	return b
}
func (b *GroupsListCallResponseBuilder) Timestamp(v string) *GroupsListCallResponseBuilder {
	b.resp.ts = v
	return b
}
func (b *GroupsListCallResponseBuilder) Groups(v objects.GroupList) *GroupsListCallResponseBuilder {
	b.resp.groups = v
	return b
}
func (b *GroupsListCallResponseBuilder) Build() GroupsListCallResponse {
	v := b.resp
	b.resp = &groupsListCallResponse{}
	return v
}
func (r *groupsListCallResponseProxy) parse(data []byte) error {
	if err := json.Unmarshal(data, r); err != nil {
		return errors.Wrap(err, `failed to unmarshal GroupsListCallResponse`)
	}
	r.Payload0 = data
	return nil
}
func (r *groupsListCallResponseProxy) payload() (objects.GroupList, error) {
	var res1 objects.GroupList
	if err := json.Unmarshal(r.Payload1, &res1); err != nil {
		return nil, errors.Wrap(err, `failed to ummarshal objects.GroupList from response`)
	}
	return res1, nil
}
func (r *groupsListCallResponse) MarshalJSON() ([]byte, error) {
	var p groupsListCallResponseProxy
	p.OK = r.ok
	p.ReplyTo = r.replyTo
	p.Error = r.error
	p.Timestamp = r.ts
	payload1, err := json.Marshal(r.groups)
	if err != nil {
		return nil, errors.Wrap(err, `failed to marshal 'groups' field`)
	}
	p.Payload1 = payload1
	return json.Marshal(p)
}

// Do executes the call to access groups.list endpoint
func (c *GroupsListCall) Do(ctx context.Context) (objects.GroupList, error) {
	const endpoint = "groups.list"
	v, err := c.Values()
	if err != nil {
		return nil, err
	}
	var res groupsListCallResponseProxy
	if err := c.service.client.postForm(ctx, endpoint, v, &res); err != nil {
		return nil, errors.Wrap(err, `failed to post to groups.list`)
	}
	if !res.OK {
		var err error
		if errresp := res.Error; errresp != nil {
			err = errors.New(errresp.String())
		} else {
			err = errors.New(`unknown error while posting to groups.list`)
		}
		return nil, err
	}

	return res.payload()
}

// FromValues parses the data in v and populates `c`
func (c *GroupsListCall) FromValues(v url.Values) error {
	var tmp GroupsListCall
	if raw := strings.TrimSpace(v.Get("exclude_archived")); len(raw) > 0 {
		parsed, err := strconv.ParseBool(raw)
		if err != nil {
			return errors.Wrap(err, `failed to parse boolean value "exclude_archived"`)
		}
		tmp.excludeArchived = parsed
	}
	if raw := strings.TrimSpace(v.Get("exclude_members")); len(raw) > 0 {
		parsed, err := strconv.ParseBool(raw)
		if err != nil {
			return errors.Wrap(err, `failed to parse boolean value "exclude_members"`)
		}
		tmp.excludeMembers = parsed
	}
	*c = tmp
	return nil
}

// Mark creates a GroupsMarkCall object in preparation for accessing the groups.mark endpoint
func (s *GroupsService) Mark(channel string, timestamp string) *GroupsMarkCall {
	var call GroupsMarkCall
	call.service = s
	call.channel = channel
	call.timestamp = timestamp
	return &call
}

// ValidateArgs checks that all required fields are set in the GroupsMarkCall object
func (c *GroupsMarkCall) ValidateArgs() error {
	if len(c.channel) <= 0 {
		return errors.New(`required field channel not initialized`)
	}
	if len(c.timestamp) <= 0 {
		return errors.New(`required field timestamp not initialized`)
	}
	return nil
}

// Values returns the GroupsMarkCall object as url.Values
func (c *GroupsMarkCall) Values() (url.Values, error) {
	if err := c.ValidateArgs(); err != nil {
		return nil, errors.Wrap(err, `failed validation`)
	}
	v := url.Values{}
	v.Set(`token`, c.service.token)

	v.Set("channel", c.channel)

	v.Set("ts", c.timestamp)
	return v, nil
}

type GroupsMarkCallResponse interface {
	OK() bool
	ReplyTo() int
	Error() *objects.ErrorResponse
	Timestamp() string
}

type groupsMarkCallResponseProxy struct {
	OK        bool                   `json:"ok"`
	ReplyTo   int                    `json:"reply_to"`
	Error     *objects.ErrorResponse `json:"error"`
	Timestamp string                 `json:"ts"`
	Payload0  json.RawMessage        `json:"-"`
}
type groupsMarkCallResponse struct {
	ok      bool
	replyTo int
	error   *objects.ErrorResponse
	ts      string
}
type GroupsMarkCallResponseBuilder struct {
	resp *groupsMarkCallResponse
}

func BuildGroupsMarkCallResponse() *GroupsMarkCallResponseBuilder {
	return &GroupsMarkCallResponseBuilder{resp: &groupsMarkCallResponse{}}
}
func (v *groupsMarkCallResponse) OK() bool {
	return v.ok
}
func (v *groupsMarkCallResponse) ReplyTo() int {
	return v.replyTo
}
func (v *groupsMarkCallResponse) Error() *objects.ErrorResponse {
	return v.error
}
func (v *groupsMarkCallResponse) Timestamp() string {
	return v.ts
}
func (b *GroupsMarkCallResponseBuilder) OK(v bool) *GroupsMarkCallResponseBuilder {
	b.resp.ok = v
	return b
}
func (b *GroupsMarkCallResponseBuilder) ReplyTo(v int) *GroupsMarkCallResponseBuilder {
	b.resp.replyTo = v
	return b
}
func (b *GroupsMarkCallResponseBuilder) Error(v *objects.ErrorResponse) *GroupsMarkCallResponseBuilder {
	b.resp.error = v
	return b
}
func (b *GroupsMarkCallResponseBuilder) Timestamp(v string) *GroupsMarkCallResponseBuilder {
	b.resp.ts = v
	return b
}
func (b *GroupsMarkCallResponseBuilder) Build() GroupsMarkCallResponse {
	v := b.resp
	b.resp = &groupsMarkCallResponse{}
	return v
}
func (r *groupsMarkCallResponseProxy) parse(data []byte) error {
	if err := json.Unmarshal(data, r); err != nil {
		return errors.Wrap(err, `failed to unmarshal GroupsMarkCallResponse`)
	}
	r.Payload0 = data
	return nil
}
func (r *groupsMarkCallResponse) MarshalJSON() ([]byte, error) {
	var p groupsMarkCallResponseProxy
	p.OK = r.ok
	p.ReplyTo = r.replyTo
	p.Error = r.error
	p.Timestamp = r.ts
	return json.Marshal(p)
}

// Do executes the call to access groups.mark endpoint
func (c *GroupsMarkCall) Do(ctx context.Context) error {
	const endpoint = "groups.mark"
	v, err := c.Values()
	if err != nil {
		return err
	}
	var res groupsMarkCallResponseProxy
	if err := c.service.client.postForm(ctx, endpoint, v, &res); err != nil {
		return errors.Wrap(err, `failed to post to groups.mark`)
	}
	if !res.OK {
		var err error
		if errresp := res.Error; errresp != nil {
			err = errors.New(errresp.String())
		} else {
			err = errors.New(`unknown error while posting to groups.mark`)
		}
		return err
	}

	return nil
}

// FromValues parses the data in v and populates `c`
func (c *GroupsMarkCall) FromValues(v url.Values) error {
	var tmp GroupsMarkCall
	if raw := strings.TrimSpace(v.Get("channel")); len(raw) > 0 {
		tmp.channel = raw
	}
	if raw := strings.TrimSpace(v.Get("ts")); len(raw) > 0 {
		tmp.timestamp = raw
	}
	*c = tmp
	return nil
}

// Open creates a GroupsOpenCall object in preparation for accessing the groups.open endpoint
func (s *GroupsService) Open(channel string) *GroupsOpenCall {
	var call GroupsOpenCall
	call.service = s
	call.channel = channel
	return &call
}

// ValidateArgs checks that all required fields are set in the GroupsOpenCall object
func (c *GroupsOpenCall) ValidateArgs() error {
	if len(c.channel) <= 0 {
		return errors.New(`required field channel not initialized`)
	}
	return nil
}

// Values returns the GroupsOpenCall object as url.Values
func (c *GroupsOpenCall) Values() (url.Values, error) {
	if err := c.ValidateArgs(); err != nil {
		return nil, errors.Wrap(err, `failed validation`)
	}
	v := url.Values{}
	v.Set(`token`, c.service.token)

	v.Set("channel", c.channel)
	return v, nil
}

type GroupsOpenCallResponse interface {
	OK() bool
	ReplyTo() int
	Error() *objects.ErrorResponse
	Timestamp() string
}

type groupsOpenCallResponseProxy struct {
	OK        bool                   `json:"ok"`
	ReplyTo   int                    `json:"reply_to"`
	Error     *objects.ErrorResponse `json:"error"`
	Timestamp string                 `json:"ts"`
	Payload0  json.RawMessage        `json:"-"`
}
type groupsOpenCallResponse struct {
	ok      bool
	replyTo int
	error   *objects.ErrorResponse
	ts      string
}
type GroupsOpenCallResponseBuilder struct {
	resp *groupsOpenCallResponse
}

func BuildGroupsOpenCallResponse() *GroupsOpenCallResponseBuilder {
	return &GroupsOpenCallResponseBuilder{resp: &groupsOpenCallResponse{}}
}
func (v *groupsOpenCallResponse) OK() bool {
	return v.ok
}
func (v *groupsOpenCallResponse) ReplyTo() int {
	return v.replyTo
}
func (v *groupsOpenCallResponse) Error() *objects.ErrorResponse {
	return v.error
}
func (v *groupsOpenCallResponse) Timestamp() string {
	return v.ts
}
func (b *GroupsOpenCallResponseBuilder) OK(v bool) *GroupsOpenCallResponseBuilder {
	b.resp.ok = v
	return b
}
func (b *GroupsOpenCallResponseBuilder) ReplyTo(v int) *GroupsOpenCallResponseBuilder {
	b.resp.replyTo = v
	return b
}
func (b *GroupsOpenCallResponseBuilder) Error(v *objects.ErrorResponse) *GroupsOpenCallResponseBuilder {
	b.resp.error = v
	return b
}
func (b *GroupsOpenCallResponseBuilder) Timestamp(v string) *GroupsOpenCallResponseBuilder {
	b.resp.ts = v
	return b
}
func (b *GroupsOpenCallResponseBuilder) Build() GroupsOpenCallResponse {
	v := b.resp
	b.resp = &groupsOpenCallResponse{}
	return v
}
func (r *groupsOpenCallResponseProxy) parse(data []byte) error {
	if err := json.Unmarshal(data, r); err != nil {
		return errors.Wrap(err, `failed to unmarshal GroupsOpenCallResponse`)
	}
	r.Payload0 = data
	return nil
}
func (r *groupsOpenCallResponse) MarshalJSON() ([]byte, error) {
	var p groupsOpenCallResponseProxy
	p.OK = r.ok
	p.ReplyTo = r.replyTo
	p.Error = r.error
	p.Timestamp = r.ts
	return json.Marshal(p)
}

// Do executes the call to access groups.open endpoint
func (c *GroupsOpenCall) Do(ctx context.Context) error {
	const endpoint = "groups.open"
	v, err := c.Values()
	if err != nil {
		return err
	}
	var res groupsOpenCallResponseProxy
	if err := c.service.client.postForm(ctx, endpoint, v, &res); err != nil {
		return errors.Wrap(err, `failed to post to groups.open`)
	}
	if !res.OK {
		var err error
		if errresp := res.Error; errresp != nil {
			err = errors.New(errresp.String())
		} else {
			err = errors.New(`unknown error while posting to groups.open`)
		}
		return err
	}

	return nil
}

// FromValues parses the data in v and populates `c`
func (c *GroupsOpenCall) FromValues(v url.Values) error {
	var tmp GroupsOpenCall
	if raw := strings.TrimSpace(v.Get("channel")); len(raw) > 0 {
		tmp.channel = raw
	}
	*c = tmp
	return nil
}

// Rename creates a GroupsRenameCall object in preparation for accessing the groups.rename endpoint
func (s *GroupsService) Rename(channel string, name string) *GroupsRenameCall {
	var call GroupsRenameCall
	call.service = s
	call.channel = channel
	call.name = name
	return &call
}

// Validate sets the value for optional validate parameter
func (c *GroupsRenameCall) Validate(validate bool) *GroupsRenameCall {
	c.validate = validate
	return c
}

// ValidateArgs checks that all required fields are set in the GroupsRenameCall object
func (c *GroupsRenameCall) ValidateArgs() error {
	if len(c.channel) <= 0 {
		return errors.New(`required field channel not initialized`)
	}
	if len(c.name) <= 0 {
		return errors.New(`required field name not initialized`)
	}
	return nil
}

// Values returns the GroupsRenameCall object as url.Values
func (c *GroupsRenameCall) Values() (url.Values, error) {
	if err := c.ValidateArgs(); err != nil {
		return nil, errors.Wrap(err, `failed validation`)
	}
	v := url.Values{}
	v.Set(`token`, c.service.token)

	v.Set("channel", c.channel)

	v.Set("name", c.name)

	if c.validate {
		v.Set("validate", "true")
	}
	return v, nil
}

type GroupsRenameCallResponse interface {
	OK() bool
	ReplyTo() int
	Error() *objects.ErrorResponse
	Timestamp() string
	Group() *objects.Group
}

type groupsRenameCallResponseProxy struct {
	OK        bool                   `json:"ok"`
	ReplyTo   int                    `json:"reply_to"`
	Error     *objects.ErrorResponse `json:"error"`
	Timestamp string                 `json:"ts"`
	Payload0  json.RawMessage        `json:"-"`
	Payload1  json.RawMessage        `json:"group"`
}
type groupsRenameCallResponse struct {
	ok      bool
	replyTo int
	error   *objects.ErrorResponse
	ts      string
	group   *objects.Group
}
type GroupsRenameCallResponseBuilder struct {
	resp *groupsRenameCallResponse
}

func BuildGroupsRenameCallResponse() *GroupsRenameCallResponseBuilder {
	return &GroupsRenameCallResponseBuilder{resp: &groupsRenameCallResponse{}}
}
func (v *groupsRenameCallResponse) OK() bool {
	return v.ok
}
func (v *groupsRenameCallResponse) ReplyTo() int {
	return v.replyTo
}
func (v *groupsRenameCallResponse) Error() *objects.ErrorResponse {
	return v.error
}
func (v *groupsRenameCallResponse) Timestamp() string {
	return v.ts
}
func (v *groupsRenameCallResponse) Group() *objects.Group {
	return v.group
}
func (b *GroupsRenameCallResponseBuilder) OK(v bool) *GroupsRenameCallResponseBuilder {
	b.resp.ok = v
	return b
}
func (b *GroupsRenameCallResponseBuilder) ReplyTo(v int) *GroupsRenameCallResponseBuilder {
	b.resp.replyTo = v
	return b
}
func (b *GroupsRenameCallResponseBuilder) Error(v *objects.ErrorResponse) *GroupsRenameCallResponseBuilder {
	b.resp.error = v
	return b
}
func (b *GroupsRenameCallResponseBuilder) Timestamp(v string) *GroupsRenameCallResponseBuilder {
	b.resp.ts = v
	return b
}
func (b *GroupsRenameCallResponseBuilder) Group(v *objects.Group) *GroupsRenameCallResponseBuilder {
	b.resp.group = v
	return b
}
func (b *GroupsRenameCallResponseBuilder) Build() GroupsRenameCallResponse {
	v := b.resp
	b.resp = &groupsRenameCallResponse{}
	return v
}
func (r *groupsRenameCallResponseProxy) parse(data []byte) error {
	if err := json.Unmarshal(data, r); err != nil {
		return errors.Wrap(err, `failed to unmarshal GroupsRenameCallResponse`)
	}
	r.Payload0 = data
	return nil
}
func (r *groupsRenameCallResponseProxy) payload() (*objects.Group, error) {
	var res1 objects.Group
	if err := json.Unmarshal(r.Payload1, &res1); err != nil {
		return nil, errors.Wrap(err, `failed to ummarshal objects.Group from response`)
	}
	return &res1, nil
}
func (r *groupsRenameCallResponse) MarshalJSON() ([]byte, error) {
	var p groupsRenameCallResponseProxy
	p.OK = r.ok
	p.ReplyTo = r.replyTo
	p.Error = r.error
	p.Timestamp = r.ts
	payload1, err := json.Marshal(r.group)
	if err != nil {
		return nil, errors.Wrap(err, `failed to marshal 'group' field`)
	}
	p.Payload1 = payload1
	return json.Marshal(p)
}

// Do executes the call to access groups.rename endpoint
func (c *GroupsRenameCall) Do(ctx context.Context) (*objects.Group, error) {
	const endpoint = "groups.rename"
	v, err := c.Values()
	if err != nil {
		return nil, err
	}
	var res groupsRenameCallResponseProxy
	if err := c.service.client.postForm(ctx, endpoint, v, &res); err != nil {
		return nil, errors.Wrap(err, `failed to post to groups.rename`)
	}
	if !res.OK {
		var err error
		if errresp := res.Error; errresp != nil {
			err = errors.New(errresp.String())
		} else {
			err = errors.New(`unknown error while posting to groups.rename`)
		}
		return nil, err
	}

	return res.payload()
}

// FromValues parses the data in v and populates `c`
func (c *GroupsRenameCall) FromValues(v url.Values) error {
	var tmp GroupsRenameCall
	if raw := strings.TrimSpace(v.Get("channel")); len(raw) > 0 {
		tmp.channel = raw
	}
	if raw := strings.TrimSpace(v.Get("name")); len(raw) > 0 {
		tmp.name = raw
	}
	if raw := strings.TrimSpace(v.Get("validate")); len(raw) > 0 {
		parsed, err := strconv.ParseBool(raw)
		if err != nil {
			return errors.Wrap(err, `failed to parse boolean value "validate"`)
		}
		tmp.validate = parsed
	}
	*c = tmp
	return nil
}

// Replies creates a GroupsRepliesCall object in preparation for accessing the groups.replies endpoint
func (s *GroupsService) Replies(channel string, threadTimestamp string) *GroupsRepliesCall {
	var call GroupsRepliesCall
	call.service = s
	call.channel = channel
	call.threadTimestamp = threadTimestamp
	return &call
}

// ValidateArgs checks that all required fields are set in the GroupsRepliesCall object
func (c *GroupsRepliesCall) ValidateArgs() error {
	if len(c.channel) <= 0 {
		return errors.New(`required field channel not initialized`)
	}
	if len(c.threadTimestamp) <= 0 {
		return errors.New(`required field threadTimestamp not initialized`)
	}
	return nil
}

// Values returns the GroupsRepliesCall object as url.Values
func (c *GroupsRepliesCall) Values() (url.Values, error) {
	if err := c.ValidateArgs(); err != nil {
		return nil, errors.Wrap(err, `failed validation`)
	}
	v := url.Values{}
	v.Set(`token`, c.service.token)

	v.Set("channel", c.channel)

	v.Set("thread_ts", c.threadTimestamp)
	return v, nil
}

type GroupsRepliesCallResponse interface {
	OK() bool
	ReplyTo() int
	Error() *objects.ErrorResponse
	Timestamp() string
	Messages() objects.MessageList
	ThreadInfo() *objects.ThreadInfo
}

type groupsRepliesCallResponseProxy struct {
	OK        bool                   `json:"ok"`
	ReplyTo   int                    `json:"reply_to"`
	Error     *objects.ErrorResponse `json:"error"`
	Timestamp string                 `json:"ts"`
	Payload0  json.RawMessage        `json:"-"`
	Payload1  json.RawMessage        `json:"messages"`
	Payload2  json.RawMessage        `json:"thread_info"`
}
type groupsRepliesCallResponse struct {
	ok          bool
	replyTo     int
	error       *objects.ErrorResponse
	ts          string
	messages    objects.MessageList
	thread_info *objects.ThreadInfo
}
type GroupsRepliesCallResponseBuilder struct {
	resp *groupsRepliesCallResponse
}

func BuildGroupsRepliesCallResponse() *GroupsRepliesCallResponseBuilder {
	return &GroupsRepliesCallResponseBuilder{resp: &groupsRepliesCallResponse{}}
}
func (v *groupsRepliesCallResponse) OK() bool {
	return v.ok
}
func (v *groupsRepliesCallResponse) ReplyTo() int {
	return v.replyTo
}
func (v *groupsRepliesCallResponse) Error() *objects.ErrorResponse {
	return v.error
}
func (v *groupsRepliesCallResponse) Timestamp() string {
	return v.ts
}
func (v *groupsRepliesCallResponse) Messages() objects.MessageList {
	return v.messages
}
func (v *groupsRepliesCallResponse) ThreadInfo() *objects.ThreadInfo {
	return v.thread_info
}
func (b *GroupsRepliesCallResponseBuilder) OK(v bool) *GroupsRepliesCallResponseBuilder {
	b.resp.ok = v
	return b
}
func (b *GroupsRepliesCallResponseBuilder) ReplyTo(v int) *GroupsRepliesCallResponseBuilder {
	b.resp.replyTo = v
	return b
}
func (b *GroupsRepliesCallResponseBuilder) Error(v *objects.ErrorResponse) *GroupsRepliesCallResponseBuilder {
	b.resp.error = v
	return b
}
func (b *GroupsRepliesCallResponseBuilder) Timestamp(v string) *GroupsRepliesCallResponseBuilder {
	b.resp.ts = v
	return b
}
func (b *GroupsRepliesCallResponseBuilder) Messages(v objects.MessageList) *GroupsRepliesCallResponseBuilder {
	b.resp.messages = v
	return b
}
func (b *GroupsRepliesCallResponseBuilder) ThreadInfo(v *objects.ThreadInfo) *GroupsRepliesCallResponseBuilder {
	b.resp.thread_info = v
	return b
}
func (b *GroupsRepliesCallResponseBuilder) Build() GroupsRepliesCallResponse {
	v := b.resp
	b.resp = &groupsRepliesCallResponse{}
	return v
}
func (r *groupsRepliesCallResponseProxy) parse(data []byte) error {
	if err := json.Unmarshal(data, r); err != nil {
		return errors.Wrap(err, `failed to unmarshal GroupsRepliesCallResponse`)
	}
	r.Payload0 = data
	return nil
}
func (r *groupsRepliesCallResponseProxy) payload() (objects.MessageList, *objects.ThreadInfo, error) {
	var res1 objects.MessageList
	if err := json.Unmarshal(r.Payload1, &res1); err != nil {
		return nil, nil, errors.Wrap(err, `failed to ummarshal objects.MessageList from response`)
	}
	var res2 objects.ThreadInfo
	if err := json.Unmarshal(r.Payload2, &res2); err != nil {
		return nil, nil, errors.Wrap(err, `failed to ummarshal objects.ThreadInfo from response`)
	}
	return res1, &res2, nil
}
func (r *groupsRepliesCallResponse) MarshalJSON() ([]byte, error) {
	var p groupsRepliesCallResponseProxy
	p.OK = r.ok
	p.ReplyTo = r.replyTo
	p.Error = r.error
	p.Timestamp = r.ts
	payload1, err := json.Marshal(r.messages)
	if err != nil {
		return nil, errors.Wrap(err, `failed to marshal 'messages' field`)
	}
	p.Payload1 = payload1
	payload2, err := json.Marshal(r.thread_info)
	if err != nil {
		return nil, errors.Wrap(err, `failed to marshal 'thread_info' field`)
	}
	p.Payload2 = payload2
	return json.Marshal(p)
}

// Do executes the call to access groups.replies endpoint
func (c *GroupsRepliesCall) Do(ctx context.Context) (objects.MessageList, *objects.ThreadInfo, error) {
	const endpoint = "groups.replies"
	v, err := c.Values()
	if err != nil {
		return nil, nil, err
	}
	var res groupsRepliesCallResponseProxy
	if err := c.service.client.postForm(ctx, endpoint, v, &res); err != nil {
		return nil, nil, errors.Wrap(err, `failed to post to groups.replies`)
	}
	if !res.OK {
		var err error
		if errresp := res.Error; errresp != nil {
			err = errors.New(errresp.String())
		} else {
			err = errors.New(`unknown error while posting to groups.replies`)
		}
		return nil, nil, err
	}

	return res.payload()
}

// FromValues parses the data in v and populates `c`
func (c *GroupsRepliesCall) FromValues(v url.Values) error {
	var tmp GroupsRepliesCall
	if raw := strings.TrimSpace(v.Get("channel")); len(raw) > 0 {
		tmp.channel = raw
	}
	if raw := strings.TrimSpace(v.Get("thread_ts")); len(raw) > 0 {
		tmp.threadTimestamp = raw
	}
	*c = tmp
	return nil
}

// SetPurpose creates a GroupsSetPurposeCall object in preparation for accessing the groups.setPurpose endpoint
func (s *GroupsService) SetPurpose(channel string, purpose string) *GroupsSetPurposeCall {
	var call GroupsSetPurposeCall
	call.service = s
	call.channel = channel
	call.purpose = purpose
	return &call
}

// ValidateArgs checks that all required fields are set in the GroupsSetPurposeCall object
func (c *GroupsSetPurposeCall) ValidateArgs() error {
	if len(c.channel) <= 0 {
		return errors.New(`required field channel not initialized`)
	}
	if len(c.purpose) <= 0 {
		return errors.New(`required field purpose not initialized`)
	}
	return nil
}

// Values returns the GroupsSetPurposeCall object as url.Values
func (c *GroupsSetPurposeCall) Values() (url.Values, error) {
	if err := c.ValidateArgs(); err != nil {
		return nil, errors.Wrap(err, `failed validation`)
	}
	v := url.Values{}
	v.Set(`token`, c.service.token)

	v.Set("channel", c.channel)

	v.Set("purpose", c.purpose)
	return v, nil
}

type GroupsSetPurposeCallResponse interface {
	OK() bool
	ReplyTo() int
	Error() *objects.ErrorResponse
	Timestamp() string
	Purpose() string
}

type groupsSetPurposeCallResponseProxy struct {
	OK        bool                   `json:"ok"`
	ReplyTo   int                    `json:"reply_to"`
	Error     *objects.ErrorResponse `json:"error"`
	Timestamp string                 `json:"ts"`
	Payload0  json.RawMessage        `json:"-"`
	Payload1  json.RawMessage        `json:"purpose"`
}
type groupsSetPurposeCallResponse struct {
	ok      bool
	replyTo int
	error   *objects.ErrorResponse
	ts      string
	purpose string
}
type GroupsSetPurposeCallResponseBuilder struct {
	resp *groupsSetPurposeCallResponse
}

func BuildGroupsSetPurposeCallResponse() *GroupsSetPurposeCallResponseBuilder {
	return &GroupsSetPurposeCallResponseBuilder{resp: &groupsSetPurposeCallResponse{}}
}
func (v *groupsSetPurposeCallResponse) OK() bool {
	return v.ok
}
func (v *groupsSetPurposeCallResponse) ReplyTo() int {
	return v.replyTo
}
func (v *groupsSetPurposeCallResponse) Error() *objects.ErrorResponse {
	return v.error
}
func (v *groupsSetPurposeCallResponse) Timestamp() string {
	return v.ts
}
func (v *groupsSetPurposeCallResponse) Purpose() string {
	return v.purpose
}
func (b *GroupsSetPurposeCallResponseBuilder) OK(v bool) *GroupsSetPurposeCallResponseBuilder {
	b.resp.ok = v
	return b
}
func (b *GroupsSetPurposeCallResponseBuilder) ReplyTo(v int) *GroupsSetPurposeCallResponseBuilder {
	b.resp.replyTo = v
	return b
}
func (b *GroupsSetPurposeCallResponseBuilder) Error(v *objects.ErrorResponse) *GroupsSetPurposeCallResponseBuilder {
	b.resp.error = v
	return b
}
func (b *GroupsSetPurposeCallResponseBuilder) Timestamp(v string) *GroupsSetPurposeCallResponseBuilder {
	b.resp.ts = v
	return b
}
func (b *GroupsSetPurposeCallResponseBuilder) Purpose(v string) *GroupsSetPurposeCallResponseBuilder {
	b.resp.purpose = v
	return b
}
func (b *GroupsSetPurposeCallResponseBuilder) Build() GroupsSetPurposeCallResponse {
	v := b.resp
	b.resp = &groupsSetPurposeCallResponse{}
	return v
}
func (r *groupsSetPurposeCallResponseProxy) parse(data []byte) error {
	if err := json.Unmarshal(data, r); err != nil {
		return errors.Wrap(err, `failed to unmarshal GroupsSetPurposeCallResponse`)
	}
	r.Payload0 = data
	return nil
}
func (r *groupsSetPurposeCallResponseProxy) payload() (string, error) {
	var res1 string
	if err := json.Unmarshal(r.Payload1, &res1); err != nil {
		return "", errors.Wrap(err, `failed to ummarshal string from response`)
	}
	return res1, nil
}
func (r *groupsSetPurposeCallResponse) MarshalJSON() ([]byte, error) {
	var p groupsSetPurposeCallResponseProxy
	p.OK = r.ok
	p.ReplyTo = r.replyTo
	p.Error = r.error
	p.Timestamp = r.ts
	payload1, err := json.Marshal(r.purpose)
	if err != nil {
		return nil, errors.Wrap(err, `failed to marshal 'purpose' field`)
	}
	p.Payload1 = payload1
	return json.Marshal(p)
}

// Do executes the call to access groups.setPurpose endpoint
func (c *GroupsSetPurposeCall) Do(ctx context.Context) (string, error) {
	const endpoint = "groups.setPurpose"
	v, err := c.Values()
	if err != nil {
		return "", err
	}
	var res groupsSetPurposeCallResponseProxy
	if err := c.service.client.postForm(ctx, endpoint, v, &res); err != nil {
		return "", errors.Wrap(err, `failed to post to groups.setPurpose`)
	}
	if !res.OK {
		var err error
		if errresp := res.Error; errresp != nil {
			err = errors.New(errresp.String())
		} else {
			err = errors.New(`unknown error while posting to groups.setPurpose`)
		}
		return "", err
	}

	return res.payload()
}

// FromValues parses the data in v and populates `c`
func (c *GroupsSetPurposeCall) FromValues(v url.Values) error {
	var tmp GroupsSetPurposeCall
	if raw := strings.TrimSpace(v.Get("channel")); len(raw) > 0 {
		tmp.channel = raw
	}
	if raw := strings.TrimSpace(v.Get("purpose")); len(raw) > 0 {
		tmp.purpose = raw
	}
	*c = tmp
	return nil
}

// SetTopic creates a GroupsSetTopicCall object in preparation for accessing the groups.setTopic endpoint
func (s *GroupsService) SetTopic(channel string, topic string) *GroupsSetTopicCall {
	var call GroupsSetTopicCall
	call.service = s
	call.channel = channel
	call.topic = topic
	return &call
}

// ValidateArgs checks that all required fields are set in the GroupsSetTopicCall object
func (c *GroupsSetTopicCall) ValidateArgs() error {
	if len(c.channel) <= 0 {
		return errors.New(`required field channel not initialized`)
	}
	if len(c.topic) <= 0 {
		return errors.New(`required field topic not initialized`)
	}
	return nil
}

// Values returns the GroupsSetTopicCall object as url.Values
func (c *GroupsSetTopicCall) Values() (url.Values, error) {
	if err := c.ValidateArgs(); err != nil {
		return nil, errors.Wrap(err, `failed validation`)
	}
	v := url.Values{}
	v.Set(`token`, c.service.token)

	v.Set("channel", c.channel)

	v.Set("topic", c.topic)
	return v, nil
}

type GroupsSetTopicCallResponse interface {
	OK() bool
	ReplyTo() int
	Error() *objects.ErrorResponse
	Timestamp() string
	Topic() string
}

type groupsSetTopicCallResponseProxy struct {
	OK        bool                   `json:"ok"`
	ReplyTo   int                    `json:"reply_to"`
	Error     *objects.ErrorResponse `json:"error"`
	Timestamp string                 `json:"ts"`
	Payload0  json.RawMessage        `json:"-"`
	Payload1  json.RawMessage        `json:"topic"`
}
type groupsSetTopicCallResponse struct {
	ok      bool
	replyTo int
	error   *objects.ErrorResponse
	ts      string
	topic   string
}
type GroupsSetTopicCallResponseBuilder struct {
	resp *groupsSetTopicCallResponse
}

func BuildGroupsSetTopicCallResponse() *GroupsSetTopicCallResponseBuilder {
	return &GroupsSetTopicCallResponseBuilder{resp: &groupsSetTopicCallResponse{}}
}
func (v *groupsSetTopicCallResponse) OK() bool {
	return v.ok
}
func (v *groupsSetTopicCallResponse) ReplyTo() int {
	return v.replyTo
}
func (v *groupsSetTopicCallResponse) Error() *objects.ErrorResponse {
	return v.error
}
func (v *groupsSetTopicCallResponse) Timestamp() string {
	return v.ts
}
func (v *groupsSetTopicCallResponse) Topic() string {
	return v.topic
}
func (b *GroupsSetTopicCallResponseBuilder) OK(v bool) *GroupsSetTopicCallResponseBuilder {
	b.resp.ok = v
	return b
}
func (b *GroupsSetTopicCallResponseBuilder) ReplyTo(v int) *GroupsSetTopicCallResponseBuilder {
	b.resp.replyTo = v
	return b
}
func (b *GroupsSetTopicCallResponseBuilder) Error(v *objects.ErrorResponse) *GroupsSetTopicCallResponseBuilder {
	b.resp.error = v
	return b
}
func (b *GroupsSetTopicCallResponseBuilder) Timestamp(v string) *GroupsSetTopicCallResponseBuilder {
	b.resp.ts = v
	return b
}
func (b *GroupsSetTopicCallResponseBuilder) Topic(v string) *GroupsSetTopicCallResponseBuilder {
	b.resp.topic = v
	return b
}
func (b *GroupsSetTopicCallResponseBuilder) Build() GroupsSetTopicCallResponse {
	v := b.resp
	b.resp = &groupsSetTopicCallResponse{}
	return v
}
func (r *groupsSetTopicCallResponseProxy) parse(data []byte) error {
	if err := json.Unmarshal(data, r); err != nil {
		return errors.Wrap(err, `failed to unmarshal GroupsSetTopicCallResponse`)
	}
	r.Payload0 = data
	return nil
}
func (r *groupsSetTopicCallResponseProxy) payload() (string, error) {
	var res1 string
	if err := json.Unmarshal(r.Payload1, &res1); err != nil {
		return "", errors.Wrap(err, `failed to ummarshal string from response`)
	}
	return res1, nil
}
func (r *groupsSetTopicCallResponse) MarshalJSON() ([]byte, error) {
	var p groupsSetTopicCallResponseProxy
	p.OK = r.ok
	p.ReplyTo = r.replyTo
	p.Error = r.error
	p.Timestamp = r.ts
	payload1, err := json.Marshal(r.topic)
	if err != nil {
		return nil, errors.Wrap(err, `failed to marshal 'topic' field`)
	}
	p.Payload1 = payload1
	return json.Marshal(p)
}

// Do executes the call to access groups.setTopic endpoint
func (c *GroupsSetTopicCall) Do(ctx context.Context) (string, error) {
	const endpoint = "groups.setTopic"
	v, err := c.Values()
	if err != nil {
		return "", err
	}
	var res groupsSetTopicCallResponseProxy
	if err := c.service.client.postForm(ctx, endpoint, v, &res); err != nil {
		return "", errors.Wrap(err, `failed to post to groups.setTopic`)
	}
	if !res.OK {
		var err error
		if errresp := res.Error; errresp != nil {
			err = errors.New(errresp.String())
		} else {
			err = errors.New(`unknown error while posting to groups.setTopic`)
		}
		return "", err
	}

	return res.payload()
}

// FromValues parses the data in v and populates `c`
func (c *GroupsSetTopicCall) FromValues(v url.Values) error {
	var tmp GroupsSetTopicCall
	if raw := strings.TrimSpace(v.Get("channel")); len(raw) > 0 {
		tmp.channel = raw
	}
	if raw := strings.TrimSpace(v.Get("topic")); len(raw) > 0 {
		tmp.topic = raw
	}
	*c = tmp
	return nil
}

// Unarchive creates a GroupsUnarchiveCall object in preparation for accessing the groups.unarchive endpoint
func (s *GroupsService) Unarchive(channel string) *GroupsUnarchiveCall {
	var call GroupsUnarchiveCall
	call.service = s
	call.channel = channel
	return &call
}

// ValidateArgs checks that all required fields are set in the GroupsUnarchiveCall object
func (c *GroupsUnarchiveCall) ValidateArgs() error {
	if len(c.channel) <= 0 {
		return errors.New(`required field channel not initialized`)
	}
	return nil
}

// Values returns the GroupsUnarchiveCall object as url.Values
func (c *GroupsUnarchiveCall) Values() (url.Values, error) {
	if err := c.ValidateArgs(); err != nil {
		return nil, errors.Wrap(err, `failed validation`)
	}
	v := url.Values{}
	v.Set(`token`, c.service.token)

	v.Set("channel", c.channel)
	return v, nil
}

type GroupsUnarchiveCallResponse interface {
	OK() bool
	ReplyTo() int
	Error() *objects.ErrorResponse
	Timestamp() string
}

type groupsUnarchiveCallResponseProxy struct {
	OK        bool                   `json:"ok"`
	ReplyTo   int                    `json:"reply_to"`
	Error     *objects.ErrorResponse `json:"error"`
	Timestamp string                 `json:"ts"`
	Payload0  json.RawMessage        `json:"-"`
}
type groupsUnarchiveCallResponse struct {
	ok      bool
	replyTo int
	error   *objects.ErrorResponse
	ts      string
}
type GroupsUnarchiveCallResponseBuilder struct {
	resp *groupsUnarchiveCallResponse
}

func BuildGroupsUnarchiveCallResponse() *GroupsUnarchiveCallResponseBuilder {
	return &GroupsUnarchiveCallResponseBuilder{resp: &groupsUnarchiveCallResponse{}}
}
func (v *groupsUnarchiveCallResponse) OK() bool {
	return v.ok
}
func (v *groupsUnarchiveCallResponse) ReplyTo() int {
	return v.replyTo
}
func (v *groupsUnarchiveCallResponse) Error() *objects.ErrorResponse {
	return v.error
}
func (v *groupsUnarchiveCallResponse) Timestamp() string {
	return v.ts
}
func (b *GroupsUnarchiveCallResponseBuilder) OK(v bool) *GroupsUnarchiveCallResponseBuilder {
	b.resp.ok = v
	return b
}
func (b *GroupsUnarchiveCallResponseBuilder) ReplyTo(v int) *GroupsUnarchiveCallResponseBuilder {
	b.resp.replyTo = v
	return b
}
func (b *GroupsUnarchiveCallResponseBuilder) Error(v *objects.ErrorResponse) *GroupsUnarchiveCallResponseBuilder {
	b.resp.error = v
	return b
}
func (b *GroupsUnarchiveCallResponseBuilder) Timestamp(v string) *GroupsUnarchiveCallResponseBuilder {
	b.resp.ts = v
	return b
}
func (b *GroupsUnarchiveCallResponseBuilder) Build() GroupsUnarchiveCallResponse {
	v := b.resp
	b.resp = &groupsUnarchiveCallResponse{}
	return v
}
func (r *groupsUnarchiveCallResponseProxy) parse(data []byte) error {
	if err := json.Unmarshal(data, r); err != nil {
		return errors.Wrap(err, `failed to unmarshal GroupsUnarchiveCallResponse`)
	}
	r.Payload0 = data
	return nil
}
func (r *groupsUnarchiveCallResponse) MarshalJSON() ([]byte, error) {
	var p groupsUnarchiveCallResponseProxy
	p.OK = r.ok
	p.ReplyTo = r.replyTo
	p.Error = r.error
	p.Timestamp = r.ts
	return json.Marshal(p)
}

// Do executes the call to access groups.unarchive endpoint
func (c *GroupsUnarchiveCall) Do(ctx context.Context) error {
	const endpoint = "groups.unarchive"
	v, err := c.Values()
	if err != nil {
		return err
	}
	var res groupsUnarchiveCallResponseProxy
	if err := c.service.client.postForm(ctx, endpoint, v, &res); err != nil {
		return errors.Wrap(err, `failed to post to groups.unarchive`)
	}
	if !res.OK {
		var err error
		if errresp := res.Error; errresp != nil {
			err = errors.New(errresp.String())
		} else {
			err = errors.New(`unknown error while posting to groups.unarchive`)
		}
		return err
	}

	return nil
}

// FromValues parses the data in v and populates `c`
func (c *GroupsUnarchiveCall) FromValues(v url.Values) error {
	var tmp GroupsUnarchiveCall
	if raw := strings.TrimSpace(v.Get("channel")); len(raw) > 0 {
		tmp.channel = raw
	}
	*c = tmp
	return nil
}
