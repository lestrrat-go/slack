package slack

// Auto-generated by internal/cmd/genmethods/genmethods.go (generateServiceDetailsFile). DO NOT EDIT!

import (
	"context"
	"encoding/json"
	"net/url"
	"strconv"
	"strings"

	"github.com/lestrrat-go/slack/objects"
	"github.com/pkg/errors"
)

var _ = strconv.Itoa
var _ = strings.Index
var _ = json.Marshal
var _ = objects.EpochTime(0)

// GroupsArchiveCall is created by GroupsService.Archive method call
type GroupsArchiveCall struct {
	service *GroupsService
	channel string
}

// GroupsCreateCall is created by GroupsService.Create method call
type GroupsCreateCall struct {
	service  *GroupsService
	name     string
	validate bool
}

// GroupsCreateChildCall is created by GroupsService.CreateChild method call
type GroupsCreateChildCall struct {
	service *GroupsService
	channel string
}

// GroupsHistoryCall is created by GroupsService.History method call
type GroupsHistoryCall struct {
	service   *GroupsService
	channel   string
	count     int
	inclusive bool
	latest    string
	oldest    string
	unreads   bool
}

// GroupsInfoCall is created by GroupsService.Info method call
type GroupsInfoCall struct {
	service       *GroupsService
	channel       string
	includeLocale bool
}

// GroupsInviteCall is created by GroupsService.Invite method call
type GroupsInviteCall struct {
	service *GroupsService
	channel string
	user    string
}

// GroupsKickCall is created by GroupsService.Kick method call
type GroupsKickCall struct {
	service *GroupsService
	channel string
	user    string
}

// GroupsLeaveCall is created by GroupsService.Leave method call
type GroupsLeaveCall struct {
	service *GroupsService
	channel string
}

// GroupsListCall is created by GroupsService.List method call
type GroupsListCall struct {
	service         *GroupsService
	excludeArchived bool
	excludeMembers  bool
}

// GroupsMarkCall is created by GroupsService.Mark method call
type GroupsMarkCall struct {
	service   *GroupsService
	channel   string
	timestamp string
}

// GroupsOpenCall is created by GroupsService.Open method call
type GroupsOpenCall struct {
	service *GroupsService
	channel string
}

// GroupsRenameCall is created by GroupsService.Rename method call
type GroupsRenameCall struct {
	service  *GroupsService
	channel  string
	name     string
	validate bool
}

// GroupsRepliesCall is created by GroupsService.Replies method call
type GroupsRepliesCall struct {
	service         *GroupsService
	channel         string
	threadTimestamp string
}

// GroupsSetPurposeCall is created by GroupsService.SetPurpose method call
type GroupsSetPurposeCall struct {
	service *GroupsService
	channel string
	purpose string
}

// GroupsSetTopicCall is created by GroupsService.SetTopic method call
type GroupsSetTopicCall struct {
	service *GroupsService
	channel string
	topic   string
}

// GroupsUnarchiveCall is created by GroupsService.Unarchive method call
type GroupsUnarchiveCall struct {
	service *GroupsService
	channel string
}

// Archive creates a GroupsArchiveCall object in preparation for accessing the groups.archive endpoint
func (s *GroupsService) Archive(channel string) *GroupsArchiveCall {
	var call GroupsArchiveCall
	call.service = s
	call.channel = channel
	return &call
}

// ValidateArgs checks that all required fields are set in the GroupsArchiveCall object
func (c *GroupsArchiveCall) ValidateArgs() error {
	if len(c.channel) <= 0 {
		return errors.New(`required field channel not initialized`)
	}
	return nil
}

// Values returns the GroupsArchiveCall object as url.Values
func (c *GroupsArchiveCall) Values() (url.Values, error) {
	if err := c.ValidateArgs(); err != nil {
		return nil, errors.Wrap(err, `failed validation`)
	}
	v := url.Values{}
	v.Set(`token`, c.service.token)

	v.Set("channel", c.channel)
	return v, nil
}

// Do executes the call to access groups.archive endpoint
func (c *GroupsArchiveCall) Do(ctx context.Context) error {
	const endpoint = "groups.archive"
	v, err := c.Values()
	if err != nil {
		return err
	}
	var res struct {
		objects.GenericResponse
	}
	if err := c.service.client.postForm(ctx, endpoint, v, &res); err != nil {
		return errors.Wrap(err, `failed to post to groups.archive`)
	}
	if !res.OK() {
		return errors.New(res.Error().String())
	}

	return nil
}

// FromValues parses the data in v and populates `c`
func (c *GroupsArchiveCall) FromValues(v url.Values) error {
	var tmp GroupsArchiveCall
	if raw := strings.TrimSpace(v.Get("channel")); len(raw) > 0 {
		tmp.channel = raw
	}
	*c = tmp
	return nil
}

// Create creates a GroupsCreateCall object in preparation for accessing the groups.create endpoint
func (s *GroupsService) Create(name string) *GroupsCreateCall {
	var call GroupsCreateCall
	call.service = s
	call.name = name
	return &call
}

// Validate sets the value for optional validate parameter
func (c *GroupsCreateCall) Validate(validate bool) *GroupsCreateCall {
	c.validate = validate
	return c
}

// ValidateArgs checks that all required fields are set in the GroupsCreateCall object
func (c *GroupsCreateCall) ValidateArgs() error {
	if len(c.name) <= 0 {
		return errors.New(`required field name not initialized`)
	}
	return nil
}

// Values returns the GroupsCreateCall object as url.Values
func (c *GroupsCreateCall) Values() (url.Values, error) {
	if err := c.ValidateArgs(); err != nil {
		return nil, errors.Wrap(err, `failed validation`)
	}
	v := url.Values{}
	v.Set(`token`, c.service.token)

	v.Set("name", c.name)

	if c.validate {
		v.Set("validate", "true")
	}
	return v, nil
}

// Do executes the call to access groups.create endpoint
func (c *GroupsCreateCall) Do(ctx context.Context) (*objects.Group, error) {
	const endpoint = "groups.create"
	v, err := c.Values()
	if err != nil {
		return nil, err
	}
	var res struct {
		objects.GenericResponse
		*objects.Group `json:"group"`
	}
	if err := c.service.client.postForm(ctx, endpoint, v, &res); err != nil {
		return nil, errors.Wrap(err, `failed to post to groups.create`)
	}
	if !res.OK() {
		return nil, errors.New(res.Error().String())
	}

	return res.Group, nil
}

// FromValues parses the data in v and populates `c`
func (c *GroupsCreateCall) FromValues(v url.Values) error {
	var tmp GroupsCreateCall
	if raw := strings.TrimSpace(v.Get("name")); len(raw) > 0 {
		tmp.name = raw
	}
	if raw := strings.TrimSpace(v.Get("validate")); len(raw) > 0 {
		parsed, err := strconv.ParseBool(raw)
		if err != nil {
			return errors.Wrap(err, `failed to parse boolean value "validate"`)
		}
		tmp.validate = parsed
	}
	*c = tmp
	return nil
}

// CreateChild creates a GroupsCreateChildCall object in preparation for accessing the groups.createChild endpoint
func (s *GroupsService) CreateChild(channel string) *GroupsCreateChildCall {
	var call GroupsCreateChildCall
	call.service = s
	call.channel = channel
	return &call
}

// ValidateArgs checks that all required fields are set in the GroupsCreateChildCall object
func (c *GroupsCreateChildCall) ValidateArgs() error {
	if len(c.channel) <= 0 {
		return errors.New(`required field channel not initialized`)
	}
	return nil
}

// Values returns the GroupsCreateChildCall object as url.Values
func (c *GroupsCreateChildCall) Values() (url.Values, error) {
	if err := c.ValidateArgs(); err != nil {
		return nil, errors.Wrap(err, `failed validation`)
	}
	v := url.Values{}
	v.Set(`token`, c.service.token)

	v.Set("channel", c.channel)
	return v, nil
}

// Do executes the call to access groups.createChild endpoint
func (c *GroupsCreateChildCall) Do(ctx context.Context) (*objects.Group, error) {
	const endpoint = "groups.createChild"
	v, err := c.Values()
	if err != nil {
		return nil, err
	}
	var res struct {
		objects.GenericResponse
		*objects.Group `json:"group"`
	}
	if err := c.service.client.postForm(ctx, endpoint, v, &res); err != nil {
		return nil, errors.Wrap(err, `failed to post to groups.createChild`)
	}
	if !res.OK() {
		return nil, errors.New(res.Error().String())
	}

	return res.Group, nil
}

// FromValues parses the data in v and populates `c`
func (c *GroupsCreateChildCall) FromValues(v url.Values) error {
	var tmp GroupsCreateChildCall
	if raw := strings.TrimSpace(v.Get("channel")); len(raw) > 0 {
		tmp.channel = raw
	}
	*c = tmp
	return nil
}

// History creates a GroupsHistoryCall object in preparation for accessing the groups.history endpoint
func (s *GroupsService) History(channel string) *GroupsHistoryCall {
	var call GroupsHistoryCall
	call.service = s
	call.channel = channel
	return &call
}

// Count sets the value for optional count parameter
func (c *GroupsHistoryCall) Count(count int) *GroupsHistoryCall {
	c.count = count
	return c
}

// Inclusive sets the value for optional inclusive parameter
func (c *GroupsHistoryCall) Inclusive(inclusive bool) *GroupsHistoryCall {
	c.inclusive = inclusive
	return c
}

// Latest sets the value for optional latest parameter
func (c *GroupsHistoryCall) Latest(latest string) *GroupsHistoryCall {
	c.latest = latest
	return c
}

// Oldest sets the value for optional oldest parameter
func (c *GroupsHistoryCall) Oldest(oldest string) *GroupsHistoryCall {
	c.oldest = oldest
	return c
}

// Unreads sets the value for optional unreads parameter
func (c *GroupsHistoryCall) Unreads(unreads bool) *GroupsHistoryCall {
	c.unreads = unreads
	return c
}

// ValidateArgs checks that all required fields are set in the GroupsHistoryCall object
func (c *GroupsHistoryCall) ValidateArgs() error {
	if len(c.channel) <= 0 {
		return errors.New(`required field channel not initialized`)
	}
	return nil
}

// Values returns the GroupsHistoryCall object as url.Values
func (c *GroupsHistoryCall) Values() (url.Values, error) {
	if err := c.ValidateArgs(); err != nil {
		return nil, errors.Wrap(err, `failed validation`)
	}
	v := url.Values{}
	v.Set(`token`, c.service.token)

	v.Set("channel", c.channel)

	if c.count > 0 {
		v.Set("count", strconv.Itoa(c.count))
	}

	if c.inclusive {
		v.Set("inclusive", "true")
	}

	if len(c.latest) > 0 {
		v.Set("latest", c.latest)
	}

	if len(c.oldest) > 0 {
		v.Set("oldest", c.oldest)
	}

	if c.unreads {
		v.Set("unreads", "true")
	}
	return v, nil
}

// Do executes the call to access groups.history endpoint
func (c *GroupsHistoryCall) Do(ctx context.Context) (string, objects.MessageList, error) {
	const endpoint = "groups.history"
	v, err := c.Values()
	if err != nil {
		return "", nil, err
	}
	var res struct {
		objects.GenericResponse
		string              `json:"latest"`
		objects.MessageList `json:"messages"`
	}
	if err := c.service.client.postForm(ctx, endpoint, v, &res); err != nil {
		return "", nil, errors.Wrap(err, `failed to post to groups.history`)
	}
	if !res.OK() {
		return "", nil, errors.New(res.Error().String())
	}

	return res.string, res.MessageList, nil
}

// FromValues parses the data in v and populates `c`
func (c *GroupsHistoryCall) FromValues(v url.Values) error {
	var tmp GroupsHistoryCall
	if raw := strings.TrimSpace(v.Get("channel")); len(raw) > 0 {
		tmp.channel = raw
	}
	if raw := strings.TrimSpace(v.Get("count")); len(raw) > 0 {
		parsed, err := strconv.ParseInt(raw, 10, 64)
		if err != nil {
			return errors.Wrap(err, `failed to parse integer value "count"`)
		}
		tmp.count = int(parsed)
	}
	if raw := strings.TrimSpace(v.Get("inclusive")); len(raw) > 0 {
		parsed, err := strconv.ParseBool(raw)
		if err != nil {
			return errors.Wrap(err, `failed to parse boolean value "inclusive"`)
		}
		tmp.inclusive = parsed
	}
	if raw := strings.TrimSpace(v.Get("latest")); len(raw) > 0 {
		tmp.latest = raw
	}
	if raw := strings.TrimSpace(v.Get("oldest")); len(raw) > 0 {
		tmp.oldest = raw
	}
	if raw := strings.TrimSpace(v.Get("unreads")); len(raw) > 0 {
		parsed, err := strconv.ParseBool(raw)
		if err != nil {
			return errors.Wrap(err, `failed to parse boolean value "unreads"`)
		}
		tmp.unreads = parsed
	}
	*c = tmp
	return nil
}

// Info creates a GroupsInfoCall object in preparation for accessing the groups.info endpoint
func (s *GroupsService) Info(channel string) *GroupsInfoCall {
	var call GroupsInfoCall
	call.service = s
	call.channel = channel
	return &call
}

// IncludeLocale sets the value for optional includeLocale parameter
func (c *GroupsInfoCall) IncludeLocale(includeLocale bool) *GroupsInfoCall {
	c.includeLocale = includeLocale
	return c
}

// ValidateArgs checks that all required fields are set in the GroupsInfoCall object
func (c *GroupsInfoCall) ValidateArgs() error {
	if len(c.channel) <= 0 {
		return errors.New(`required field channel not initialized`)
	}
	return nil
}

// Values returns the GroupsInfoCall object as url.Values
func (c *GroupsInfoCall) Values() (url.Values, error) {
	if err := c.ValidateArgs(); err != nil {
		return nil, errors.Wrap(err, `failed validation`)
	}
	v := url.Values{}
	v.Set(`token`, c.service.token)

	v.Set("channel", c.channel)

	if c.includeLocale {
		v.Set("include_locale", "true")
	}
	return v, nil
}

// Do executes the call to access groups.info endpoint
func (c *GroupsInfoCall) Do(ctx context.Context) (*objects.Group, error) {
	const endpoint = "groups.info"
	v, err := c.Values()
	if err != nil {
		return nil, err
	}
	var res struct {
		objects.GenericResponse
		*objects.Group `json:"group"`
	}
	if err := c.service.client.postForm(ctx, endpoint, v, &res); err != nil {
		return nil, errors.Wrap(err, `failed to post to groups.info`)
	}
	if !res.OK() {
		return nil, errors.New(res.Error().String())
	}

	return res.Group, nil
}

// FromValues parses the data in v and populates `c`
func (c *GroupsInfoCall) FromValues(v url.Values) error {
	var tmp GroupsInfoCall
	if raw := strings.TrimSpace(v.Get("channel")); len(raw) > 0 {
		tmp.channel = raw
	}
	if raw := strings.TrimSpace(v.Get("include_locale")); len(raw) > 0 {
		parsed, err := strconv.ParseBool(raw)
		if err != nil {
			return errors.Wrap(err, `failed to parse boolean value "include_locale"`)
		}
		tmp.includeLocale = parsed
	}
	*c = tmp
	return nil
}

// Invite creates a GroupsInviteCall object in preparation for accessing the groups.invite endpoint
func (s *GroupsService) Invite(channel string, user string) *GroupsInviteCall {
	var call GroupsInviteCall
	call.service = s
	call.channel = channel
	call.user = user
	return &call
}

// ValidateArgs checks that all required fields are set in the GroupsInviteCall object
func (c *GroupsInviteCall) ValidateArgs() error {
	if len(c.channel) <= 0 {
		return errors.New(`required field channel not initialized`)
	}
	if len(c.user) <= 0 {
		return errors.New(`required field user not initialized`)
	}
	return nil
}

// Values returns the GroupsInviteCall object as url.Values
func (c *GroupsInviteCall) Values() (url.Values, error) {
	if err := c.ValidateArgs(); err != nil {
		return nil, errors.Wrap(err, `failed validation`)
	}
	v := url.Values{}
	v.Set(`token`, c.service.token)

	v.Set("channel", c.channel)

	v.Set("user", c.user)
	return v, nil
}

// Do executes the call to access groups.invite endpoint
func (c *GroupsInviteCall) Do(ctx context.Context) (*objects.Group, bool, error) {
	const endpoint = "groups.invite"
	v, err := c.Values()
	if err != nil {
		return nil, false, err
	}
	var res struct {
		objects.GenericResponse
		*objects.Group `json:"group"`
		bool           `json:"already_in_group"`
	}
	if err := c.service.client.postForm(ctx, endpoint, v, &res); err != nil {
		return nil, false, errors.Wrap(err, `failed to post to groups.invite`)
	}
	if !res.OK() {
		return nil, false, errors.New(res.Error().String())
	}

	return res.Group, res.bool, nil
}

// FromValues parses the data in v and populates `c`
func (c *GroupsInviteCall) FromValues(v url.Values) error {
	var tmp GroupsInviteCall
	if raw := strings.TrimSpace(v.Get("channel")); len(raw) > 0 {
		tmp.channel = raw
	}
	if raw := strings.TrimSpace(v.Get("user")); len(raw) > 0 {
		tmp.user = raw
	}
	*c = tmp
	return nil
}

// Kick creates a GroupsKickCall object in preparation for accessing the groups.kick endpoint
func (s *GroupsService) Kick(channel string, user string) *GroupsKickCall {
	var call GroupsKickCall
	call.service = s
	call.channel = channel
	call.user = user
	return &call
}

// ValidateArgs checks that all required fields are set in the GroupsKickCall object
func (c *GroupsKickCall) ValidateArgs() error {
	if len(c.channel) <= 0 {
		return errors.New(`required field channel not initialized`)
	}
	if len(c.user) <= 0 {
		return errors.New(`required field user not initialized`)
	}
	return nil
}

// Values returns the GroupsKickCall object as url.Values
func (c *GroupsKickCall) Values() (url.Values, error) {
	if err := c.ValidateArgs(); err != nil {
		return nil, errors.Wrap(err, `failed validation`)
	}
	v := url.Values{}
	v.Set(`token`, c.service.token)

	v.Set("channel", c.channel)

	v.Set("user", c.user)
	return v, nil
}

// Do executes the call to access groups.kick endpoint
func (c *GroupsKickCall) Do(ctx context.Context) error {
	const endpoint = "groups.kick"
	v, err := c.Values()
	if err != nil {
		return err
	}
	var res struct {
		objects.GenericResponse
	}
	if err := c.service.client.postForm(ctx, endpoint, v, &res); err != nil {
		return errors.Wrap(err, `failed to post to groups.kick`)
	}
	if !res.OK() {
		return errors.New(res.Error().String())
	}

	return nil
}

// FromValues parses the data in v and populates `c`
func (c *GroupsKickCall) FromValues(v url.Values) error {
	var tmp GroupsKickCall
	if raw := strings.TrimSpace(v.Get("channel")); len(raw) > 0 {
		tmp.channel = raw
	}
	if raw := strings.TrimSpace(v.Get("user")); len(raw) > 0 {
		tmp.user = raw
	}
	*c = tmp
	return nil
}

// Leave creates a GroupsLeaveCall object in preparation for accessing the groups.leave endpoint
func (s *GroupsService) Leave(channel string) *GroupsLeaveCall {
	var call GroupsLeaveCall
	call.service = s
	call.channel = channel
	return &call
}

// ValidateArgs checks that all required fields are set in the GroupsLeaveCall object
func (c *GroupsLeaveCall) ValidateArgs() error {
	if len(c.channel) <= 0 {
		return errors.New(`required field channel not initialized`)
	}
	return nil
}

// Values returns the GroupsLeaveCall object as url.Values
func (c *GroupsLeaveCall) Values() (url.Values, error) {
	if err := c.ValidateArgs(); err != nil {
		return nil, errors.Wrap(err, `failed validation`)
	}
	v := url.Values{}
	v.Set(`token`, c.service.token)

	v.Set("channel", c.channel)
	return v, nil
}

// Do executes the call to access groups.leave endpoint
func (c *GroupsLeaveCall) Do(ctx context.Context) error {
	const endpoint = "groups.leave"
	v, err := c.Values()
	if err != nil {
		return err
	}
	var res struct {
		objects.GenericResponse
	}
	if err := c.service.client.postForm(ctx, endpoint, v, &res); err != nil {
		return errors.Wrap(err, `failed to post to groups.leave`)
	}
	if !res.OK() {
		return errors.New(res.Error().String())
	}

	return nil
}

// FromValues parses the data in v and populates `c`
func (c *GroupsLeaveCall) FromValues(v url.Values) error {
	var tmp GroupsLeaveCall
	if raw := strings.TrimSpace(v.Get("channel")); len(raw) > 0 {
		tmp.channel = raw
	}
	*c = tmp
	return nil
}

// List creates a GroupsListCall object in preparation for accessing the groups.list endpoint
func (s *GroupsService) List() *GroupsListCall {
	var call GroupsListCall
	call.service = s
	return &call
}

// ExcludeArchived sets the value for optional excludeArchived parameter
func (c *GroupsListCall) ExcludeArchived(excludeArchived bool) *GroupsListCall {
	c.excludeArchived = excludeArchived
	return c
}

// ExcludeMembers sets the value for optional excludeMembers parameter
func (c *GroupsListCall) ExcludeMembers(excludeMembers bool) *GroupsListCall {
	c.excludeMembers = excludeMembers
	return c
}

// ValidateArgs checks that all required fields are set in the GroupsListCall object
func (c *GroupsListCall) ValidateArgs() error {
	return nil
}

// Values returns the GroupsListCall object as url.Values
func (c *GroupsListCall) Values() (url.Values, error) {
	if err := c.ValidateArgs(); err != nil {
		return nil, errors.Wrap(err, `failed validation`)
	}
	v := url.Values{}
	v.Set(`token`, c.service.token)

	if c.excludeArchived {
		v.Set("exclude_archived", "true")
	}

	if c.excludeMembers {
		v.Set("exclude_members", "true")
	}
	return v, nil
}

// Do executes the call to access groups.list endpoint
func (c *GroupsListCall) Do(ctx context.Context) (objects.GroupList, error) {
	const endpoint = "groups.list"
	v, err := c.Values()
	if err != nil {
		return nil, err
	}
	var res struct {
		objects.GenericResponse
		objects.GroupList `json:"groups"`
	}
	if err := c.service.client.postForm(ctx, endpoint, v, &res); err != nil {
		return nil, errors.Wrap(err, `failed to post to groups.list`)
	}
	if !res.OK() {
		return nil, errors.New(res.Error().String())
	}

	return res.GroupList, nil
}

// FromValues parses the data in v and populates `c`
func (c *GroupsListCall) FromValues(v url.Values) error {
	var tmp GroupsListCall
	if raw := strings.TrimSpace(v.Get("exclude_archived")); len(raw) > 0 {
		parsed, err := strconv.ParseBool(raw)
		if err != nil {
			return errors.Wrap(err, `failed to parse boolean value "exclude_archived"`)
		}
		tmp.excludeArchived = parsed
	}
	if raw := strings.TrimSpace(v.Get("exclude_members")); len(raw) > 0 {
		parsed, err := strconv.ParseBool(raw)
		if err != nil {
			return errors.Wrap(err, `failed to parse boolean value "exclude_members"`)
		}
		tmp.excludeMembers = parsed
	}
	*c = tmp
	return nil
}

// Mark creates a GroupsMarkCall object in preparation for accessing the groups.mark endpoint
func (s *GroupsService) Mark(channel string, timestamp string) *GroupsMarkCall {
	var call GroupsMarkCall
	call.service = s
	call.channel = channel
	call.timestamp = timestamp
	return &call
}

// ValidateArgs checks that all required fields are set in the GroupsMarkCall object
func (c *GroupsMarkCall) ValidateArgs() error {
	if len(c.channel) <= 0 {
		return errors.New(`required field channel not initialized`)
	}
	if len(c.timestamp) <= 0 {
		return errors.New(`required field timestamp not initialized`)
	}
	return nil
}

// Values returns the GroupsMarkCall object as url.Values
func (c *GroupsMarkCall) Values() (url.Values, error) {
	if err := c.ValidateArgs(); err != nil {
		return nil, errors.Wrap(err, `failed validation`)
	}
	v := url.Values{}
	v.Set(`token`, c.service.token)

	v.Set("channel", c.channel)

	v.Set("ts", c.timestamp)
	return v, nil
}

// Do executes the call to access groups.mark endpoint
func (c *GroupsMarkCall) Do(ctx context.Context) error {
	const endpoint = "groups.mark"
	v, err := c.Values()
	if err != nil {
		return err
	}
	var res struct {
		objects.GenericResponse
	}
	if err := c.service.client.postForm(ctx, endpoint, v, &res); err != nil {
		return errors.Wrap(err, `failed to post to groups.mark`)
	}
	if !res.OK() {
		return errors.New(res.Error().String())
	}

	return nil
}

// FromValues parses the data in v and populates `c`
func (c *GroupsMarkCall) FromValues(v url.Values) error {
	var tmp GroupsMarkCall
	if raw := strings.TrimSpace(v.Get("channel")); len(raw) > 0 {
		tmp.channel = raw
	}
	if raw := strings.TrimSpace(v.Get("ts")); len(raw) > 0 {
		tmp.timestamp = raw
	}
	*c = tmp
	return nil
}

// Open creates a GroupsOpenCall object in preparation for accessing the groups.open endpoint
func (s *GroupsService) Open(channel string) *GroupsOpenCall {
	var call GroupsOpenCall
	call.service = s
	call.channel = channel
	return &call
}

// ValidateArgs checks that all required fields are set in the GroupsOpenCall object
func (c *GroupsOpenCall) ValidateArgs() error {
	if len(c.channel) <= 0 {
		return errors.New(`required field channel not initialized`)
	}
	return nil
}

// Values returns the GroupsOpenCall object as url.Values
func (c *GroupsOpenCall) Values() (url.Values, error) {
	if err := c.ValidateArgs(); err != nil {
		return nil, errors.Wrap(err, `failed validation`)
	}
	v := url.Values{}
	v.Set(`token`, c.service.token)

	v.Set("channel", c.channel)
	return v, nil
}

// Do executes the call to access groups.open endpoint
func (c *GroupsOpenCall) Do(ctx context.Context) error {
	const endpoint = "groups.open"
	v, err := c.Values()
	if err != nil {
		return err
	}
	var res struct {
		objects.GenericResponse
	}
	if err := c.service.client.postForm(ctx, endpoint, v, &res); err != nil {
		return errors.Wrap(err, `failed to post to groups.open`)
	}
	if !res.OK() {
		return errors.New(res.Error().String())
	}

	return nil
}

// FromValues parses the data in v and populates `c`
func (c *GroupsOpenCall) FromValues(v url.Values) error {
	var tmp GroupsOpenCall
	if raw := strings.TrimSpace(v.Get("channel")); len(raw) > 0 {
		tmp.channel = raw
	}
	*c = tmp
	return nil
}

// Rename creates a GroupsRenameCall object in preparation for accessing the groups.rename endpoint
func (s *GroupsService) Rename(channel string, name string) *GroupsRenameCall {
	var call GroupsRenameCall
	call.service = s
	call.channel = channel
	call.name = name
	return &call
}

// Validate sets the value for optional validate parameter
func (c *GroupsRenameCall) Validate(validate bool) *GroupsRenameCall {
	c.validate = validate
	return c
}

// ValidateArgs checks that all required fields are set in the GroupsRenameCall object
func (c *GroupsRenameCall) ValidateArgs() error {
	if len(c.channel) <= 0 {
		return errors.New(`required field channel not initialized`)
	}
	if len(c.name) <= 0 {
		return errors.New(`required field name not initialized`)
	}
	return nil
}

// Values returns the GroupsRenameCall object as url.Values
func (c *GroupsRenameCall) Values() (url.Values, error) {
	if err := c.ValidateArgs(); err != nil {
		return nil, errors.Wrap(err, `failed validation`)
	}
	v := url.Values{}
	v.Set(`token`, c.service.token)

	v.Set("channel", c.channel)

	v.Set("name", c.name)

	if c.validate {
		v.Set("validate", "true")
	}
	return v, nil
}

// Do executes the call to access groups.rename endpoint
func (c *GroupsRenameCall) Do(ctx context.Context) (*objects.Group, error) {
	const endpoint = "groups.rename"
	v, err := c.Values()
	if err != nil {
		return nil, err
	}
	var res struct {
		objects.GenericResponse
		*objects.Group `json:"group"`
	}
	if err := c.service.client.postForm(ctx, endpoint, v, &res); err != nil {
		return nil, errors.Wrap(err, `failed to post to groups.rename`)
	}
	if !res.OK() {
		return nil, errors.New(res.Error().String())
	}

	return res.Group, nil
}

// FromValues parses the data in v and populates `c`
func (c *GroupsRenameCall) FromValues(v url.Values) error {
	var tmp GroupsRenameCall
	if raw := strings.TrimSpace(v.Get("channel")); len(raw) > 0 {
		tmp.channel = raw
	}
	if raw := strings.TrimSpace(v.Get("name")); len(raw) > 0 {
		tmp.name = raw
	}
	if raw := strings.TrimSpace(v.Get("validate")); len(raw) > 0 {
		parsed, err := strconv.ParseBool(raw)
		if err != nil {
			return errors.Wrap(err, `failed to parse boolean value "validate"`)
		}
		tmp.validate = parsed
	}
	*c = tmp
	return nil
}

// Replies creates a GroupsRepliesCall object in preparation for accessing the groups.replies endpoint
func (s *GroupsService) Replies(channel string, threadTimestamp string) *GroupsRepliesCall {
	var call GroupsRepliesCall
	call.service = s
	call.channel = channel
	call.threadTimestamp = threadTimestamp
	return &call
}

// ValidateArgs checks that all required fields are set in the GroupsRepliesCall object
func (c *GroupsRepliesCall) ValidateArgs() error {
	if len(c.channel) <= 0 {
		return errors.New(`required field channel not initialized`)
	}
	if len(c.threadTimestamp) <= 0 {
		return errors.New(`required field threadTimestamp not initialized`)
	}
	return nil
}

// Values returns the GroupsRepliesCall object as url.Values
func (c *GroupsRepliesCall) Values() (url.Values, error) {
	if err := c.ValidateArgs(); err != nil {
		return nil, errors.Wrap(err, `failed validation`)
	}
	v := url.Values{}
	v.Set(`token`, c.service.token)

	v.Set("channel", c.channel)

	v.Set("thread_ts", c.threadTimestamp)
	return v, nil
}

// Do executes the call to access groups.replies endpoint
func (c *GroupsRepliesCall) Do(ctx context.Context) (objects.MessageList, *objects.ThreadInfo, error) {
	const endpoint = "groups.replies"
	v, err := c.Values()
	if err != nil {
		return nil, nil, err
	}
	var res struct {
		objects.GenericResponse
		objects.MessageList `json:"messages"`
		*objects.ThreadInfo `json:"thread_info"`
	}
	if err := c.service.client.postForm(ctx, endpoint, v, &res); err != nil {
		return nil, nil, errors.Wrap(err, `failed to post to groups.replies`)
	}
	if !res.OK() {
		return nil, nil, errors.New(res.Error().String())
	}

	return res.MessageList, res.ThreadInfo, nil
}

// FromValues parses the data in v and populates `c`
func (c *GroupsRepliesCall) FromValues(v url.Values) error {
	var tmp GroupsRepliesCall
	if raw := strings.TrimSpace(v.Get("channel")); len(raw) > 0 {
		tmp.channel = raw
	}
	if raw := strings.TrimSpace(v.Get("thread_ts")); len(raw) > 0 {
		tmp.threadTimestamp = raw
	}
	*c = tmp
	return nil
}

// SetPurpose creates a GroupsSetPurposeCall object in preparation for accessing the groups.setPurpose endpoint
func (s *GroupsService) SetPurpose(channel string, purpose string) *GroupsSetPurposeCall {
	var call GroupsSetPurposeCall
	call.service = s
	call.channel = channel
	call.purpose = purpose
	return &call
}

// ValidateArgs checks that all required fields are set in the GroupsSetPurposeCall object
func (c *GroupsSetPurposeCall) ValidateArgs() error {
	if len(c.channel) <= 0 {
		return errors.New(`required field channel not initialized`)
	}
	if len(c.purpose) <= 0 {
		return errors.New(`required field purpose not initialized`)
	}
	return nil
}

// Values returns the GroupsSetPurposeCall object as url.Values
func (c *GroupsSetPurposeCall) Values() (url.Values, error) {
	if err := c.ValidateArgs(); err != nil {
		return nil, errors.Wrap(err, `failed validation`)
	}
	v := url.Values{}
	v.Set(`token`, c.service.token)

	v.Set("channel", c.channel)

	v.Set("purpose", c.purpose)
	return v, nil
}

// Do executes the call to access groups.setPurpose endpoint
func (c *GroupsSetPurposeCall) Do(ctx context.Context) (string, error) {
	const endpoint = "groups.setPurpose"
	v, err := c.Values()
	if err != nil {
		return "", err
	}
	var res struct {
		objects.GenericResponse
		string `json:"purpose"`
	}
	if err := c.service.client.postForm(ctx, endpoint, v, &res); err != nil {
		return "", errors.Wrap(err, `failed to post to groups.setPurpose`)
	}
	if !res.OK() {
		return "", errors.New(res.Error().String())
	}

	return res.string, nil
}

// FromValues parses the data in v and populates `c`
func (c *GroupsSetPurposeCall) FromValues(v url.Values) error {
	var tmp GroupsSetPurposeCall
	if raw := strings.TrimSpace(v.Get("channel")); len(raw) > 0 {
		tmp.channel = raw
	}
	if raw := strings.TrimSpace(v.Get("purpose")); len(raw) > 0 {
		tmp.purpose = raw
	}
	*c = tmp
	return nil
}

// SetTopic creates a GroupsSetTopicCall object in preparation for accessing the groups.setTopic endpoint
func (s *GroupsService) SetTopic(channel string, topic string) *GroupsSetTopicCall {
	var call GroupsSetTopicCall
	call.service = s
	call.channel = channel
	call.topic = topic
	return &call
}

// ValidateArgs checks that all required fields are set in the GroupsSetTopicCall object
func (c *GroupsSetTopicCall) ValidateArgs() error {
	if len(c.channel) <= 0 {
		return errors.New(`required field channel not initialized`)
	}
	if len(c.topic) <= 0 {
		return errors.New(`required field topic not initialized`)
	}
	return nil
}

// Values returns the GroupsSetTopicCall object as url.Values
func (c *GroupsSetTopicCall) Values() (url.Values, error) {
	if err := c.ValidateArgs(); err != nil {
		return nil, errors.Wrap(err, `failed validation`)
	}
	v := url.Values{}
	v.Set(`token`, c.service.token)

	v.Set("channel", c.channel)

	v.Set("topic", c.topic)
	return v, nil
}

// Do executes the call to access groups.setTopic endpoint
func (c *GroupsSetTopicCall) Do(ctx context.Context) (string, error) {
	const endpoint = "groups.setTopic"
	v, err := c.Values()
	if err != nil {
		return "", err
	}
	var res struct {
		objects.GenericResponse
		string `json:"topic"`
	}
	if err := c.service.client.postForm(ctx, endpoint, v, &res); err != nil {
		return "", errors.Wrap(err, `failed to post to groups.setTopic`)
	}
	if !res.OK() {
		return "", errors.New(res.Error().String())
	}

	return res.string, nil
}

// FromValues parses the data in v and populates `c`
func (c *GroupsSetTopicCall) FromValues(v url.Values) error {
	var tmp GroupsSetTopicCall
	if raw := strings.TrimSpace(v.Get("channel")); len(raw) > 0 {
		tmp.channel = raw
	}
	if raw := strings.TrimSpace(v.Get("topic")); len(raw) > 0 {
		tmp.topic = raw
	}
	*c = tmp
	return nil
}

// Unarchive creates a GroupsUnarchiveCall object in preparation for accessing the groups.unarchive endpoint
func (s *GroupsService) Unarchive(channel string) *GroupsUnarchiveCall {
	var call GroupsUnarchiveCall
	call.service = s
	call.channel = channel
	return &call
}

// ValidateArgs checks that all required fields are set in the GroupsUnarchiveCall object
func (c *GroupsUnarchiveCall) ValidateArgs() error {
	if len(c.channel) <= 0 {
		return errors.New(`required field channel not initialized`)
	}
	return nil
}

// Values returns the GroupsUnarchiveCall object as url.Values
func (c *GroupsUnarchiveCall) Values() (url.Values, error) {
	if err := c.ValidateArgs(); err != nil {
		return nil, errors.Wrap(err, `failed validation`)
	}
	v := url.Values{}
	v.Set(`token`, c.service.token)

	v.Set("channel", c.channel)
	return v, nil
}

// Do executes the call to access groups.unarchive endpoint
func (c *GroupsUnarchiveCall) Do(ctx context.Context) error {
	const endpoint = "groups.unarchive"
	v, err := c.Values()
	if err != nil {
		return err
	}
	var res struct {
		objects.GenericResponse
	}
	if err := c.service.client.postForm(ctx, endpoint, v, &res); err != nil {
		return errors.Wrap(err, `failed to post to groups.unarchive`)
	}
	if !res.OK() {
		return errors.New(res.Error().String())
	}

	return nil
}

// FromValues parses the data in v and populates `c`
func (c *GroupsUnarchiveCall) FromValues(v url.Values) error {
	var tmp GroupsUnarchiveCall
	if raw := strings.TrimSpace(v.Get("channel")); len(raw) > 0 {
		tmp.channel = raw
	}
	*c = tmp
	return nil
}
