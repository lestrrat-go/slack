package slack

// Auto-generated by internal/cmd/genmethods/genmethods.go (generateServiceDetailsFile). DO NOT EDIT!

import (
	"context"
	"encoding/json"
	"net/url"
	"strconv"
	"strings"

	"github.com/lestrrat-go/slack/objects"
	"github.com/pkg/errors"
)

var _ = strconv.Itoa
var _ = strings.Index
var _ = json.Marshal
var _ = objects.EpochTime(0)

// ChatDeleteCall is created by ChatService.Delete method call
type ChatDeleteCall struct {
	service   *ChatService
	asUser    bool
	channel   string
	timestamp string
}

// ChatGetPermalinkCall is created by ChatService.GetPermalink method call
type ChatGetPermalinkCall struct {
	service          *ChatService
	channel          string
	messageTimestamp string
}

// ChatMeMessageCall is created by ChatService.MeMessage method call
type ChatMeMessageCall struct {
	service *ChatService
	channel string
	text    string
}

// ChatPostEphemeralCall is created by ChatService.PostEphemeral method call
type ChatPostEphemeralCall struct {
	service     *ChatService
	asUser      bool
	attachments objects.AttachmentList
	blocks      objects.BlockList
	channel     string
	linkNames   bool
	parse       string
	text        string
	user        string
}

// ChatPostMessageCall is created by ChatService.PostMessage method call
type ChatPostMessageCall struct {
	service     *ChatService
	asUser      bool
	attachments objects.AttachmentList
	blocks      objects.BlockList
	channel     string
	escapeText  bool
	iconEmoji   string
	iconURL     string
	linkNames   bool
	markdown    bool
	parse       string
	text        string
	unfurlLinks bool
	unfurlMedia bool
	username    string
}

// ChatUnfurlCall is created by ChatService.Unfurl method call
type ChatUnfurlCall struct {
	service          *ChatService
	channel          string
	timestamp        string
	unfurls          string
	userAuthRequired bool
}

// ChatUpdateCall is created by ChatService.Update method call
type ChatUpdateCall struct {
	service     *ChatService
	asUser      bool
	attachments objects.AttachmentList
	blocks      objects.BlockList
	channel     string
	linkNames   bool
	parse       string
	text        string
	timestamp   string
}

// Delete creates a ChatDeleteCall object in preparation for accessing the chat.delete endpoint
func (s *ChatService) Delete(channel string) *ChatDeleteCall {
	var call ChatDeleteCall
	call.service = s
	call.channel = channel
	return &call
}

// AsUser sets the value for optional asUser parameter
func (c *ChatDeleteCall) AsUser(asUser bool) *ChatDeleteCall {
	c.asUser = asUser
	return c
}

// Timestamp sets the value for optional timestamp parameter
func (c *ChatDeleteCall) Timestamp(timestamp string) *ChatDeleteCall {
	c.timestamp = timestamp
	return c
}

// ValidateArgs checks that all required fields are set in the ChatDeleteCall object
func (c *ChatDeleteCall) ValidateArgs() error {
	if len(c.channel) <= 0 {
		return errors.New(`required field channel not initialized`)
	}
	return nil
}

// Values returns the ChatDeleteCall object as url.Values
func (c *ChatDeleteCall) Values() (url.Values, error) {
	if err := c.ValidateArgs(); err != nil {
		return nil, errors.Wrap(err, `failed validation`)
	}
	v := url.Values{}
	v.Set(`token`, c.service.token)

	if c.asUser {
		v.Set("as_user", "true")
	}

	v.Set("channel", c.channel)

	if len(c.timestamp) > 0 {
		v.Set("ts", c.timestamp)
	}
	return v, nil
}

type ChatDeleteCallResponse interface {
	OK() bool
	ReplyTo() int
	Error() *objects.ErrorResponse
	Timestamp() string
}

type chatDeleteCallResponseProxy struct {
	OK        bool                   `json:"ok"`
	ReplyTo   int                    `json:"reply_to"`
	Error     *objects.ErrorResponse `json:"error"`
	Timestamp string                 `json:"ts"`
	Payload0  json.RawMessage        `json:"-"`
}
type chatDeleteCallResponse struct {
	ok      bool
	replyTo int
	error   *objects.ErrorResponse
	ts      string
}
type ChatDeleteCallResponseBuilder struct {
	resp *chatDeleteCallResponse
}

func BuildChatDeleteCallResponse() *ChatDeleteCallResponseBuilder {
	return &ChatDeleteCallResponseBuilder{resp: &chatDeleteCallResponse{}}
}
func (v *chatDeleteCallResponse) OK() bool {
	return v.ok
}
func (v *chatDeleteCallResponse) ReplyTo() int {
	return v.replyTo
}
func (v *chatDeleteCallResponse) Error() *objects.ErrorResponse {
	return v.error
}
func (v *chatDeleteCallResponse) Timestamp() string {
	return v.ts
}
func (b *ChatDeleteCallResponseBuilder) OK(v bool) *ChatDeleteCallResponseBuilder {
	b.resp.ok = v
	return b
}
func (b *ChatDeleteCallResponseBuilder) ReplyTo(v int) *ChatDeleteCallResponseBuilder {
	b.resp.replyTo = v
	return b
}
func (b *ChatDeleteCallResponseBuilder) Error(v *objects.ErrorResponse) *ChatDeleteCallResponseBuilder {
	b.resp.error = v
	return b
}
func (b *ChatDeleteCallResponseBuilder) Timestamp(v string) *ChatDeleteCallResponseBuilder {
	b.resp.ts = v
	return b
}
func (b *ChatDeleteCallResponseBuilder) Build() ChatDeleteCallResponse {
	v := b.resp
	b.resp = &chatDeleteCallResponse{}
	return v
}
func (r *chatDeleteCallResponseProxy) parse(data []byte) error {
	if err := json.Unmarshal(data, r); err != nil {
		return errors.Wrap(err, `failed to unmarshal ChatDeleteCallResponse`)
	}
	r.Payload0 = data
	return nil
}
func (r *chatDeleteCallResponseProxy) payload() (*objects.ChatResponse, error) {
	var res0 objects.ChatResponse
	if err := json.Unmarshal(r.Payload0, &res0); err != nil {
		return nil, errors.Wrap(err, `failed to ummarshal objects.ChatResponse from response`)
	}
	return &res0, nil
}
func (r *chatDeleteCallResponse) MarshalJSON() ([]byte, error) {
	var p chatDeleteCallResponseProxy
	p.OK = r.ok
	p.ReplyTo = r.replyTo
	p.Error = r.error
	p.Timestamp = r.ts
	return json.Marshal(p)
}

// Do executes the call to access chat.delete endpoint
func (c *ChatDeleteCall) Do(ctx context.Context) (*objects.ChatResponse, error) {
	const endpoint = "chat.delete"
	v, err := c.Values()
	if err != nil {
		return nil, err
	}
	var res chatDeleteCallResponseProxy
	if err := c.service.client.postForm(ctx, endpoint, v, &res); err != nil {
		return nil, errors.Wrap(err, `failed to post to chat.delete`)
	}
	if !res.OK {
		var err error
		if errresp := res.Error; errresp != nil {
			err = errors.New(errresp.String())
		} else {
			err = errors.New(`unknown error while posting to chat.delete`)
		}
		return nil, err
	}

	return res.payload()
}

// FromValues parses the data in v and populates `c`
func (c *ChatDeleteCall) FromValues(v url.Values) error {
	var tmp ChatDeleteCall
	if raw := strings.TrimSpace(v.Get("as_user")); len(raw) > 0 {
		parsed, err := strconv.ParseBool(raw)
		if err != nil {
			return errors.Wrap(err, `failed to parse boolean value "as_user"`)
		}
		tmp.asUser = parsed
	}
	if raw := strings.TrimSpace(v.Get("channel")); len(raw) > 0 {
		tmp.channel = raw
	}
	if raw := strings.TrimSpace(v.Get("ts")); len(raw) > 0 {
		tmp.timestamp = raw
	}
	*c = tmp
	return nil
}

// GetPermalink creates a ChatGetPermalinkCall object in preparation for accessing the chat.getPermalink endpoint
func (s *ChatService) GetPermalink(channel string, messageTimestamp string) *ChatGetPermalinkCall {
	var call ChatGetPermalinkCall
	call.service = s
	call.channel = channel
	call.messageTimestamp = messageTimestamp
	return &call
}

// ValidateArgs checks that all required fields are set in the ChatGetPermalinkCall object
func (c *ChatGetPermalinkCall) ValidateArgs() error {
	if len(c.channel) <= 0 {
		return errors.New(`required field channel not initialized`)
	}
	if len(c.messageTimestamp) <= 0 {
		return errors.New(`required field messageTimestamp not initialized`)
	}
	return nil
}

// Values returns the ChatGetPermalinkCall object as url.Values
func (c *ChatGetPermalinkCall) Values() (url.Values, error) {
	if err := c.ValidateArgs(); err != nil {
		return nil, errors.Wrap(err, `failed validation`)
	}
	v := url.Values{}
	v.Set(`token`, c.service.token)

	v.Set("channel", c.channel)

	v.Set("message_ts", c.messageTimestamp)
	return v, nil
}

type ChatGetPermalinkCallResponse interface {
	OK() bool
	ReplyTo() int
	Error() *objects.ErrorResponse
	Timestamp() string
}

type chatGetPermalinkCallResponseProxy struct {
	OK        bool                   `json:"ok"`
	ReplyTo   int                    `json:"reply_to"`
	Error     *objects.ErrorResponse `json:"error"`
	Timestamp string                 `json:"ts"`
	Payload0  json.RawMessage        `json:"-"`
}
type chatGetPermalinkCallResponse struct {
	ok      bool
	replyTo int
	error   *objects.ErrorResponse
	ts      string
}
type ChatGetPermalinkCallResponseBuilder struct {
	resp *chatGetPermalinkCallResponse
}

func BuildChatGetPermalinkCallResponse() *ChatGetPermalinkCallResponseBuilder {
	return &ChatGetPermalinkCallResponseBuilder{resp: &chatGetPermalinkCallResponse{}}
}
func (v *chatGetPermalinkCallResponse) OK() bool {
	return v.ok
}
func (v *chatGetPermalinkCallResponse) ReplyTo() int {
	return v.replyTo
}
func (v *chatGetPermalinkCallResponse) Error() *objects.ErrorResponse {
	return v.error
}
func (v *chatGetPermalinkCallResponse) Timestamp() string {
	return v.ts
}
func (b *ChatGetPermalinkCallResponseBuilder) OK(v bool) *ChatGetPermalinkCallResponseBuilder {
	b.resp.ok = v
	return b
}
func (b *ChatGetPermalinkCallResponseBuilder) ReplyTo(v int) *ChatGetPermalinkCallResponseBuilder {
	b.resp.replyTo = v
	return b
}
func (b *ChatGetPermalinkCallResponseBuilder) Error(v *objects.ErrorResponse) *ChatGetPermalinkCallResponseBuilder {
	b.resp.error = v
	return b
}
func (b *ChatGetPermalinkCallResponseBuilder) Timestamp(v string) *ChatGetPermalinkCallResponseBuilder {
	b.resp.ts = v
	return b
}
func (b *ChatGetPermalinkCallResponseBuilder) Build() ChatGetPermalinkCallResponse {
	v := b.resp
	b.resp = &chatGetPermalinkCallResponse{}
	return v
}
func (r *chatGetPermalinkCallResponseProxy) parse(data []byte) error {
	if err := json.Unmarshal(data, r); err != nil {
		return errors.Wrap(err, `failed to unmarshal ChatGetPermalinkCallResponse`)
	}
	r.Payload0 = data
	return nil
}
func (r *chatGetPermalinkCallResponseProxy) payload() (*objects.PermalinkResponse, error) {
	var res0 objects.PermalinkResponse
	if err := json.Unmarshal(r.Payload0, &res0); err != nil {
		return nil, errors.Wrap(err, `failed to ummarshal objects.PermalinkResponse from response`)
	}
	return &res0, nil
}
func (r *chatGetPermalinkCallResponse) MarshalJSON() ([]byte, error) {
	var p chatGetPermalinkCallResponseProxy
	p.OK = r.ok
	p.ReplyTo = r.replyTo
	p.Error = r.error
	p.Timestamp = r.ts
	return json.Marshal(p)
}

// Do executes the call to access chat.getPermalink endpoint
func (c *ChatGetPermalinkCall) Do(ctx context.Context) (*objects.PermalinkResponse, error) {
	const endpoint = "chat.getPermalink"
	v, err := c.Values()
	if err != nil {
		return nil, err
	}
	var res chatGetPermalinkCallResponseProxy
	if err := c.service.client.postForm(ctx, endpoint, v, &res); err != nil {
		return nil, errors.Wrap(err, `failed to post to chat.getPermalink`)
	}
	if !res.OK {
		var err error
		if errresp := res.Error; errresp != nil {
			err = errors.New(errresp.String())
		} else {
			err = errors.New(`unknown error while posting to chat.getPermalink`)
		}
		return nil, err
	}

	return res.payload()
}

// FromValues parses the data in v and populates `c`
func (c *ChatGetPermalinkCall) FromValues(v url.Values) error {
	var tmp ChatGetPermalinkCall
	if raw := strings.TrimSpace(v.Get("channel")); len(raw) > 0 {
		tmp.channel = raw
	}
	if raw := strings.TrimSpace(v.Get("message_ts")); len(raw) > 0 {
		tmp.messageTimestamp = raw
	}
	*c = tmp
	return nil
}

// MeMessage creates a ChatMeMessageCall object in preparation for accessing the chat.meMessage endpoint
func (s *ChatService) MeMessage(channel string) *ChatMeMessageCall {
	var call ChatMeMessageCall
	call.service = s
	call.channel = channel
	return &call
}

// Text sets the value for optional text parameter
func (c *ChatMeMessageCall) Text(text string) *ChatMeMessageCall {
	c.text = text
	return c
}

// ValidateArgs checks that all required fields are set in the ChatMeMessageCall object
func (c *ChatMeMessageCall) ValidateArgs() error {
	if len(c.channel) <= 0 {
		return errors.New(`required field channel not initialized`)
	}
	return nil
}

// Values returns the ChatMeMessageCall object as url.Values
func (c *ChatMeMessageCall) Values() (url.Values, error) {
	if err := c.ValidateArgs(); err != nil {
		return nil, errors.Wrap(err, `failed validation`)
	}
	v := url.Values{}
	v.Set(`token`, c.service.token)

	v.Set("channel", c.channel)

	if len(c.text) > 0 {
		v.Set("text", c.text)
	}
	return v, nil
}

type ChatMeMessageCallResponse interface {
	OK() bool
	ReplyTo() int
	Error() *objects.ErrorResponse
	Timestamp() string
}

type chatMeMessageCallResponseProxy struct {
	OK        bool                   `json:"ok"`
	ReplyTo   int                    `json:"reply_to"`
	Error     *objects.ErrorResponse `json:"error"`
	Timestamp string                 `json:"ts"`
	Payload0  json.RawMessage        `json:"-"`
}
type chatMeMessageCallResponse struct {
	ok      bool
	replyTo int
	error   *objects.ErrorResponse
	ts      string
}
type ChatMeMessageCallResponseBuilder struct {
	resp *chatMeMessageCallResponse
}

func BuildChatMeMessageCallResponse() *ChatMeMessageCallResponseBuilder {
	return &ChatMeMessageCallResponseBuilder{resp: &chatMeMessageCallResponse{}}
}
func (v *chatMeMessageCallResponse) OK() bool {
	return v.ok
}
func (v *chatMeMessageCallResponse) ReplyTo() int {
	return v.replyTo
}
func (v *chatMeMessageCallResponse) Error() *objects.ErrorResponse {
	return v.error
}
func (v *chatMeMessageCallResponse) Timestamp() string {
	return v.ts
}
func (b *ChatMeMessageCallResponseBuilder) OK(v bool) *ChatMeMessageCallResponseBuilder {
	b.resp.ok = v
	return b
}
func (b *ChatMeMessageCallResponseBuilder) ReplyTo(v int) *ChatMeMessageCallResponseBuilder {
	b.resp.replyTo = v
	return b
}
func (b *ChatMeMessageCallResponseBuilder) Error(v *objects.ErrorResponse) *ChatMeMessageCallResponseBuilder {
	b.resp.error = v
	return b
}
func (b *ChatMeMessageCallResponseBuilder) Timestamp(v string) *ChatMeMessageCallResponseBuilder {
	b.resp.ts = v
	return b
}
func (b *ChatMeMessageCallResponseBuilder) Build() ChatMeMessageCallResponse {
	v := b.resp
	b.resp = &chatMeMessageCallResponse{}
	return v
}
func (r *chatMeMessageCallResponseProxy) parse(data []byte) error {
	if err := json.Unmarshal(data, r); err != nil {
		return errors.Wrap(err, `failed to unmarshal ChatMeMessageCallResponse`)
	}
	r.Payload0 = data
	return nil
}
func (r *chatMeMessageCallResponseProxy) payload() (*objects.ChatResponse, error) {
	var res0 objects.ChatResponse
	if err := json.Unmarshal(r.Payload0, &res0); err != nil {
		return nil, errors.Wrap(err, `failed to ummarshal objects.ChatResponse from response`)
	}
	return &res0, nil
}
func (r *chatMeMessageCallResponse) MarshalJSON() ([]byte, error) {
	var p chatMeMessageCallResponseProxy
	p.OK = r.ok
	p.ReplyTo = r.replyTo
	p.Error = r.error
	p.Timestamp = r.ts
	return json.Marshal(p)
}

// Do executes the call to access chat.meMessage endpoint
func (c *ChatMeMessageCall) Do(ctx context.Context) (*objects.ChatResponse, error) {
	const endpoint = "chat.meMessage"
	v, err := c.Values()
	if err != nil {
		return nil, err
	}
	var res chatMeMessageCallResponseProxy
	if err := c.service.client.postForm(ctx, endpoint, v, &res); err != nil {
		return nil, errors.Wrap(err, `failed to post to chat.meMessage`)
	}
	if !res.OK {
		var err error
		if errresp := res.Error; errresp != nil {
			err = errors.New(errresp.String())
		} else {
			err = errors.New(`unknown error while posting to chat.meMessage`)
		}
		return nil, err
	}

	return res.payload()
}

// FromValues parses the data in v and populates `c`
func (c *ChatMeMessageCall) FromValues(v url.Values) error {
	var tmp ChatMeMessageCall
	if raw := strings.TrimSpace(v.Get("channel")); len(raw) > 0 {
		tmp.channel = raw
	}
	if raw := strings.TrimSpace(v.Get("text")); len(raw) > 0 {
		tmp.text = raw
	}
	*c = tmp
	return nil
}

// PostEphemeral creates a ChatPostEphemeralCall object in preparation for accessing the chat.postEphemeral endpoint
func (s *ChatService) PostEphemeral(channel string, text string, user string) *ChatPostEphemeralCall {
	var call ChatPostEphemeralCall
	call.service = s
	call.channel = channel
	call.text = text
	call.user = user
	return &call
}

// AsUser sets the value for optional asUser parameter
func (c *ChatPostEphemeralCall) AsUser(asUser bool) *ChatPostEphemeralCall {
	c.asUser = asUser
	return c
}

// SetAttachments sets the attachments list
func (c *ChatPostEphemeralCall) SetAttachments(attachments objects.AttachmentList) *ChatPostEphemeralCall {
	c.attachments = attachments
	return c
}

// Attachment appends to the attachments list
func (c *ChatPostEphemeralCall) Attachment(attachment *objects.Attachment) *ChatPostEphemeralCall {
	c.attachments.Append(attachment)
	return c
}

// SetBlocks sets the blocks list
func (c *ChatPostEphemeralCall) SetBlocks(blocks objects.BlockList) *ChatPostEphemeralCall {
	c.blocks = blocks
	return c
}

// Block appends to the blocks list
func (c *ChatPostEphemeralCall) Block(block objects.Block) *ChatPostEphemeralCall {
	c.blocks.Append(block)
	return c
}

// LinkNames sets the value for optional linkNames parameter
func (c *ChatPostEphemeralCall) LinkNames(linkNames bool) *ChatPostEphemeralCall {
	c.linkNames = linkNames
	return c
}

// Parse sets the value for optional parse parameter
func (c *ChatPostEphemeralCall) Parse(parse string) *ChatPostEphemeralCall {
	c.parse = parse
	return c
}

// ValidateArgs checks that all required fields are set in the ChatPostEphemeralCall object
func (c *ChatPostEphemeralCall) ValidateArgs() error {
	if len(c.channel) <= 0 {
		return errors.New(`required field channel not initialized`)
	}
	if len(c.text) <= 0 {
		return errors.New(`required field text not initialized`)
	}
	if len(c.user) <= 0 {
		return errors.New(`required field user not initialized`)
	}
	return nil
}

// Values returns the ChatPostEphemeralCall object as url.Values
func (c *ChatPostEphemeralCall) Values() (url.Values, error) {
	if err := c.ValidateArgs(); err != nil {
		return nil, errors.Wrap(err, `failed validation`)
	}
	v := url.Values{}
	v.Set(`token`, c.service.token)

	if c.asUser {
		v.Set("as_user", "true")
	}

	if len(c.attachments) > 0 {
		attachmentsEncoded, err := json.Marshal(c.attachments)
		if err != nil {
			return nil, errors.Wrap(err, `failed to encode field`)
		}
		v.Set("attachments", string(attachmentsEncoded))
	}

	if len(c.blocks) > 0 {
		blocksEncoded, err := json.Marshal(c.blocks)
		if err != nil {
			return nil, errors.Wrap(err, `failed to encode field`)
		}
		v.Set("blocks", string(blocksEncoded))
	}

	v.Set("channel", c.channel)

	if c.linkNames {
		v.Set("linkNames", "true")
	}

	if len(c.parse) > 0 {
		v.Set("parse", c.parse)
	}

	v.Set("text", c.text)

	v.Set("user", c.user)
	return v, nil
}

type ChatPostEphemeralCallResponse interface {
	OK() bool
	ReplyTo() int
	Error() *objects.ErrorResponse
	Timestamp() string
}

type chatPostEphemeralCallResponseProxy struct {
	OK        bool                   `json:"ok"`
	ReplyTo   int                    `json:"reply_to"`
	Error     *objects.ErrorResponse `json:"error"`
	Timestamp string                 `json:"ts"`
	Payload0  json.RawMessage        `json:"-"`
}
type chatPostEphemeralCallResponse struct {
	ok      bool
	replyTo int
	error   *objects.ErrorResponse
	ts      string
}
type ChatPostEphemeralCallResponseBuilder struct {
	resp *chatPostEphemeralCallResponse
}

func BuildChatPostEphemeralCallResponse() *ChatPostEphemeralCallResponseBuilder {
	return &ChatPostEphemeralCallResponseBuilder{resp: &chatPostEphemeralCallResponse{}}
}
func (v *chatPostEphemeralCallResponse) OK() bool {
	return v.ok
}
func (v *chatPostEphemeralCallResponse) ReplyTo() int {
	return v.replyTo
}
func (v *chatPostEphemeralCallResponse) Error() *objects.ErrorResponse {
	return v.error
}
func (v *chatPostEphemeralCallResponse) Timestamp() string {
	return v.ts
}
func (b *ChatPostEphemeralCallResponseBuilder) OK(v bool) *ChatPostEphemeralCallResponseBuilder {
	b.resp.ok = v
	return b
}
func (b *ChatPostEphemeralCallResponseBuilder) ReplyTo(v int) *ChatPostEphemeralCallResponseBuilder {
	b.resp.replyTo = v
	return b
}
func (b *ChatPostEphemeralCallResponseBuilder) Error(v *objects.ErrorResponse) *ChatPostEphemeralCallResponseBuilder {
	b.resp.error = v
	return b
}
func (b *ChatPostEphemeralCallResponseBuilder) Timestamp(v string) *ChatPostEphemeralCallResponseBuilder {
	b.resp.ts = v
	return b
}
func (b *ChatPostEphemeralCallResponseBuilder) Build() ChatPostEphemeralCallResponse {
	v := b.resp
	b.resp = &chatPostEphemeralCallResponse{}
	return v
}
func (r *chatPostEphemeralCallResponseProxy) parse(data []byte) error {
	if err := json.Unmarshal(data, r); err != nil {
		return errors.Wrap(err, `failed to unmarshal ChatPostEphemeralCallResponse`)
	}
	r.Payload0 = data
	return nil
}
func (r *chatPostEphemeralCallResponseProxy) payload() (*objects.EphemeralResponse, error) {
	var res0 objects.EphemeralResponse
	if err := json.Unmarshal(r.Payload0, &res0); err != nil {
		return nil, errors.Wrap(err, `failed to ummarshal objects.EphemeralResponse from response`)
	}
	return &res0, nil
}
func (r *chatPostEphemeralCallResponse) MarshalJSON() ([]byte, error) {
	var p chatPostEphemeralCallResponseProxy
	p.OK = r.ok
	p.ReplyTo = r.replyTo
	p.Error = r.error
	p.Timestamp = r.ts
	return json.Marshal(p)
}

// Do executes the call to access chat.postEphemeral endpoint
func (c *ChatPostEphemeralCall) Do(ctx context.Context) (*objects.EphemeralResponse, error) {
	const endpoint = "chat.postEphemeral"
	v, err := c.Values()
	if err != nil {
		return nil, err
	}
	var res chatPostEphemeralCallResponseProxy
	if err := c.service.client.postForm(ctx, endpoint, v, &res); err != nil {
		return nil, errors.Wrap(err, `failed to post to chat.postEphemeral`)
	}
	if !res.OK {
		var err error
		if errresp := res.Error; errresp != nil {
			err = errors.New(errresp.String())
		} else {
			err = errors.New(`unknown error while posting to chat.postEphemeral`)
		}
		return nil, err
	}

	return res.payload()
}

// FromValues parses the data in v and populates `c`
func (c *ChatPostEphemeralCall) FromValues(v url.Values) error {
	var tmp ChatPostEphemeralCall
	if raw := strings.TrimSpace(v.Get("as_user")); len(raw) > 0 {
		parsed, err := strconv.ParseBool(raw)
		if err != nil {
			return errors.Wrap(err, `failed to parse boolean value "as_user"`)
		}
		tmp.asUser = parsed
	}
	if raw := strings.TrimSpace(v.Get("attachments")); len(raw) > 0 {
		if err := json.Unmarshal([]byte(raw), &tmp.attachments); err != nil {
			return errors.Wrap(err, `failed to decode value "attachments"`)
		}
	}
	if raw := strings.TrimSpace(v.Get("blocks")); len(raw) > 0 {
		if err := json.Unmarshal([]byte(raw), &tmp.blocks); err != nil {
			return errors.Wrap(err, `failed to decode value "blocks"`)
		}
	}
	if raw := strings.TrimSpace(v.Get("channel")); len(raw) > 0 {
		tmp.channel = raw
	}
	if raw := strings.TrimSpace(v.Get("linkNames")); len(raw) > 0 {
		parsed, err := strconv.ParseBool(raw)
		if err != nil {
			return errors.Wrap(err, `failed to parse boolean value "linkNames"`)
		}
		tmp.linkNames = parsed
	}
	if raw := strings.TrimSpace(v.Get("parse")); len(raw) > 0 {
		tmp.parse = raw
	}
	if raw := strings.TrimSpace(v.Get("text")); len(raw) > 0 {
		tmp.text = raw
	}
	if raw := strings.TrimSpace(v.Get("user")); len(raw) > 0 {
		tmp.user = raw
	}
	*c = tmp
	return nil
}

// PostMessage creates a ChatPostMessageCall object in preparation for accessing the chat.postMessage endpoint
func (s *ChatService) PostMessage(channel string) *ChatPostMessageCall {
	var call ChatPostMessageCall
	call.service = s
	call.channel = channel
	return &call
}

// AsUser sets the value for optional asUser parameter
func (c *ChatPostMessageCall) AsUser(asUser bool) *ChatPostMessageCall {
	c.asUser = asUser
	return c
}

// SetAttachments sets the attachments list
func (c *ChatPostMessageCall) SetAttachments(attachments objects.AttachmentList) *ChatPostMessageCall {
	c.attachments = attachments
	return c
}

// Attachment appends to the attachments list
func (c *ChatPostMessageCall) Attachment(attachment *objects.Attachment) *ChatPostMessageCall {
	c.attachments.Append(attachment)
	return c
}

// SetBlocks sets the blocks list
func (c *ChatPostMessageCall) SetBlocks(blocks objects.BlockList) *ChatPostMessageCall {
	c.blocks = blocks
	return c
}

// Block appends to the blocks list
func (c *ChatPostMessageCall) Block(block objects.Block) *ChatPostMessageCall {
	c.blocks.Append(block)
	return c
}

// EscapeText sets the value for optional escapeText parameter
func (c *ChatPostMessageCall) EscapeText(escapeText bool) *ChatPostMessageCall {
	c.escapeText = escapeText
	return c
}

// IconEmoji sets the value for optional iconEmoji parameter
func (c *ChatPostMessageCall) IconEmoji(iconEmoji string) *ChatPostMessageCall {
	c.iconEmoji = iconEmoji
	return c
}

// IconURL sets the value for optional iconURL parameter
func (c *ChatPostMessageCall) IconURL(iconURL string) *ChatPostMessageCall {
	c.iconURL = iconURL
	return c
}

// LinkNames sets the value for optional linkNames parameter
func (c *ChatPostMessageCall) LinkNames(linkNames bool) *ChatPostMessageCall {
	c.linkNames = linkNames
	return c
}

// Markdown sets the value for optional markdown parameter
func (c *ChatPostMessageCall) Markdown(markdown bool) *ChatPostMessageCall {
	c.markdown = markdown
	return c
}

// Parse sets the value for optional parse parameter
func (c *ChatPostMessageCall) Parse(parse string) *ChatPostMessageCall {
	c.parse = parse
	return c
}

// Text sets the value for optional text parameter
func (c *ChatPostMessageCall) Text(text string) *ChatPostMessageCall {
	c.text = text
	return c
}

// UnfurlLinks sets the value for optional unfurlLinks parameter
func (c *ChatPostMessageCall) UnfurlLinks(unfurlLinks bool) *ChatPostMessageCall {
	c.unfurlLinks = unfurlLinks
	return c
}

// UnfurlMedia sets the value for optional unfurlMedia parameter
func (c *ChatPostMessageCall) UnfurlMedia(unfurlMedia bool) *ChatPostMessageCall {
	c.unfurlMedia = unfurlMedia
	return c
}

// Username sets the value for optional username parameter
func (c *ChatPostMessageCall) Username(username string) *ChatPostMessageCall {
	c.username = username
	return c
}

// ValidateArgs checks that all required fields are set in the ChatPostMessageCall object
func (c *ChatPostMessageCall) ValidateArgs() error {
	if len(c.channel) <= 0 {
		return errors.New(`required field channel not initialized`)
	}
	return nil
}

// Values returns the ChatPostMessageCall object as url.Values
func (c *ChatPostMessageCall) Values() (url.Values, error) {
	if err := c.ValidateArgs(); err != nil {
		return nil, errors.Wrap(err, `failed validation`)
	}
	v := url.Values{}
	v.Set(`token`, c.service.token)

	if c.asUser {
		v.Set("as_user", "true")
	}

	if len(c.attachments) > 0 {
		attachmentsEncoded, err := json.Marshal(c.attachments)
		if err != nil {
			return nil, errors.Wrap(err, `failed to encode field`)
		}
		v.Set("attachments", string(attachmentsEncoded))
	}

	if len(c.blocks) > 0 {
		blocksEncoded, err := json.Marshal(c.blocks)
		if err != nil {
			return nil, errors.Wrap(err, `failed to encode field`)
		}
		v.Set("blocks", string(blocksEncoded))
	}

	v.Set("channel", c.channel)

	if c.escapeText {
		v.Set("escapeText", "true")
	}

	if len(c.iconEmoji) > 0 {
		v.Set("iconEmoji", c.iconEmoji)
	}

	if len(c.iconURL) > 0 {
		v.Set("iconURL", c.iconURL)
	}

	if c.linkNames {
		v.Set("linkNames", "true")
	}

	if c.markdown {
		v.Set("markdown", "true")
	}

	if len(c.parse) > 0 {
		v.Set("parse", c.parse)
	}

	if len(c.text) > 0 {
		v.Set("text", c.text)
	}

	if c.unfurlLinks {
		v.Set("unfurlLinks", "true")
	}

	if c.unfurlMedia {
		v.Set("unfurlMedia", "true")
	}

	if len(c.username) > 0 {
		v.Set("username", c.username)
	}
	return v, nil
}

type ChatPostMessageCallResponse interface {
	OK() bool
	ReplyTo() int
	Error() *objects.ErrorResponse
	Timestamp() string
}

type chatPostMessageCallResponseProxy struct {
	OK        bool                   `json:"ok"`
	ReplyTo   int                    `json:"reply_to"`
	Error     *objects.ErrorResponse `json:"error"`
	Timestamp string                 `json:"ts"`
	Payload0  json.RawMessage        `json:"-"`
}
type chatPostMessageCallResponse struct {
	ok      bool
	replyTo int
	error   *objects.ErrorResponse
	ts      string
}
type ChatPostMessageCallResponseBuilder struct {
	resp *chatPostMessageCallResponse
}

func BuildChatPostMessageCallResponse() *ChatPostMessageCallResponseBuilder {
	return &ChatPostMessageCallResponseBuilder{resp: &chatPostMessageCallResponse{}}
}
func (v *chatPostMessageCallResponse) OK() bool {
	return v.ok
}
func (v *chatPostMessageCallResponse) ReplyTo() int {
	return v.replyTo
}
func (v *chatPostMessageCallResponse) Error() *objects.ErrorResponse {
	return v.error
}
func (v *chatPostMessageCallResponse) Timestamp() string {
	return v.ts
}
func (b *ChatPostMessageCallResponseBuilder) OK(v bool) *ChatPostMessageCallResponseBuilder {
	b.resp.ok = v
	return b
}
func (b *ChatPostMessageCallResponseBuilder) ReplyTo(v int) *ChatPostMessageCallResponseBuilder {
	b.resp.replyTo = v
	return b
}
func (b *ChatPostMessageCallResponseBuilder) Error(v *objects.ErrorResponse) *ChatPostMessageCallResponseBuilder {
	b.resp.error = v
	return b
}
func (b *ChatPostMessageCallResponseBuilder) Timestamp(v string) *ChatPostMessageCallResponseBuilder {
	b.resp.ts = v
	return b
}
func (b *ChatPostMessageCallResponseBuilder) Build() ChatPostMessageCallResponse {
	v := b.resp
	b.resp = &chatPostMessageCallResponse{}
	return v
}
func (r *chatPostMessageCallResponseProxy) parse(data []byte) error {
	if err := json.Unmarshal(data, r); err != nil {
		return errors.Wrap(err, `failed to unmarshal ChatPostMessageCallResponse`)
	}
	r.Payload0 = data
	return nil
}
func (r *chatPostMessageCallResponseProxy) payload() (*objects.ChatResponse, error) {
	var res0 objects.ChatResponse
	if err := json.Unmarshal(r.Payload0, &res0); err != nil {
		return nil, errors.Wrap(err, `failed to ummarshal objects.ChatResponse from response`)
	}
	return &res0, nil
}
func (r *chatPostMessageCallResponse) MarshalJSON() ([]byte, error) {
	var p chatPostMessageCallResponseProxy
	p.OK = r.ok
	p.ReplyTo = r.replyTo
	p.Error = r.error
	p.Timestamp = r.ts
	return json.Marshal(p)
}

// Do executes the call to access chat.postMessage endpoint
func (c *ChatPostMessageCall) Do(ctx context.Context) (*objects.ChatResponse, error) {
	const endpoint = "chat.postMessage"
	v, err := c.Values()
	if err != nil {
		return nil, err
	}
	var res chatPostMessageCallResponseProxy
	if err := c.service.client.postForm(ctx, endpoint, v, &res); err != nil {
		return nil, errors.Wrap(err, `failed to post to chat.postMessage`)
	}
	if !res.OK {
		var err error
		if errresp := res.Error; errresp != nil {
			err = errors.New(errresp.String())
		} else {
			err = errors.New(`unknown error while posting to chat.postMessage`)
		}
		return nil, err
	}

	return res.payload()
}

// FromValues parses the data in v and populates `c`
func (c *ChatPostMessageCall) FromValues(v url.Values) error {
	var tmp ChatPostMessageCall
	if raw := strings.TrimSpace(v.Get("as_user")); len(raw) > 0 {
		parsed, err := strconv.ParseBool(raw)
		if err != nil {
			return errors.Wrap(err, `failed to parse boolean value "as_user"`)
		}
		tmp.asUser = parsed
	}
	if raw := strings.TrimSpace(v.Get("attachments")); len(raw) > 0 {
		if err := json.Unmarshal([]byte(raw), &tmp.attachments); err != nil {
			return errors.Wrap(err, `failed to decode value "attachments"`)
		}
	}
	if raw := strings.TrimSpace(v.Get("blocks")); len(raw) > 0 {
		if err := json.Unmarshal([]byte(raw), &tmp.blocks); err != nil {
			return errors.Wrap(err, `failed to decode value "blocks"`)
		}
	}
	if raw := strings.TrimSpace(v.Get("channel")); len(raw) > 0 {
		tmp.channel = raw
	}
	if raw := strings.TrimSpace(v.Get("escapeText")); len(raw) > 0 {
		parsed, err := strconv.ParseBool(raw)
		if err != nil {
			return errors.Wrap(err, `failed to parse boolean value "escapeText"`)
		}
		tmp.escapeText = parsed
	}
	if raw := strings.TrimSpace(v.Get("iconEmoji")); len(raw) > 0 {
		tmp.iconEmoji = raw
	}
	if raw := strings.TrimSpace(v.Get("iconURL")); len(raw) > 0 {
		tmp.iconURL = raw
	}
	if raw := strings.TrimSpace(v.Get("linkNames")); len(raw) > 0 {
		parsed, err := strconv.ParseBool(raw)
		if err != nil {
			return errors.Wrap(err, `failed to parse boolean value "linkNames"`)
		}
		tmp.linkNames = parsed
	}
	if raw := strings.TrimSpace(v.Get("markdown")); len(raw) > 0 {
		parsed, err := strconv.ParseBool(raw)
		if err != nil {
			return errors.Wrap(err, `failed to parse boolean value "markdown"`)
		}
		tmp.markdown = parsed
	}
	if raw := strings.TrimSpace(v.Get("parse")); len(raw) > 0 {
		tmp.parse = raw
	}
	if raw := strings.TrimSpace(v.Get("text")); len(raw) > 0 {
		tmp.text = raw
	}
	if raw := strings.TrimSpace(v.Get("unfurlLinks")); len(raw) > 0 {
		parsed, err := strconv.ParseBool(raw)
		if err != nil {
			return errors.Wrap(err, `failed to parse boolean value "unfurlLinks"`)
		}
		tmp.unfurlLinks = parsed
	}
	if raw := strings.TrimSpace(v.Get("unfurlMedia")); len(raw) > 0 {
		parsed, err := strconv.ParseBool(raw)
		if err != nil {
			return errors.Wrap(err, `failed to parse boolean value "unfurlMedia"`)
		}
		tmp.unfurlMedia = parsed
	}
	if raw := strings.TrimSpace(v.Get("username")); len(raw) > 0 {
		tmp.username = raw
	}
	*c = tmp
	return nil
}

// Unfurl creates a ChatUnfurlCall object in preparation for accessing the chat.unfurl endpoint
func (s *ChatService) Unfurl(channel string, timestamp string, unfurls string) *ChatUnfurlCall {
	var call ChatUnfurlCall
	call.service = s
	call.channel = channel
	call.timestamp = timestamp
	call.unfurls = unfurls
	return &call
}

// UserAuthRequired sets the value for optional userAuthRequired parameter
func (c *ChatUnfurlCall) UserAuthRequired(userAuthRequired bool) *ChatUnfurlCall {
	c.userAuthRequired = userAuthRequired
	return c
}

// ValidateArgs checks that all required fields are set in the ChatUnfurlCall object
func (c *ChatUnfurlCall) ValidateArgs() error {
	if len(c.channel) <= 0 {
		return errors.New(`required field channel not initialized`)
	}
	if len(c.timestamp) <= 0 {
		return errors.New(`required field timestamp not initialized`)
	}
	if len(c.unfurls) <= 0 {
		return errors.New(`required field unfurls not initialized`)
	}
	return nil
}

// Values returns the ChatUnfurlCall object as url.Values
func (c *ChatUnfurlCall) Values() (url.Values, error) {
	if err := c.ValidateArgs(); err != nil {
		return nil, errors.Wrap(err, `failed validation`)
	}
	v := url.Values{}
	v.Set(`token`, c.service.token)

	v.Set("channel", c.channel)

	v.Set("ts", c.timestamp)

	v.Set("unfurls", c.unfurls)

	if c.userAuthRequired {
		v.Set("user_auth_required", "true")
	}
	return v, nil
}

type ChatUnfurlCallResponse interface {
	OK() bool
	ReplyTo() int
	Error() *objects.ErrorResponse
	Timestamp() string
}

type chatUnfurlCallResponseProxy struct {
	OK        bool                   `json:"ok"`
	ReplyTo   int                    `json:"reply_to"`
	Error     *objects.ErrorResponse `json:"error"`
	Timestamp string                 `json:"ts"`
	Payload0  json.RawMessage        `json:"-"`
}
type chatUnfurlCallResponse struct {
	ok      bool
	replyTo int
	error   *objects.ErrorResponse
	ts      string
}
type ChatUnfurlCallResponseBuilder struct {
	resp *chatUnfurlCallResponse
}

func BuildChatUnfurlCallResponse() *ChatUnfurlCallResponseBuilder {
	return &ChatUnfurlCallResponseBuilder{resp: &chatUnfurlCallResponse{}}
}
func (v *chatUnfurlCallResponse) OK() bool {
	return v.ok
}
func (v *chatUnfurlCallResponse) ReplyTo() int {
	return v.replyTo
}
func (v *chatUnfurlCallResponse) Error() *objects.ErrorResponse {
	return v.error
}
func (v *chatUnfurlCallResponse) Timestamp() string {
	return v.ts
}
func (b *ChatUnfurlCallResponseBuilder) OK(v bool) *ChatUnfurlCallResponseBuilder {
	b.resp.ok = v
	return b
}
func (b *ChatUnfurlCallResponseBuilder) ReplyTo(v int) *ChatUnfurlCallResponseBuilder {
	b.resp.replyTo = v
	return b
}
func (b *ChatUnfurlCallResponseBuilder) Error(v *objects.ErrorResponse) *ChatUnfurlCallResponseBuilder {
	b.resp.error = v
	return b
}
func (b *ChatUnfurlCallResponseBuilder) Timestamp(v string) *ChatUnfurlCallResponseBuilder {
	b.resp.ts = v
	return b
}
func (b *ChatUnfurlCallResponseBuilder) Build() ChatUnfurlCallResponse {
	v := b.resp
	b.resp = &chatUnfurlCallResponse{}
	return v
}
func (r *chatUnfurlCallResponseProxy) parse(data []byte) error {
	if err := json.Unmarshal(data, r); err != nil {
		return errors.Wrap(err, `failed to unmarshal ChatUnfurlCallResponse`)
	}
	r.Payload0 = data
	return nil
}
func (r *chatUnfurlCallResponse) MarshalJSON() ([]byte, error) {
	var p chatUnfurlCallResponseProxy
	p.OK = r.ok
	p.ReplyTo = r.replyTo
	p.Error = r.error
	p.Timestamp = r.ts
	return json.Marshal(p)
}

// Do executes the call to access chat.unfurl endpoint
func (c *ChatUnfurlCall) Do(ctx context.Context) error {
	const endpoint = "chat.unfurl"
	v, err := c.Values()
	if err != nil {
		return err
	}
	var res chatUnfurlCallResponseProxy
	if err := c.service.client.postForm(ctx, endpoint, v, &res); err != nil {
		return errors.Wrap(err, `failed to post to chat.unfurl`)
	}
	if !res.OK {
		var err error
		if errresp := res.Error; errresp != nil {
			err = errors.New(errresp.String())
		} else {
			err = errors.New(`unknown error while posting to chat.unfurl`)
		}
		return err
	}

	return nil
}

// FromValues parses the data in v and populates `c`
func (c *ChatUnfurlCall) FromValues(v url.Values) error {
	var tmp ChatUnfurlCall
	if raw := strings.TrimSpace(v.Get("channel")); len(raw) > 0 {
		tmp.channel = raw
	}
	if raw := strings.TrimSpace(v.Get("ts")); len(raw) > 0 {
		tmp.timestamp = raw
	}
	if raw := strings.TrimSpace(v.Get("unfurls")); len(raw) > 0 {
		tmp.unfurls = raw
	}
	if raw := strings.TrimSpace(v.Get("user_auth_required")); len(raw) > 0 {
		parsed, err := strconv.ParseBool(raw)
		if err != nil {
			return errors.Wrap(err, `failed to parse boolean value "user_auth_required"`)
		}
		tmp.userAuthRequired = parsed
	}
	*c = tmp
	return nil
}

// Update creates a ChatUpdateCall object in preparation for accessing the chat.update endpoint
func (s *ChatService) Update(channel string) *ChatUpdateCall {
	var call ChatUpdateCall
	call.service = s
	call.channel = channel
	return &call
}

// AsUser sets the value for optional asUser parameter
func (c *ChatUpdateCall) AsUser(asUser bool) *ChatUpdateCall {
	c.asUser = asUser
	return c
}

// SetAttachments sets the attachments list
func (c *ChatUpdateCall) SetAttachments(attachments objects.AttachmentList) *ChatUpdateCall {
	c.attachments = attachments
	return c
}

// Attachment appends to the attachments list
func (c *ChatUpdateCall) Attachment(attachment *objects.Attachment) *ChatUpdateCall {
	c.attachments.Append(attachment)
	return c
}

// SetBlocks sets the blocks list
func (c *ChatUpdateCall) SetBlocks(blocks objects.BlockList) *ChatUpdateCall {
	c.blocks = blocks
	return c
}

// Block appends to the blocks list
func (c *ChatUpdateCall) Block(block objects.Block) *ChatUpdateCall {
	c.blocks.Append(block)
	return c
}

// LinkNames sets the value for optional linkNames parameter
func (c *ChatUpdateCall) LinkNames(linkNames bool) *ChatUpdateCall {
	c.linkNames = linkNames
	return c
}

// Parse sets the value for optional parse parameter
func (c *ChatUpdateCall) Parse(parse string) *ChatUpdateCall {
	c.parse = parse
	return c
}

// Text sets the value for optional text parameter
func (c *ChatUpdateCall) Text(text string) *ChatUpdateCall {
	c.text = text
	return c
}

// Timestamp sets the value for optional timestamp parameter
func (c *ChatUpdateCall) Timestamp(timestamp string) *ChatUpdateCall {
	c.timestamp = timestamp
	return c
}

// ValidateArgs checks that all required fields are set in the ChatUpdateCall object
func (c *ChatUpdateCall) ValidateArgs() error {
	if len(c.channel) <= 0 {
		return errors.New(`required field channel not initialized`)
	}
	return nil
}

// Values returns the ChatUpdateCall object as url.Values
func (c *ChatUpdateCall) Values() (url.Values, error) {
	if err := c.ValidateArgs(); err != nil {
		return nil, errors.Wrap(err, `failed validation`)
	}
	v := url.Values{}
	v.Set(`token`, c.service.token)

	if c.asUser {
		v.Set("as_user", "true")
	}

	if len(c.attachments) > 0 {
		attachmentsEncoded, err := json.Marshal(c.attachments)
		if err != nil {
			return nil, errors.Wrap(err, `failed to encode field`)
		}
		v.Set("attachments", string(attachmentsEncoded))
	}

	if len(c.blocks) > 0 {
		blocksEncoded, err := json.Marshal(c.blocks)
		if err != nil {
			return nil, errors.Wrap(err, `failed to encode field`)
		}
		v.Set("blocks", string(blocksEncoded))
	}

	v.Set("channel", c.channel)

	if c.linkNames {
		v.Set("linkNames", "true")
	}

	if len(c.parse) > 0 {
		v.Set("parse", c.parse)
	}

	if len(c.text) > 0 {
		v.Set("text", c.text)
	}

	if len(c.timestamp) > 0 {
		v.Set("ts", c.timestamp)
	}
	return v, nil
}

type ChatUpdateCallResponse interface {
	OK() bool
	ReplyTo() int
	Error() *objects.ErrorResponse
	Timestamp() string
}

type chatUpdateCallResponseProxy struct {
	OK        bool                   `json:"ok"`
	ReplyTo   int                    `json:"reply_to"`
	Error     *objects.ErrorResponse `json:"error"`
	Timestamp string                 `json:"ts"`
	Payload0  json.RawMessage        `json:"-"`
}
type chatUpdateCallResponse struct {
	ok      bool
	replyTo int
	error   *objects.ErrorResponse
	ts      string
}
type ChatUpdateCallResponseBuilder struct {
	resp *chatUpdateCallResponse
}

func BuildChatUpdateCallResponse() *ChatUpdateCallResponseBuilder {
	return &ChatUpdateCallResponseBuilder{resp: &chatUpdateCallResponse{}}
}
func (v *chatUpdateCallResponse) OK() bool {
	return v.ok
}
func (v *chatUpdateCallResponse) ReplyTo() int {
	return v.replyTo
}
func (v *chatUpdateCallResponse) Error() *objects.ErrorResponse {
	return v.error
}
func (v *chatUpdateCallResponse) Timestamp() string {
	return v.ts
}
func (b *ChatUpdateCallResponseBuilder) OK(v bool) *ChatUpdateCallResponseBuilder {
	b.resp.ok = v
	return b
}
func (b *ChatUpdateCallResponseBuilder) ReplyTo(v int) *ChatUpdateCallResponseBuilder {
	b.resp.replyTo = v
	return b
}
func (b *ChatUpdateCallResponseBuilder) Error(v *objects.ErrorResponse) *ChatUpdateCallResponseBuilder {
	b.resp.error = v
	return b
}
func (b *ChatUpdateCallResponseBuilder) Timestamp(v string) *ChatUpdateCallResponseBuilder {
	b.resp.ts = v
	return b
}
func (b *ChatUpdateCallResponseBuilder) Build() ChatUpdateCallResponse {
	v := b.resp
	b.resp = &chatUpdateCallResponse{}
	return v
}
func (r *chatUpdateCallResponseProxy) parse(data []byte) error {
	if err := json.Unmarshal(data, r); err != nil {
		return errors.Wrap(err, `failed to unmarshal ChatUpdateCallResponse`)
	}
	r.Payload0 = data
	return nil
}
func (r *chatUpdateCallResponseProxy) payload() (*objects.ChatResponse, error) {
	var res0 objects.ChatResponse
	if err := json.Unmarshal(r.Payload0, &res0); err != nil {
		return nil, errors.Wrap(err, `failed to ummarshal objects.ChatResponse from response`)
	}
	return &res0, nil
}
func (r *chatUpdateCallResponse) MarshalJSON() ([]byte, error) {
	var p chatUpdateCallResponseProxy
	p.OK = r.ok
	p.ReplyTo = r.replyTo
	p.Error = r.error
	p.Timestamp = r.ts
	return json.Marshal(p)
}

// Do executes the call to access chat.update endpoint
func (c *ChatUpdateCall) Do(ctx context.Context) (*objects.ChatResponse, error) {
	const endpoint = "chat.update"
	v, err := c.Values()
	if err != nil {
		return nil, err
	}
	var res chatUpdateCallResponseProxy
	if err := c.service.client.postForm(ctx, endpoint, v, &res); err != nil {
		return nil, errors.Wrap(err, `failed to post to chat.update`)
	}
	if !res.OK {
		var err error
		if errresp := res.Error; errresp != nil {
			err = errors.New(errresp.String())
		} else {
			err = errors.New(`unknown error while posting to chat.update`)
		}
		return nil, err
	}

	return res.payload()
}

// FromValues parses the data in v and populates `c`
func (c *ChatUpdateCall) FromValues(v url.Values) error {
	var tmp ChatUpdateCall
	if raw := strings.TrimSpace(v.Get("as_user")); len(raw) > 0 {
		parsed, err := strconv.ParseBool(raw)
		if err != nil {
			return errors.Wrap(err, `failed to parse boolean value "as_user"`)
		}
		tmp.asUser = parsed
	}
	if raw := strings.TrimSpace(v.Get("attachments")); len(raw) > 0 {
		if err := json.Unmarshal([]byte(raw), &tmp.attachments); err != nil {
			return errors.Wrap(err, `failed to decode value "attachments"`)
		}
	}
	if raw := strings.TrimSpace(v.Get("blocks")); len(raw) > 0 {
		if err := json.Unmarshal([]byte(raw), &tmp.blocks); err != nil {
			return errors.Wrap(err, `failed to decode value "blocks"`)
		}
	}
	if raw := strings.TrimSpace(v.Get("channel")); len(raw) > 0 {
		tmp.channel = raw
	}
	if raw := strings.TrimSpace(v.Get("linkNames")); len(raw) > 0 {
		parsed, err := strconv.ParseBool(raw)
		if err != nil {
			return errors.Wrap(err, `failed to parse boolean value "linkNames"`)
		}
		tmp.linkNames = parsed
	}
	if raw := strings.TrimSpace(v.Get("parse")); len(raw) > 0 {
		tmp.parse = raw
	}
	if raw := strings.TrimSpace(v.Get("text")); len(raw) > 0 {
		tmp.text = raw
	}
	if raw := strings.TrimSpace(v.Get("ts")); len(raw) > 0 {
		tmp.timestamp = raw
	}
	*c = tmp
	return nil
}
