package slack

// Auto-generated by internal/cmd/genmethods/genmethods.go (generateServiceDetailsFile). DO NOT EDIT!

import (
	"context"
	"encoding/json"
	"net/url"
	"strconv"
	"strings"

	"github.com/lestrrat-go/slack/objects"
	"github.com/pkg/errors"
)

var _ = strconv.Itoa
var _ = strings.Index
var _ = json.Marshal
var _ = objects.EpochTime(0)

// EmojiListCall is created by EmojiService.List method call
type EmojiListCall struct {
	service *EmojiService
}

// List creates a EmojiListCall object in preparation for accessing the emoji.list endpoint
func (s *EmojiService) List() *EmojiListCall {
	var call EmojiListCall
	call.service = s
	return &call
}

// ValidateArgs checks that all required fields are set in the EmojiListCall object
func (c *EmojiListCall) ValidateArgs() error {
	return nil
}

// Values returns the EmojiListCall object as url.Values
func (c *EmojiListCall) Values() (url.Values, error) {
	if err := c.ValidateArgs(); err != nil {
		return nil, errors.Wrap(err, `failed validation`)
	}
	v := url.Values{}
	v.Set(`token`, c.service.token)
	return v, nil
}

type EmojiListCallResponse struct {
	OK        bool                   `json:"ok"`
	ReplyTo   int                    `json:"reply_to"`
	Error     *objects.ErrorResponse `json:"error"`
	Timestamp string                 `json:"ts"`
	Payload0  json.RawMessage        `json:"-"`
}

func (r *EmojiListCallResponse) parse(data []byte) error {
	if err := json.Unmarshal(data, r); err != nil {
		return errors.Wrap(err, `failed to unmarshal EmojiListCallResponse`)
	}
	r.Payload0 = data
	return nil
}
func (r *EmojiListCallResponse) payload() (*objects.EmojiListResponse, error) {
	var res0 objects.EmojiListResponse
	if err := json.Unmarshal(r.Payload0, &res0); err != nil {
		return nil, errors.Wrap(err, `failed to ummarshal objects.EmojiListResponse from response`)
	}
	return &res0, nil
}

// Do executes the call to access emoji.list endpoint
func (c *EmojiListCall) Do(ctx context.Context) (*objects.EmojiListResponse, error) {
	const endpoint = "emoji.list"
	v, err := c.Values()
	if err != nil {
		return nil, err
	}
	var res EmojiListCallResponse
	if err := c.service.client.postForm(ctx, endpoint, v, &res); err != nil {
		return nil, errors.Wrap(err, `failed to post to emoji.list`)
	}
	if !res.OK {
		var err error
		if errresp := res.Error; errresp != nil {
			err = errors.New(errresp.String())
		} else {
			err = errors.New(`unknown error while posting to emoji.list`)
		}
		return nil, err
	}

	return res.payload()
}

// FromValues parses the data in v and populates `c`
func (c *EmojiListCall) FromValues(v url.Values) error {
	var tmp EmojiListCall
	*c = tmp
	return nil
}
