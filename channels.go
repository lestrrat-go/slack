package slack

// Auto-generated by internal/cmd/genmethods/genmethods.go. DO NOT EDIT!

import (
	"context"
	"net/url"
	"strconv"

	"github.com/lestrrat/go-slack/objects"
	"github.com/pkg/errors"
)

var _ = strconv.Itoa
var _ = objects.EpochTime(0)

// ChannelsArchiveCall is created by ChannelsService.Archive method call
type ChannelsArchiveCall struct {
	service *ChannelsService
	channel string
}

// ChannelsCreateCall is created by ChannelsService.Create method call
type ChannelsCreateCall struct {
	service  *ChannelsService
	name     string
	validate bool
}

// ChannelsHistoryCall is created by ChannelsService.History method call
type ChannelsHistoryCall struct {
	service   *ChannelsService
	channel   string
	count     int // 1 - 1000
	inclusive bool
	latest    string // Range of time (end)
	oldest    string // Range of time (start)
	timestamp string // Used only when retrieving a single message
	unreads   bool   // Include unread_count_display in the output
}

// ChannelsInfoCall is created by ChannelsService.Info method call
type ChannelsInfoCall struct {
	service *ChannelsService
	channel string
}

// ChannelsInviteCall is created by ChannelsService.Invite method call
type ChannelsInviteCall struct {
	service *ChannelsService
	channel string
	user    string
}

// ChannelsJoinCall is created by ChannelsService.Join method call
type ChannelsJoinCall struct {
	service  *ChannelsService
	name     string
	validate bool
}

// ChannelsKickCall is created by ChannelsService.Kick method call
type ChannelsKickCall struct {
	service *ChannelsService
	channel string
	user    string
}

// ChannelsLeaveCall is created by ChannelsService.Leave method call
type ChannelsLeaveCall struct {
	service *ChannelsService
	channel string
}

// ChannelsListCall is created by ChannelsService.List method call
type ChannelsListCall struct {
	service      *ChannelsService
	exclArchived bool
}

// Archive creates a ChannelsArchiveCall object in preparation for accessing the channels.archive endpoint
func (s *ChannelsService) Archive(channel string) *ChannelsArchiveCall {
	var call ChannelsArchiveCall
	call.service = s
	call.channel = channel
	return &call
}

// Values returns the ChannelsArchiveCall object as url.Values
func (c *ChannelsArchiveCall) Values() (url.Values, error) {
	v := url.Values{}
	v.Set(`token`, c.service.token)

	if len(c.channel) <= 0 {
		return nil, errors.New(`missing required parameter channel`)
	}
	v.Set("channel", c.channel)
	return v, nil
}

// Do executes the call to access channels.archive endpoint
func (c *ChannelsArchiveCall) Do(ctx context.Context) error {
	const endpoint = "channels.archive"
	v, err := c.Values()
	if err != nil {
		return err
	}
	var res struct {
		SlackResponse
	}
	if err := c.service.client.postForm(ctx, endpoint, v, &res); err != nil {
		return errors.Wrap(err, `failed to post to channels.archive`)
	}
	if !res.OK {
		return errors.New(res.Error.String())
	}

	return nil
}

// Create creates a ChannelsCreateCall object in preparation for accessing the channels.create endpoint
func (s *ChannelsService) Create(name string) *ChannelsCreateCall {
	var call ChannelsCreateCall
	call.service = s
	call.name = name
	return &call
}

// Validate sets the value for optional validate parameter
func (c *ChannelsCreateCall) Validate(validate bool) *ChannelsCreateCall {
	c.validate = validate
	return c
}

// Values returns the ChannelsCreateCall object as url.Values
func (c *ChannelsCreateCall) Values() (url.Values, error) {
	v := url.Values{}
	v.Set(`token`, c.service.token)

	if len(c.name) <= 0 {
		return nil, errors.New(`missing required parameter name`)
	}
	v.Set("name", c.name)

	if c.validate {
		v.Set("validate", "true")
	}
	return v, nil
}

// Do executes the call to access channels.create endpoint
func (c *ChannelsCreateCall) Do(ctx context.Context) error {
	const endpoint = "channels.create"
	v, err := c.Values()
	if err != nil {
		return err
	}
	var res struct {
		SlackResponse
	}
	if err := c.service.client.postForm(ctx, endpoint, v, &res); err != nil {
		return errors.Wrap(err, `failed to post to channels.create`)
	}
	if !res.OK {
		return errors.New(res.Error.String())
	}

	return nil
}

// History creates a ChannelsHistoryCall object in preparation for accessing the channels.history endpoint
func (s *ChannelsService) History(channel string) *ChannelsHistoryCall {
	var call ChannelsHistoryCall
	call.service = s
	call.channel = channel
	return &call
}

// Count sets the value for optional count parameter
func (c *ChannelsHistoryCall) Count(count int) *ChannelsHistoryCall {
	c.count = count
	return c
}

// Inclusive sets the value for optional inclusive parameter
func (c *ChannelsHistoryCall) Inclusive(inclusive bool) *ChannelsHistoryCall {
	c.inclusive = inclusive
	return c
}

// Latest sets the value for optional latest parameter
func (c *ChannelsHistoryCall) Latest(latest string) *ChannelsHistoryCall {
	c.latest = latest
	return c
}

// Oldest sets the value for optional oldest parameter
func (c *ChannelsHistoryCall) Oldest(oldest string) *ChannelsHistoryCall {
	c.oldest = oldest
	return c
}

// Timestamp sets the value for optional timestamp parameter
func (c *ChannelsHistoryCall) Timestamp(timestamp string) *ChannelsHistoryCall {
	c.timestamp = timestamp
	return c
}

// Unreads sets the value for optional unreads parameter
func (c *ChannelsHistoryCall) Unreads(unreads bool) *ChannelsHistoryCall {
	c.unreads = unreads
	return c
}

// Values returns the ChannelsHistoryCall object as url.Values
func (c *ChannelsHistoryCall) Values() (url.Values, error) {
	v := url.Values{}
	v.Set(`token`, c.service.token)

	if len(c.channel) <= 0 {
		return nil, errors.New(`missing required parameter channel`)
	}
	v.Set("channel", c.channel)

	if c.count > 0 {
		v.Set("count", strconv.Itoa(c.count))
	}

	if c.inclusive {
		v.Set("inclusive", "true")
	}

	if len(c.latest) > 0 {
		v.Set("latest", c.latest)
	}

	if len(c.oldest) > 0 {
		v.Set("oldest", c.oldest)
	}

	if len(c.timestamp) > 0 {
		v.Set("ts", c.timestamp)
	}

	if c.unreads {
		v.Set("unreads", "true")
	}
	return v, nil
}

// Do executes the call to access channels.history endpoint
func (c *ChannelsHistoryCall) Do(ctx context.Context) (*ChannelsHistoryResponse, error) {
	const endpoint = "channels.history"
	v, err := c.Values()
	if err != nil {
		return nil, err
	}
	var res struct {
		SlackResponse
		*ChannelsHistoryResponse
	}
	if err := c.service.client.postForm(ctx, endpoint, v, &res); err != nil {
		return nil, errors.Wrap(err, `failed to post to channels.history`)
	}
	if !res.OK {
		return nil, errors.New(res.Error.String())
	}

	return res.ChannelsHistoryResponse, nil
}

// Info creates a ChannelsInfoCall object in preparation for accessing the channels.info endpoint
func (s *ChannelsService) Info(channel string) *ChannelsInfoCall {
	var call ChannelsInfoCall
	call.service = s
	call.channel = channel
	return &call
}

// Values returns the ChannelsInfoCall object as url.Values
func (c *ChannelsInfoCall) Values() (url.Values, error) {
	v := url.Values{}
	v.Set(`token`, c.service.token)

	if len(c.channel) <= 0 {
		return nil, errors.New(`missing required parameter channel`)
	}
	v.Set("channel", c.channel)
	return v, nil
}

// Do executes the call to access channels.info endpoint
func (c *ChannelsInfoCall) Do(ctx context.Context) (*objects.Channel, error) {
	const endpoint = "channels.info"
	v, err := c.Values()
	if err != nil {
		return nil, err
	}
	var res struct {
		SlackResponse
		*objects.Channel
	}
	if err := c.service.client.postForm(ctx, endpoint, v, &res); err != nil {
		return nil, errors.Wrap(err, `failed to post to channels.info`)
	}
	if !res.OK {
		return nil, errors.New(res.Error.String())
	}

	return res.Channel, nil
}

// Invite creates a ChannelsInviteCall object in preparation for accessing the channels.invite endpoint
func (s *ChannelsService) Invite(channel string, user string) *ChannelsInviteCall {
	var call ChannelsInviteCall
	call.service = s
	call.channel = channel
	call.user = user
	return &call
}

// Values returns the ChannelsInviteCall object as url.Values
func (c *ChannelsInviteCall) Values() (url.Values, error) {
	v := url.Values{}
	v.Set(`token`, c.service.token)

	if len(c.channel) <= 0 {
		return nil, errors.New(`missing required parameter channel`)
	}
	v.Set("channel", c.channel)

	if len(c.user) <= 0 {
		return nil, errors.New(`missing required parameter user`)
	}
	v.Set("user", c.user)
	return v, nil
}

// Do executes the call to access channels.invite endpoint
func (c *ChannelsInviteCall) Do(ctx context.Context) (*objects.Channel, error) {
	const endpoint = "channels.invite"
	v, err := c.Values()
	if err != nil {
		return nil, err
	}
	var res struct {
		SlackResponse
		*objects.Channel
	}
	if err := c.service.client.postForm(ctx, endpoint, v, &res); err != nil {
		return nil, errors.Wrap(err, `failed to post to channels.invite`)
	}
	if !res.OK {
		return nil, errors.New(res.Error.String())
	}

	return res.Channel, nil
}

// Join creates a ChannelsJoinCall object in preparation for accessing the channels.join endpoint
func (s *ChannelsService) Join(name string) *ChannelsJoinCall {
	var call ChannelsJoinCall
	call.service = s
	call.name = name
	return &call
}

// Validate sets the value for optional validate parameter
func (c *ChannelsJoinCall) Validate(validate bool) *ChannelsJoinCall {
	c.validate = validate
	return c
}

// Values returns the ChannelsJoinCall object as url.Values
func (c *ChannelsJoinCall) Values() (url.Values, error) {
	v := url.Values{}
	v.Set(`token`, c.service.token)

	if len(c.name) <= 0 {
		return nil, errors.New(`missing required parameter name`)
	}
	v.Set("name", c.name)

	if c.validate {
		v.Set("validate", "true")
	}
	return v, nil
}

// Do executes the call to access channels.join endpoint
func (c *ChannelsJoinCall) Do(ctx context.Context) (*objects.Channel, error) {
	const endpoint = "channels.join"
	v, err := c.Values()
	if err != nil {
		return nil, err
	}
	var res struct {
		SlackResponse
		*objects.Channel
	}
	if err := c.service.client.postForm(ctx, endpoint, v, &res); err != nil {
		return nil, errors.Wrap(err, `failed to post to channels.join`)
	}
	if !res.OK {
		return nil, errors.New(res.Error.String())
	}

	return res.Channel, nil
}

// Kick creates a ChannelsKickCall object in preparation for accessing the channels.kick endpoint
func (s *ChannelsService) Kick(channel string, user string) *ChannelsKickCall {
	var call ChannelsKickCall
	call.service = s
	call.channel = channel
	call.user = user
	return &call
}

// Values returns the ChannelsKickCall object as url.Values
func (c *ChannelsKickCall) Values() (url.Values, error) {
	v := url.Values{}
	v.Set(`token`, c.service.token)

	if len(c.channel) <= 0 {
		return nil, errors.New(`missing required parameter channel`)
	}
	v.Set("channel", c.channel)

	if len(c.user) <= 0 {
		return nil, errors.New(`missing required parameter user`)
	}
	v.Set("user", c.user)
	return v, nil
}

// Do executes the call to access channels.kick endpoint
func (c *ChannelsKickCall) Do(ctx context.Context) error {
	const endpoint = "channels.kick"
	v, err := c.Values()
	if err != nil {
		return err
	}
	var res struct {
		SlackResponse
	}
	if err := c.service.client.postForm(ctx, endpoint, v, &res); err != nil {
		return errors.Wrap(err, `failed to post to channels.kick`)
	}
	if !res.OK {
		return errors.New(res.Error.String())
	}

	return nil
}

// Leave creates a ChannelsLeaveCall object in preparation for accessing the channels.leave endpoint
func (s *ChannelsService) Leave(channel string) *ChannelsLeaveCall {
	var call ChannelsLeaveCall
	call.service = s
	call.channel = channel
	return &call
}

// Values returns the ChannelsLeaveCall object as url.Values
func (c *ChannelsLeaveCall) Values() (url.Values, error) {
	v := url.Values{}
	v.Set(`token`, c.service.token)

	if len(c.channel) <= 0 {
		return nil, errors.New(`missing required parameter channel`)
	}
	v.Set("channel", c.channel)
	return v, nil
}

// Do executes the call to access channels.leave endpoint
func (c *ChannelsLeaveCall) Do(ctx context.Context) error {
	const endpoint = "channels.leave"
	v, err := c.Values()
	if err != nil {
		return err
	}
	var res struct {
		SlackResponse
	}
	if err := c.service.client.postForm(ctx, endpoint, v, &res); err != nil {
		return errors.Wrap(err, `failed to post to channels.leave`)
	}
	if !res.OK {
		return errors.New(res.Error.String())
	}

	return nil
}

// List creates a ChannelsListCall object in preparation for accessing the channels.list endpoint
func (s *ChannelsService) List() *ChannelsListCall {
	var call ChannelsListCall
	call.service = s
	return &call
}

// ExclArchived sets the value for optional exclArchived parameter
func (c *ChannelsListCall) ExclArchived(exclArchived bool) *ChannelsListCall {
	c.exclArchived = exclArchived
	return c
}

// Values returns the ChannelsListCall object as url.Values
func (c *ChannelsListCall) Values() (url.Values, error) {
	v := url.Values{}
	v.Set(`token`, c.service.token)

	if c.exclArchived {
		v.Set("exclArchived", "true")
	}
	return v, nil
}

// Do executes the call to access channels.list endpoint
func (c *ChannelsListCall) Do(ctx context.Context) (objects.ChannelList, error) {
	const endpoint = "channels.list"
	v, err := c.Values()
	if err != nil {
		return nil, err
	}
	var res struct {
		SlackResponse
		objects.ChannelList
	}
	if err := c.service.client.postForm(ctx, endpoint, v, &res); err != nil {
		return nil, errors.Wrap(err, `failed to post to channels.list`)
	}
	if !res.OK {
		return nil, errors.New(res.Error.String())
	}

	return res.ChannelList, nil
}
