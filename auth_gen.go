package slack

// Auto-generated by internal/cmd/genmethods/genmethods.go (generateServiceDetailsFile). DO NOT EDIT!

import (
	"context"
	"encoding/json"
	"net/url"
	"strconv"
	"strings"

	"github.com/lestrrat-go/slack/objects"
	"github.com/pkg/errors"
)

var _ = strconv.Itoa
var _ = strings.Index
var _ = json.Marshal
var _ = objects.EpochTime(0)

// AuthRevokeCall is created by AuthService.Revoke method call
type AuthRevokeCall struct {
	service *AuthService
	test    bool
}

// AuthTestCall is created by AuthService.Test method call
type AuthTestCall struct {
	service *AuthService
}

// Revoke creates a AuthRevokeCall object in preparation for accessing the auth.revoke endpoint
func (s *AuthService) Revoke() *AuthRevokeCall {
	var call AuthRevokeCall
	call.service = s
	return &call
}

// Test sets the value for optional test parameter
func (c *AuthRevokeCall) Test(test bool) *AuthRevokeCall {
	c.test = test
	return c
}

// ValidateArgs checks that all required fields are set in the AuthRevokeCall object
func (c *AuthRevokeCall) ValidateArgs() error {
	return nil
}

// Values returns the AuthRevokeCall object as url.Values
func (c *AuthRevokeCall) Values() (url.Values, error) {
	if err := c.ValidateArgs(); err != nil {
		return nil, errors.Wrap(err, `failed validation`)
	}
	v := url.Values{}
	v.Set(`token`, c.service.token)

	if c.test {
		v.Set("test", "true")
	}
	return v, nil
}

type AuthRevokeCallResponse interface {
	OK() bool
	ReplyTo() int
	Error() *objects.ErrorResponse
	Timestamp() string
}

type authRevokeCallResponseProxy struct {
	OK        bool                   `json:"ok"`
	ReplyTo   int                    `json:"reply_to"`
	Error     *objects.ErrorResponse `json:"error"`
	Timestamp string                 `json:"ts"`
	Payload0  json.RawMessage        `json:"-"`
}
type authRevokeCallResponse struct {
	ok      bool
	replyTo int
	error   *objects.ErrorResponse
	ts      string
}
type AuthRevokeCallResponseBuilder struct {
	resp *authRevokeCallResponse
}

func BuildAuthRevokeCallResponse() *AuthRevokeCallResponseBuilder {
	return &AuthRevokeCallResponseBuilder{resp: &authRevokeCallResponse{}}
}
func (v *authRevokeCallResponse) OK() bool {
	return v.ok
}
func (v *authRevokeCallResponse) ReplyTo() int {
	return v.replyTo
}
func (v *authRevokeCallResponse) Error() *objects.ErrorResponse {
	return v.error
}
func (v *authRevokeCallResponse) Timestamp() string {
	return v.ts
}
func (b *AuthRevokeCallResponseBuilder) OK(v bool) *AuthRevokeCallResponseBuilder {
	b.resp.ok = v
	return b
}
func (b *AuthRevokeCallResponseBuilder) ReplyTo(v int) *AuthRevokeCallResponseBuilder {
	b.resp.replyTo = v
	return b
}
func (b *AuthRevokeCallResponseBuilder) Error(v *objects.ErrorResponse) *AuthRevokeCallResponseBuilder {
	b.resp.error = v
	return b
}
func (b *AuthRevokeCallResponseBuilder) Timestamp(v string) *AuthRevokeCallResponseBuilder {
	b.resp.ts = v
	return b
}
func (b *AuthRevokeCallResponseBuilder) Build() AuthRevokeCallResponse {
	v := b.resp
	b.resp = &authRevokeCallResponse{}
	return v
}
func (r *authRevokeCallResponseProxy) parse(data []byte) error {
	if err := json.Unmarshal(data, r); err != nil {
		return errors.Wrap(err, `failed to unmarshal AuthRevokeCallResponse`)
	}
	r.Payload0 = data
	return nil
}

// Do executes the call to access auth.revoke endpoint
func (c *AuthRevokeCall) Do(ctx context.Context) error {
	const endpoint = "auth.revoke"
	v, err := c.Values()
	if err != nil {
		return err
	}
	var res authRevokeCallResponseProxy
	if err := c.service.client.postForm(ctx, endpoint, v, &res); err != nil {
		return errors.Wrap(err, `failed to post to auth.revoke`)
	}
	if !res.OK {
		var err error
		if errresp := res.Error; errresp != nil {
			err = errors.New(errresp.String())
		} else {
			err = errors.New(`unknown error while posting to auth.revoke`)
		}
		return err
	}

	return nil
}

// FromValues parses the data in v and populates `c`
func (c *AuthRevokeCall) FromValues(v url.Values) error {
	var tmp AuthRevokeCall
	if raw := strings.TrimSpace(v.Get("test")); len(raw) > 0 {
		parsed, err := strconv.ParseBool(raw)
		if err != nil {
			return errors.Wrap(err, `failed to parse boolean value "test"`)
		}
		tmp.test = parsed
	}
	*c = tmp
	return nil
}

// Test creates a AuthTestCall object in preparation for accessing the auth.test endpoint
func (s *AuthService) Test() *AuthTestCall {
	var call AuthTestCall
	call.service = s
	return &call
}

// ValidateArgs checks that all required fields are set in the AuthTestCall object
func (c *AuthTestCall) ValidateArgs() error {
	return nil
}

// Values returns the AuthTestCall object as url.Values
func (c *AuthTestCall) Values() (url.Values, error) {
	if err := c.ValidateArgs(); err != nil {
		return nil, errors.Wrap(err, `failed validation`)
	}
	v := url.Values{}
	v.Set(`token`, c.service.token)
	return v, nil
}

type AuthTestCallResponse interface {
	OK() bool
	ReplyTo() int
	Error() *objects.ErrorResponse
	Timestamp() string
}

type authTestCallResponseProxy struct {
	OK        bool                   `json:"ok"`
	ReplyTo   int                    `json:"reply_to"`
	Error     *objects.ErrorResponse `json:"error"`
	Timestamp string                 `json:"ts"`
	Payload0  json.RawMessage        `json:"-"`
}
type authTestCallResponse struct {
	ok      bool
	replyTo int
	error   *objects.ErrorResponse
	ts      string
}
type AuthTestCallResponseBuilder struct {
	resp *authTestCallResponse
}

func BuildAuthTestCallResponse() *AuthTestCallResponseBuilder {
	return &AuthTestCallResponseBuilder{resp: &authTestCallResponse{}}
}
func (v *authTestCallResponse) OK() bool {
	return v.ok
}
func (v *authTestCallResponse) ReplyTo() int {
	return v.replyTo
}
func (v *authTestCallResponse) Error() *objects.ErrorResponse {
	return v.error
}
func (v *authTestCallResponse) Timestamp() string {
	return v.ts
}
func (b *AuthTestCallResponseBuilder) OK(v bool) *AuthTestCallResponseBuilder {
	b.resp.ok = v
	return b
}
func (b *AuthTestCallResponseBuilder) ReplyTo(v int) *AuthTestCallResponseBuilder {
	b.resp.replyTo = v
	return b
}
func (b *AuthTestCallResponseBuilder) Error(v *objects.ErrorResponse) *AuthTestCallResponseBuilder {
	b.resp.error = v
	return b
}
func (b *AuthTestCallResponseBuilder) Timestamp(v string) *AuthTestCallResponseBuilder {
	b.resp.ts = v
	return b
}
func (b *AuthTestCallResponseBuilder) Build() AuthTestCallResponse {
	v := b.resp
	b.resp = &authTestCallResponse{}
	return v
}
func (r *authTestCallResponseProxy) parse(data []byte) error {
	if err := json.Unmarshal(data, r); err != nil {
		return errors.Wrap(err, `failed to unmarshal AuthTestCallResponse`)
	}
	r.Payload0 = data
	return nil
}
func (r *authTestCallResponseProxy) payload() (*objects.AuthTestResponse, error) {
	var res0 objects.AuthTestResponse
	if err := json.Unmarshal(r.Payload0, &res0); err != nil {
		return nil, errors.Wrap(err, `failed to ummarshal objects.AuthTestResponse from response`)
	}
	return &res0, nil
}

// Do executes the call to access auth.test endpoint
func (c *AuthTestCall) Do(ctx context.Context) (*objects.AuthTestResponse, error) {
	const endpoint = "auth.test"
	v, err := c.Values()
	if err != nil {
		return nil, err
	}
	var res authTestCallResponseProxy
	if err := c.service.client.postForm(ctx, endpoint, v, &res); err != nil {
		return nil, errors.Wrap(err, `failed to post to auth.test`)
	}
	if !res.OK {
		var err error
		if errresp := res.Error; errresp != nil {
			err = errors.New(errresp.String())
		} else {
			err = errors.New(`unknown error while posting to auth.test`)
		}
		return nil, err
	}

	return res.payload()
}

// FromValues parses the data in v and populates `c`
func (c *AuthTestCall) FromValues(v url.Values) error {
	var tmp AuthTestCall
	*c = tmp
	return nil
}
