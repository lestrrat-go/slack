package slack

// Auto-generated by internal/cmd/genmethods/genmethods.go (generateServiceDetailsFile). DO NOT EDIT!

import (
	"context"
	"encoding/json"
	"net/url"
	"strconv"
	"strings"

	"github.com/lestrrat-go/slack/objects"
	"github.com/pkg/errors"
)

var _ = strconv.Itoa
var _ = strings.Index
var _ = json.Marshal
var _ = objects.EpochTime(0)

// UsergroupsCreateCall is created by UsergroupsService.Create method call
type UsergroupsCreateCall struct {
	service      *UsergroupsService
	channels     string // Comma-separated list of channels IDs
	description  string
	handle       string
	includeCount bool
	name         string
}

// UsergroupsDisableCall is created by UsergroupsService.Disable method call
type UsergroupsDisableCall struct {
	service      *UsergroupsService
	includeCount bool
	usergroup    string
}

// UsergroupsEnableCall is created by UsergroupsService.Enable method call
type UsergroupsEnableCall struct {
	service      *UsergroupsService
	includeCount bool
	usergroup    string
}

// UsergroupsListCall is created by UsergroupsService.List method call
type UsergroupsListCall struct {
	service         *UsergroupsService
	includeCount    bool
	includeDisabled bool
	includeUsers    bool
}

// UsergroupsUpdateCall is created by UsergroupsService.Update method call
type UsergroupsUpdateCall struct {
	service      *UsergroupsService
	channels     string // Comma-separated list of channels IDs
	description  string
	handle       string
	includeCount bool
	name         string
	usergroup    string
}

// Create creates a UsergroupsCreateCall object in preparation for accessing the usergroups.create endpoint
func (s *UsergroupsService) Create(name string) *UsergroupsCreateCall {
	var call UsergroupsCreateCall
	call.service = s
	call.name = name
	return &call
}

// Channels sets the value for optional channels parameter
func (c *UsergroupsCreateCall) Channels(channels string) *UsergroupsCreateCall {
	c.channels = channels
	return c
}

// Description sets the value for optional description parameter
func (c *UsergroupsCreateCall) Description(description string) *UsergroupsCreateCall {
	c.description = description
	return c
}

// Handle sets the value for optional handle parameter
func (c *UsergroupsCreateCall) Handle(handle string) *UsergroupsCreateCall {
	c.handle = handle
	return c
}

// IncludeCount sets the value for optional includeCount parameter
func (c *UsergroupsCreateCall) IncludeCount(includeCount bool) *UsergroupsCreateCall {
	c.includeCount = includeCount
	return c
}

// ValidateArgs checks that all required fields are set in the UsergroupsCreateCall object
func (c *UsergroupsCreateCall) ValidateArgs() error {
	if len(c.name) <= 0 {
		return errors.New(`required field name not initialized`)
	}
	return nil
}

// Values returns the UsergroupsCreateCall object as url.Values
func (c *UsergroupsCreateCall) Values() (url.Values, error) {
	if err := c.ValidateArgs(); err != nil {
		return nil, errors.Wrap(err, `failed validation`)
	}
	v := url.Values{}
	v.Set(`token`, c.service.token)

	if len(c.channels) > 0 {
		v.Set("channels", c.channels)
	}

	if len(c.description) > 0 {
		v.Set("description", c.description)
	}

	if len(c.handle) > 0 {
		v.Set("handle", c.handle)
	}

	if c.includeCount {
		v.Set("include_count", "true")
	}

	v.Set("name", c.name)
	return v, nil
}

type UsergroupsCreateCallResponse interface {
	OK() bool
	ReplyTo() int
	Error() *objects.ErrorResponse
	Timestamp() string
	Usergroup() *objects.Usergroup
}

type usergroupsCreateCallResponseProxy struct {
	OK        bool                   `json:"ok"`
	ReplyTo   int                    `json:"reply_to"`
	Error     *objects.ErrorResponse `json:"error"`
	Timestamp string                 `json:"ts"`
	Payload0  json.RawMessage        `json:"-"`
	Payload1  json.RawMessage        `json:"usergroup"`
}
type usergroupsCreateCallResponse struct {
	ok        bool
	replyTo   int
	error     *objects.ErrorResponse
	ts        string
	usergroup *objects.Usergroup
}
type UsergroupsCreateCallResponseBuilder struct {
	resp *usergroupsCreateCallResponse
}

func BuildUsergroupsCreateCallResponse() *UsergroupsCreateCallResponseBuilder {
	return &UsergroupsCreateCallResponseBuilder{resp: &usergroupsCreateCallResponse{}}
}
func (v *usergroupsCreateCallResponse) OK() bool {
	return v.ok
}
func (v *usergroupsCreateCallResponse) ReplyTo() int {
	return v.replyTo
}
func (v *usergroupsCreateCallResponse) Error() *objects.ErrorResponse {
	return v.error
}
func (v *usergroupsCreateCallResponse) Timestamp() string {
	return v.ts
}
func (v *usergroupsCreateCallResponse) Usergroup() *objects.Usergroup {
	return v.usergroup
}
func (b *UsergroupsCreateCallResponseBuilder) OK(v bool) *UsergroupsCreateCallResponseBuilder {
	b.resp.ok = v
	return b
}
func (b *UsergroupsCreateCallResponseBuilder) ReplyTo(v int) *UsergroupsCreateCallResponseBuilder {
	b.resp.replyTo = v
	return b
}
func (b *UsergroupsCreateCallResponseBuilder) Error(v *objects.ErrorResponse) *UsergroupsCreateCallResponseBuilder {
	b.resp.error = v
	return b
}
func (b *UsergroupsCreateCallResponseBuilder) Timestamp(v string) *UsergroupsCreateCallResponseBuilder {
	b.resp.ts = v
	return b
}
func (b *UsergroupsCreateCallResponseBuilder) Usergroup(v *objects.Usergroup) *UsergroupsCreateCallResponseBuilder {
	b.resp.usergroup = v
	return b
}
func (b *UsergroupsCreateCallResponseBuilder) Build() UsergroupsCreateCallResponse {
	v := b.resp
	b.resp = &usergroupsCreateCallResponse{}
	return v
}
func (r *usergroupsCreateCallResponseProxy) parse(data []byte) error {
	if err := json.Unmarshal(data, r); err != nil {
		return errors.Wrap(err, `failed to unmarshal UsergroupsCreateCallResponse`)
	}
	r.Payload0 = data
	return nil
}
func (r *usergroupsCreateCallResponseProxy) payload() (*objects.Usergroup, error) {
	var res1 objects.Usergroup
	if err := json.Unmarshal(r.Payload1, &res1); err != nil {
		return nil, errors.Wrap(err, `failed to ummarshal objects.Usergroup from response`)
	}
	return &res1, nil
}
func (r *usergroupsCreateCallResponse) MarshalJSON() ([]byte, error) {
	var p usergroupsCreateCallResponseProxy
	p.OK = r.ok
	p.ReplyTo = r.replyTo
	p.Error = r.error
	p.Timestamp = r.ts
	payload1, err := json.Marshal(r.usergroup)
	if err != nil {
		return nil, errors.Wrap(err, `failed to marshal 'usergroup' field`)
	}
	p.Payload1 = payload1
	return json.Marshal(p)
}

// Do executes the call to access usergroups.create endpoint
func (c *UsergroupsCreateCall) Do(ctx context.Context) (*objects.Usergroup, error) {
	const endpoint = "usergroups.create"
	v, err := c.Values()
	if err != nil {
		return nil, err
	}
	var res usergroupsCreateCallResponseProxy
	if err := c.service.client.postForm(ctx, endpoint, v, &res); err != nil {
		return nil, errors.Wrap(err, `failed to post to usergroups.create`)
	}
	if !res.OK {
		var err error
		if errresp := res.Error; errresp != nil {
			err = errors.New(errresp.String())
		} else {
			err = errors.New(`unknown error while posting to usergroups.create`)
		}
		return nil, err
	}

	return res.payload()
}

// FromValues parses the data in v and populates `c`
func (c *UsergroupsCreateCall) FromValues(v url.Values) error {
	var tmp UsergroupsCreateCall
	if raw := strings.TrimSpace(v.Get("channels")); len(raw) > 0 {
		tmp.channels = raw
	}
	if raw := strings.TrimSpace(v.Get("description")); len(raw) > 0 {
		tmp.description = raw
	}
	if raw := strings.TrimSpace(v.Get("handle")); len(raw) > 0 {
		tmp.handle = raw
	}
	if raw := strings.TrimSpace(v.Get("include_count")); len(raw) > 0 {
		parsed, err := strconv.ParseBool(raw)
		if err != nil {
			return errors.Wrap(err, `failed to parse boolean value "include_count"`)
		}
		tmp.includeCount = parsed
	}
	if raw := strings.TrimSpace(v.Get("name")); len(raw) > 0 {
		tmp.name = raw
	}
	*c = tmp
	return nil
}

// Disable creates a UsergroupsDisableCall object in preparation for accessing the usergroups.disable endpoint
func (s *UsergroupsService) Disable(usergroup string) *UsergroupsDisableCall {
	var call UsergroupsDisableCall
	call.service = s
	call.usergroup = usergroup
	return &call
}

// IncludeCount sets the value for optional includeCount parameter
func (c *UsergroupsDisableCall) IncludeCount(includeCount bool) *UsergroupsDisableCall {
	c.includeCount = includeCount
	return c
}

// ValidateArgs checks that all required fields are set in the UsergroupsDisableCall object
func (c *UsergroupsDisableCall) ValidateArgs() error {
	if len(c.usergroup) <= 0 {
		return errors.New(`required field usergroup not initialized`)
	}
	return nil
}

// Values returns the UsergroupsDisableCall object as url.Values
func (c *UsergroupsDisableCall) Values() (url.Values, error) {
	if err := c.ValidateArgs(); err != nil {
		return nil, errors.Wrap(err, `failed validation`)
	}
	v := url.Values{}
	v.Set(`token`, c.service.token)

	if c.includeCount {
		v.Set("include_count", "true")
	}

	v.Set("usergroup", c.usergroup)
	return v, nil
}

type UsergroupsDisableCallResponse interface {
	OK() bool
	ReplyTo() int
	Error() *objects.ErrorResponse
	Timestamp() string
	Usergroup() *objects.Usergroup
}

type usergroupsDisableCallResponseProxy struct {
	OK        bool                   `json:"ok"`
	ReplyTo   int                    `json:"reply_to"`
	Error     *objects.ErrorResponse `json:"error"`
	Timestamp string                 `json:"ts"`
	Payload0  json.RawMessage        `json:"-"`
	Payload1  json.RawMessage        `json:"usergroup"`
}
type usergroupsDisableCallResponse struct {
	ok        bool
	replyTo   int
	error     *objects.ErrorResponse
	ts        string
	usergroup *objects.Usergroup
}
type UsergroupsDisableCallResponseBuilder struct {
	resp *usergroupsDisableCallResponse
}

func BuildUsergroupsDisableCallResponse() *UsergroupsDisableCallResponseBuilder {
	return &UsergroupsDisableCallResponseBuilder{resp: &usergroupsDisableCallResponse{}}
}
func (v *usergroupsDisableCallResponse) OK() bool {
	return v.ok
}
func (v *usergroupsDisableCallResponse) ReplyTo() int {
	return v.replyTo
}
func (v *usergroupsDisableCallResponse) Error() *objects.ErrorResponse {
	return v.error
}
func (v *usergroupsDisableCallResponse) Timestamp() string {
	return v.ts
}
func (v *usergroupsDisableCallResponse) Usergroup() *objects.Usergroup {
	return v.usergroup
}
func (b *UsergroupsDisableCallResponseBuilder) OK(v bool) *UsergroupsDisableCallResponseBuilder {
	b.resp.ok = v
	return b
}
func (b *UsergroupsDisableCallResponseBuilder) ReplyTo(v int) *UsergroupsDisableCallResponseBuilder {
	b.resp.replyTo = v
	return b
}
func (b *UsergroupsDisableCallResponseBuilder) Error(v *objects.ErrorResponse) *UsergroupsDisableCallResponseBuilder {
	b.resp.error = v
	return b
}
func (b *UsergroupsDisableCallResponseBuilder) Timestamp(v string) *UsergroupsDisableCallResponseBuilder {
	b.resp.ts = v
	return b
}
func (b *UsergroupsDisableCallResponseBuilder) Usergroup(v *objects.Usergroup) *UsergroupsDisableCallResponseBuilder {
	b.resp.usergroup = v
	return b
}
func (b *UsergroupsDisableCallResponseBuilder) Build() UsergroupsDisableCallResponse {
	v := b.resp
	b.resp = &usergroupsDisableCallResponse{}
	return v
}
func (r *usergroupsDisableCallResponseProxy) parse(data []byte) error {
	if err := json.Unmarshal(data, r); err != nil {
		return errors.Wrap(err, `failed to unmarshal UsergroupsDisableCallResponse`)
	}
	r.Payload0 = data
	return nil
}
func (r *usergroupsDisableCallResponseProxy) payload() (*objects.Usergroup, error) {
	var res1 objects.Usergroup
	if err := json.Unmarshal(r.Payload1, &res1); err != nil {
		return nil, errors.Wrap(err, `failed to ummarshal objects.Usergroup from response`)
	}
	return &res1, nil
}
func (r *usergroupsDisableCallResponse) MarshalJSON() ([]byte, error) {
	var p usergroupsDisableCallResponseProxy
	p.OK = r.ok
	p.ReplyTo = r.replyTo
	p.Error = r.error
	p.Timestamp = r.ts
	payload1, err := json.Marshal(r.usergroup)
	if err != nil {
		return nil, errors.Wrap(err, `failed to marshal 'usergroup' field`)
	}
	p.Payload1 = payload1
	return json.Marshal(p)
}

// Do executes the call to access usergroups.disable endpoint
func (c *UsergroupsDisableCall) Do(ctx context.Context) (*objects.Usergroup, error) {
	const endpoint = "usergroups.disable"
	v, err := c.Values()
	if err != nil {
		return nil, err
	}
	var res usergroupsDisableCallResponseProxy
	if err := c.service.client.postForm(ctx, endpoint, v, &res); err != nil {
		return nil, errors.Wrap(err, `failed to post to usergroups.disable`)
	}
	if !res.OK {
		var err error
		if errresp := res.Error; errresp != nil {
			err = errors.New(errresp.String())
		} else {
			err = errors.New(`unknown error while posting to usergroups.disable`)
		}
		return nil, err
	}

	return res.payload()
}

// FromValues parses the data in v and populates `c`
func (c *UsergroupsDisableCall) FromValues(v url.Values) error {
	var tmp UsergroupsDisableCall
	if raw := strings.TrimSpace(v.Get("include_count")); len(raw) > 0 {
		parsed, err := strconv.ParseBool(raw)
		if err != nil {
			return errors.Wrap(err, `failed to parse boolean value "include_count"`)
		}
		tmp.includeCount = parsed
	}
	if raw := strings.TrimSpace(v.Get("usergroup")); len(raw) > 0 {
		tmp.usergroup = raw
	}
	*c = tmp
	return nil
}

// Enable creates a UsergroupsEnableCall object in preparation for accessing the usergroups.enable endpoint
func (s *UsergroupsService) Enable(usergroup string) *UsergroupsEnableCall {
	var call UsergroupsEnableCall
	call.service = s
	call.usergroup = usergroup
	return &call
}

// IncludeCount sets the value for optional includeCount parameter
func (c *UsergroupsEnableCall) IncludeCount(includeCount bool) *UsergroupsEnableCall {
	c.includeCount = includeCount
	return c
}

// ValidateArgs checks that all required fields are set in the UsergroupsEnableCall object
func (c *UsergroupsEnableCall) ValidateArgs() error {
	if len(c.usergroup) <= 0 {
		return errors.New(`required field usergroup not initialized`)
	}
	return nil
}

// Values returns the UsergroupsEnableCall object as url.Values
func (c *UsergroupsEnableCall) Values() (url.Values, error) {
	if err := c.ValidateArgs(); err != nil {
		return nil, errors.Wrap(err, `failed validation`)
	}
	v := url.Values{}
	v.Set(`token`, c.service.token)

	if c.includeCount {
		v.Set("include_count", "true")
	}

	v.Set("usergroup", c.usergroup)
	return v, nil
}

type UsergroupsEnableCallResponse interface {
	OK() bool
	ReplyTo() int
	Error() *objects.ErrorResponse
	Timestamp() string
	Usergroup() *objects.Usergroup
}

type usergroupsEnableCallResponseProxy struct {
	OK        bool                   `json:"ok"`
	ReplyTo   int                    `json:"reply_to"`
	Error     *objects.ErrorResponse `json:"error"`
	Timestamp string                 `json:"ts"`
	Payload0  json.RawMessage        `json:"-"`
	Payload1  json.RawMessage        `json:"usergroup"`
}
type usergroupsEnableCallResponse struct {
	ok        bool
	replyTo   int
	error     *objects.ErrorResponse
	ts        string
	usergroup *objects.Usergroup
}
type UsergroupsEnableCallResponseBuilder struct {
	resp *usergroupsEnableCallResponse
}

func BuildUsergroupsEnableCallResponse() *UsergroupsEnableCallResponseBuilder {
	return &UsergroupsEnableCallResponseBuilder{resp: &usergroupsEnableCallResponse{}}
}
func (v *usergroupsEnableCallResponse) OK() bool {
	return v.ok
}
func (v *usergroupsEnableCallResponse) ReplyTo() int {
	return v.replyTo
}
func (v *usergroupsEnableCallResponse) Error() *objects.ErrorResponse {
	return v.error
}
func (v *usergroupsEnableCallResponse) Timestamp() string {
	return v.ts
}
func (v *usergroupsEnableCallResponse) Usergroup() *objects.Usergroup {
	return v.usergroup
}
func (b *UsergroupsEnableCallResponseBuilder) OK(v bool) *UsergroupsEnableCallResponseBuilder {
	b.resp.ok = v
	return b
}
func (b *UsergroupsEnableCallResponseBuilder) ReplyTo(v int) *UsergroupsEnableCallResponseBuilder {
	b.resp.replyTo = v
	return b
}
func (b *UsergroupsEnableCallResponseBuilder) Error(v *objects.ErrorResponse) *UsergroupsEnableCallResponseBuilder {
	b.resp.error = v
	return b
}
func (b *UsergroupsEnableCallResponseBuilder) Timestamp(v string) *UsergroupsEnableCallResponseBuilder {
	b.resp.ts = v
	return b
}
func (b *UsergroupsEnableCallResponseBuilder) Usergroup(v *objects.Usergroup) *UsergroupsEnableCallResponseBuilder {
	b.resp.usergroup = v
	return b
}
func (b *UsergroupsEnableCallResponseBuilder) Build() UsergroupsEnableCallResponse {
	v := b.resp
	b.resp = &usergroupsEnableCallResponse{}
	return v
}
func (r *usergroupsEnableCallResponseProxy) parse(data []byte) error {
	if err := json.Unmarshal(data, r); err != nil {
		return errors.Wrap(err, `failed to unmarshal UsergroupsEnableCallResponse`)
	}
	r.Payload0 = data
	return nil
}
func (r *usergroupsEnableCallResponseProxy) payload() (*objects.Usergroup, error) {
	var res1 objects.Usergroup
	if err := json.Unmarshal(r.Payload1, &res1); err != nil {
		return nil, errors.Wrap(err, `failed to ummarshal objects.Usergroup from response`)
	}
	return &res1, nil
}
func (r *usergroupsEnableCallResponse) MarshalJSON() ([]byte, error) {
	var p usergroupsEnableCallResponseProxy
	p.OK = r.ok
	p.ReplyTo = r.replyTo
	p.Error = r.error
	p.Timestamp = r.ts
	payload1, err := json.Marshal(r.usergroup)
	if err != nil {
		return nil, errors.Wrap(err, `failed to marshal 'usergroup' field`)
	}
	p.Payload1 = payload1
	return json.Marshal(p)
}

// Do executes the call to access usergroups.enable endpoint
func (c *UsergroupsEnableCall) Do(ctx context.Context) (*objects.Usergroup, error) {
	const endpoint = "usergroups.enable"
	v, err := c.Values()
	if err != nil {
		return nil, err
	}
	var res usergroupsEnableCallResponseProxy
	if err := c.service.client.postForm(ctx, endpoint, v, &res); err != nil {
		return nil, errors.Wrap(err, `failed to post to usergroups.enable`)
	}
	if !res.OK {
		var err error
		if errresp := res.Error; errresp != nil {
			err = errors.New(errresp.String())
		} else {
			err = errors.New(`unknown error while posting to usergroups.enable`)
		}
		return nil, err
	}

	return res.payload()
}

// FromValues parses the data in v and populates `c`
func (c *UsergroupsEnableCall) FromValues(v url.Values) error {
	var tmp UsergroupsEnableCall
	if raw := strings.TrimSpace(v.Get("include_count")); len(raw) > 0 {
		parsed, err := strconv.ParseBool(raw)
		if err != nil {
			return errors.Wrap(err, `failed to parse boolean value "include_count"`)
		}
		tmp.includeCount = parsed
	}
	if raw := strings.TrimSpace(v.Get("usergroup")); len(raw) > 0 {
		tmp.usergroup = raw
	}
	*c = tmp
	return nil
}

// List creates a UsergroupsListCall object in preparation for accessing the usergroups.list endpoint
func (s *UsergroupsService) List() *UsergroupsListCall {
	var call UsergroupsListCall
	call.service = s
	return &call
}

// IncludeCount sets the value for optional includeCount parameter
func (c *UsergroupsListCall) IncludeCount(includeCount bool) *UsergroupsListCall {
	c.includeCount = includeCount
	return c
}

// IncludeDisabled sets the value for optional includeDisabled parameter
func (c *UsergroupsListCall) IncludeDisabled(includeDisabled bool) *UsergroupsListCall {
	c.includeDisabled = includeDisabled
	return c
}

// IncludeUsers sets the value for optional includeUsers parameter
func (c *UsergroupsListCall) IncludeUsers(includeUsers bool) *UsergroupsListCall {
	c.includeUsers = includeUsers
	return c
}

// ValidateArgs checks that all required fields are set in the UsergroupsListCall object
func (c *UsergroupsListCall) ValidateArgs() error {
	return nil
}

// Values returns the UsergroupsListCall object as url.Values
func (c *UsergroupsListCall) Values() (url.Values, error) {
	if err := c.ValidateArgs(); err != nil {
		return nil, errors.Wrap(err, `failed validation`)
	}
	v := url.Values{}
	v.Set(`token`, c.service.token)

	if c.includeCount {
		v.Set("include_count", "true")
	}

	if c.includeDisabled {
		v.Set("include_disabled", "true")
	}

	if c.includeUsers {
		v.Set("include_users", "true")
	}
	return v, nil
}

type UsergroupsListCallResponse interface {
	OK() bool
	ReplyTo() int
	Error() *objects.ErrorResponse
	Timestamp() string
	Usergroups() *objects.UsergroupList
}

type usergroupsListCallResponseProxy struct {
	OK        bool                   `json:"ok"`
	ReplyTo   int                    `json:"reply_to"`
	Error     *objects.ErrorResponse `json:"error"`
	Timestamp string                 `json:"ts"`
	Payload0  json.RawMessage        `json:"-"`
	Payload1  json.RawMessage        `json:"usergroups"`
}
type usergroupsListCallResponse struct {
	ok         bool
	replyTo    int
	error      *objects.ErrorResponse
	ts         string
	usergroups *objects.UsergroupList
}
type UsergroupsListCallResponseBuilder struct {
	resp *usergroupsListCallResponse
}

func BuildUsergroupsListCallResponse() *UsergroupsListCallResponseBuilder {
	return &UsergroupsListCallResponseBuilder{resp: &usergroupsListCallResponse{}}
}
func (v *usergroupsListCallResponse) OK() bool {
	return v.ok
}
func (v *usergroupsListCallResponse) ReplyTo() int {
	return v.replyTo
}
func (v *usergroupsListCallResponse) Error() *objects.ErrorResponse {
	return v.error
}
func (v *usergroupsListCallResponse) Timestamp() string {
	return v.ts
}
func (v *usergroupsListCallResponse) Usergroups() *objects.UsergroupList {
	return v.usergroups
}
func (b *UsergroupsListCallResponseBuilder) OK(v bool) *UsergroupsListCallResponseBuilder {
	b.resp.ok = v
	return b
}
func (b *UsergroupsListCallResponseBuilder) ReplyTo(v int) *UsergroupsListCallResponseBuilder {
	b.resp.replyTo = v
	return b
}
func (b *UsergroupsListCallResponseBuilder) Error(v *objects.ErrorResponse) *UsergroupsListCallResponseBuilder {
	b.resp.error = v
	return b
}
func (b *UsergroupsListCallResponseBuilder) Timestamp(v string) *UsergroupsListCallResponseBuilder {
	b.resp.ts = v
	return b
}
func (b *UsergroupsListCallResponseBuilder) Usergroups(v *objects.UsergroupList) *UsergroupsListCallResponseBuilder {
	b.resp.usergroups = v
	return b
}
func (b *UsergroupsListCallResponseBuilder) Build() UsergroupsListCallResponse {
	v := b.resp
	b.resp = &usergroupsListCallResponse{}
	return v
}
func (r *usergroupsListCallResponseProxy) parse(data []byte) error {
	if err := json.Unmarshal(data, r); err != nil {
		return errors.Wrap(err, `failed to unmarshal UsergroupsListCallResponse`)
	}
	r.Payload0 = data
	return nil
}
func (r *usergroupsListCallResponseProxy) payload() (objects.UsergroupList, error) {
	var res1 objects.UsergroupList
	if err := json.Unmarshal(r.Payload1, &res1); err != nil {
		return nil, errors.Wrap(err, `failed to ummarshal objects.UsergroupList from response`)
	}
	return res1, nil
}
func (r *usergroupsListCallResponse) MarshalJSON() ([]byte, error) {
	var p usergroupsListCallResponseProxy
	p.OK = r.ok
	p.ReplyTo = r.replyTo
	p.Error = r.error
	p.Timestamp = r.ts
	payload1, err := json.Marshal(r.usergroups)
	if err != nil {
		return nil, errors.Wrap(err, `failed to marshal 'usergroups' field`)
	}
	p.Payload1 = payload1
	return json.Marshal(p)
}

// Do executes the call to access usergroups.list endpoint
func (c *UsergroupsListCall) Do(ctx context.Context) (objects.UsergroupList, error) {
	const endpoint = "usergroups.list"
	v, err := c.Values()
	if err != nil {
		return nil, err
	}
	var res usergroupsListCallResponseProxy
	if err := c.service.client.postForm(ctx, endpoint, v, &res); err != nil {
		return nil, errors.Wrap(err, `failed to post to usergroups.list`)
	}
	if !res.OK {
		var err error
		if errresp := res.Error; errresp != nil {
			err = errors.New(errresp.String())
		} else {
			err = errors.New(`unknown error while posting to usergroups.list`)
		}
		return nil, err
	}

	return res.payload()
}

// FromValues parses the data in v and populates `c`
func (c *UsergroupsListCall) FromValues(v url.Values) error {
	var tmp UsergroupsListCall
	if raw := strings.TrimSpace(v.Get("include_count")); len(raw) > 0 {
		parsed, err := strconv.ParseBool(raw)
		if err != nil {
			return errors.Wrap(err, `failed to parse boolean value "include_count"`)
		}
		tmp.includeCount = parsed
	}
	if raw := strings.TrimSpace(v.Get("include_disabled")); len(raw) > 0 {
		parsed, err := strconv.ParseBool(raw)
		if err != nil {
			return errors.Wrap(err, `failed to parse boolean value "include_disabled"`)
		}
		tmp.includeDisabled = parsed
	}
	if raw := strings.TrimSpace(v.Get("include_users")); len(raw) > 0 {
		parsed, err := strconv.ParseBool(raw)
		if err != nil {
			return errors.Wrap(err, `failed to parse boolean value "include_users"`)
		}
		tmp.includeUsers = parsed
	}
	*c = tmp
	return nil
}

// Update creates a UsergroupsUpdateCall object in preparation for accessing the usergroups.update endpoint
func (s *UsergroupsService) Update(usergroup string) *UsergroupsUpdateCall {
	var call UsergroupsUpdateCall
	call.service = s
	call.usergroup = usergroup
	return &call
}

// Channels sets the value for optional channels parameter
func (c *UsergroupsUpdateCall) Channels(channels string) *UsergroupsUpdateCall {
	c.channels = channels
	return c
}

// Description sets the value for optional description parameter
func (c *UsergroupsUpdateCall) Description(description string) *UsergroupsUpdateCall {
	c.description = description
	return c
}

// Handle sets the value for optional handle parameter
func (c *UsergroupsUpdateCall) Handle(handle string) *UsergroupsUpdateCall {
	c.handle = handle
	return c
}

// IncludeCount sets the value for optional includeCount parameter
func (c *UsergroupsUpdateCall) IncludeCount(includeCount bool) *UsergroupsUpdateCall {
	c.includeCount = includeCount
	return c
}

// Name sets the value for optional name parameter
func (c *UsergroupsUpdateCall) Name(name string) *UsergroupsUpdateCall {
	c.name = name
	return c
}

// ValidateArgs checks that all required fields are set in the UsergroupsUpdateCall object
func (c *UsergroupsUpdateCall) ValidateArgs() error {
	if len(c.usergroup) <= 0 {
		return errors.New(`required field usergroup not initialized`)
	}
	return nil
}

// Values returns the UsergroupsUpdateCall object as url.Values
func (c *UsergroupsUpdateCall) Values() (url.Values, error) {
	if err := c.ValidateArgs(); err != nil {
		return nil, errors.Wrap(err, `failed validation`)
	}
	v := url.Values{}
	v.Set(`token`, c.service.token)

	if len(c.channels) > 0 {
		v.Set("channels", c.channels)
	}

	if len(c.description) > 0 {
		v.Set("description", c.description)
	}

	if len(c.handle) > 0 {
		v.Set("handle", c.handle)
	}

	if c.includeCount {
		v.Set("include_count", "true")
	}

	if len(c.name) > 0 {
		v.Set("name", c.name)
	}

	v.Set("usergroup", c.usergroup)
	return v, nil
}

type UsergroupsUpdateCallResponse interface {
	OK() bool
	ReplyTo() int
	Error() *objects.ErrorResponse
	Timestamp() string
	Usergroup() *objects.Usergroup
}

type usergroupsUpdateCallResponseProxy struct {
	OK        bool                   `json:"ok"`
	ReplyTo   int                    `json:"reply_to"`
	Error     *objects.ErrorResponse `json:"error"`
	Timestamp string                 `json:"ts"`
	Payload0  json.RawMessage        `json:"-"`
	Payload1  json.RawMessage        `json:"usergroup"`
}
type usergroupsUpdateCallResponse struct {
	ok        bool
	replyTo   int
	error     *objects.ErrorResponse
	ts        string
	usergroup *objects.Usergroup
}
type UsergroupsUpdateCallResponseBuilder struct {
	resp *usergroupsUpdateCallResponse
}

func BuildUsergroupsUpdateCallResponse() *UsergroupsUpdateCallResponseBuilder {
	return &UsergroupsUpdateCallResponseBuilder{resp: &usergroupsUpdateCallResponse{}}
}
func (v *usergroupsUpdateCallResponse) OK() bool {
	return v.ok
}
func (v *usergroupsUpdateCallResponse) ReplyTo() int {
	return v.replyTo
}
func (v *usergroupsUpdateCallResponse) Error() *objects.ErrorResponse {
	return v.error
}
func (v *usergroupsUpdateCallResponse) Timestamp() string {
	return v.ts
}
func (v *usergroupsUpdateCallResponse) Usergroup() *objects.Usergroup {
	return v.usergroup
}
func (b *UsergroupsUpdateCallResponseBuilder) OK(v bool) *UsergroupsUpdateCallResponseBuilder {
	b.resp.ok = v
	return b
}
func (b *UsergroupsUpdateCallResponseBuilder) ReplyTo(v int) *UsergroupsUpdateCallResponseBuilder {
	b.resp.replyTo = v
	return b
}
func (b *UsergroupsUpdateCallResponseBuilder) Error(v *objects.ErrorResponse) *UsergroupsUpdateCallResponseBuilder {
	b.resp.error = v
	return b
}
func (b *UsergroupsUpdateCallResponseBuilder) Timestamp(v string) *UsergroupsUpdateCallResponseBuilder {
	b.resp.ts = v
	return b
}
func (b *UsergroupsUpdateCallResponseBuilder) Usergroup(v *objects.Usergroup) *UsergroupsUpdateCallResponseBuilder {
	b.resp.usergroup = v
	return b
}
func (b *UsergroupsUpdateCallResponseBuilder) Build() UsergroupsUpdateCallResponse {
	v := b.resp
	b.resp = &usergroupsUpdateCallResponse{}
	return v
}
func (r *usergroupsUpdateCallResponseProxy) parse(data []byte) error {
	if err := json.Unmarshal(data, r); err != nil {
		return errors.Wrap(err, `failed to unmarshal UsergroupsUpdateCallResponse`)
	}
	r.Payload0 = data
	return nil
}
func (r *usergroupsUpdateCallResponseProxy) payload() (*objects.Usergroup, error) {
	var res1 objects.Usergroup
	if err := json.Unmarshal(r.Payload1, &res1); err != nil {
		return nil, errors.Wrap(err, `failed to ummarshal objects.Usergroup from response`)
	}
	return &res1, nil
}
func (r *usergroupsUpdateCallResponse) MarshalJSON() ([]byte, error) {
	var p usergroupsUpdateCallResponseProxy
	p.OK = r.ok
	p.ReplyTo = r.replyTo
	p.Error = r.error
	p.Timestamp = r.ts
	payload1, err := json.Marshal(r.usergroup)
	if err != nil {
		return nil, errors.Wrap(err, `failed to marshal 'usergroup' field`)
	}
	p.Payload1 = payload1
	return json.Marshal(p)
}

// Do executes the call to access usergroups.update endpoint
func (c *UsergroupsUpdateCall) Do(ctx context.Context) (*objects.Usergroup, error) {
	const endpoint = "usergroups.update"
	v, err := c.Values()
	if err != nil {
		return nil, err
	}
	var res usergroupsUpdateCallResponseProxy
	if err := c.service.client.postForm(ctx, endpoint, v, &res); err != nil {
		return nil, errors.Wrap(err, `failed to post to usergroups.update`)
	}
	if !res.OK {
		var err error
		if errresp := res.Error; errresp != nil {
			err = errors.New(errresp.String())
		} else {
			err = errors.New(`unknown error while posting to usergroups.update`)
		}
		return nil, err
	}

	return res.payload()
}

// FromValues parses the data in v and populates `c`
func (c *UsergroupsUpdateCall) FromValues(v url.Values) error {
	var tmp UsergroupsUpdateCall
	if raw := strings.TrimSpace(v.Get("channels")); len(raw) > 0 {
		tmp.channels = raw
	}
	if raw := strings.TrimSpace(v.Get("description")); len(raw) > 0 {
		tmp.description = raw
	}
	if raw := strings.TrimSpace(v.Get("handle")); len(raw) > 0 {
		tmp.handle = raw
	}
	if raw := strings.TrimSpace(v.Get("include_count")); len(raw) > 0 {
		parsed, err := strconv.ParseBool(raw)
		if err != nil {
			return errors.Wrap(err, `failed to parse boolean value "include_count"`)
		}
		tmp.includeCount = parsed
	}
	if raw := strings.TrimSpace(v.Get("name")); len(raw) > 0 {
		tmp.name = raw
	}
	if raw := strings.TrimSpace(v.Get("usergroup")); len(raw) > 0 {
		tmp.usergroup = raw
	}
	*c = tmp
	return nil
}
