package slack

// Auto-generated by internal/cmd/genmethods/genmethods.go (generateServiceDetailsFile). DO NOT EDIT!

import (
	"context"
	"encoding/json"
	"net/url"
	"strconv"
	"strings"

	"github.com/lestrrat-go/slack/objects"
	"github.com/pkg/errors"
)

var _ = strconv.Itoa
var _ = strings.Index
var _ = json.Marshal
var _ = objects.EpochTime(0)

// ChannelsArchiveCall is created by ChannelsService.Archive method call
type ChannelsArchiveCall struct {
	service *ChannelsService
	channel string
}

// ChannelsCreateCall is created by ChannelsService.Create method call
type ChannelsCreateCall struct {
	service  *ChannelsService
	name     string
	validate bool
}

// ChannelsHistoryCall is created by ChannelsService.History method call
type ChannelsHistoryCall struct {
	service   *ChannelsService
	channel   string
	count     int // 1 - 1000
	inclusive bool
	latest    string // Range of time (end)
	oldest    string // Range of time (start)
	timestamp string // Used only when retrieving a single message
	unreads   bool   // Include unread_count_display in the output
}

// ChannelsInfoCall is created by ChannelsService.Info method call
type ChannelsInfoCall struct {
	service       *ChannelsService
	channel       string
	includeLocale bool
}

// ChannelsInviteCall is created by ChannelsService.Invite method call
type ChannelsInviteCall struct {
	service *ChannelsService
	channel string
	user    string
}

// ChannelsJoinCall is created by ChannelsService.Join method call
type ChannelsJoinCall struct {
	service  *ChannelsService
	name     string
	validate bool
}

// ChannelsKickCall is created by ChannelsService.Kick method call
type ChannelsKickCall struct {
	service *ChannelsService
	channel string
	user    string
}

// ChannelsLeaveCall is created by ChannelsService.Leave method call
type ChannelsLeaveCall struct {
	service *ChannelsService
	channel string
}

// ChannelsListCall is created by ChannelsService.List method call
type ChannelsListCall struct {
	service        *ChannelsService
	excludeArchive bool // Exclude archived channels
	excludeMembers bool // Exclude the list of members in channels
	limit          int
}

// ChannelsMarkCall is created by ChannelsService.Mark method call
type ChannelsMarkCall struct {
	service   *ChannelsService
	channel   string
	timestamp string
}

// ChannelsRenameCall is created by ChannelsService.Rename method call
type ChannelsRenameCall struct {
	service  *ChannelsService
	channel  string
	name     string
	validate bool
}

// ChannelsRepliesCall is created by ChannelsService.Replies method call
type ChannelsRepliesCall struct {
	service         *ChannelsService
	channel         string
	threadTimestamp string
}

// ChannelsSetPurposeCall is created by ChannelsService.SetPurpose method call
type ChannelsSetPurposeCall struct {
	service *ChannelsService
	channel string
	purpose string
}

// ChannelsSetTopicCall is created by ChannelsService.SetTopic method call
type ChannelsSetTopicCall struct {
	service *ChannelsService
	channel string
	topic   string
}

// ChannelsUnarchiveCall is created by ChannelsService.Unarchive method call
type ChannelsUnarchiveCall struct {
	service *ChannelsService
	channel string
}

// Archive creates a ChannelsArchiveCall object in preparation for accessing the channels.archive endpoint
func (s *ChannelsService) Archive(channel string) *ChannelsArchiveCall {
	var call ChannelsArchiveCall
	call.service = s
	call.channel = channel
	return &call
}

// ValidateArgs checks that all required fields are set in the ChannelsArchiveCall object
func (c *ChannelsArchiveCall) ValidateArgs() error {
	if len(c.channel) <= 0 {
		return errors.New(`required field channel not initialized`)
	}
	return nil
}

// Values returns the ChannelsArchiveCall object as url.Values
func (c *ChannelsArchiveCall) Values() (url.Values, error) {
	if err := c.ValidateArgs(); err != nil {
		return nil, errors.Wrap(err, `failed validation`)
	}
	v := url.Values{}
	v.Set(`token`, c.service.token)

	v.Set("channel", c.channel)
	return v, nil
}

type ChannelsArchiveCallResponse interface {
	OK() bool
	ReplyTo() int
	Error() *objects.ErrorResponse
	Timestamp() string
}

type channelsArchiveCallResponseProxy struct {
	OK        bool                   `json:"ok"`
	ReplyTo   int                    `json:"reply_to"`
	Error     *objects.ErrorResponse `json:"error"`
	Timestamp string                 `json:"ts"`
	Payload0  json.RawMessage        `json:"-"`
}
type channelsArchiveCallResponse struct {
	ok      bool
	replyTo int
	error   *objects.ErrorResponse
	ts      string
}
type ChannelsArchiveCallResponseBuilder struct {
	resp *channelsArchiveCallResponse
}

func BuildChannelsArchiveCallResponse() *ChannelsArchiveCallResponseBuilder {
	return &ChannelsArchiveCallResponseBuilder{resp: &channelsArchiveCallResponse{}}
}
func (v *channelsArchiveCallResponse) OK() bool {
	return v.ok
}
func (v *channelsArchiveCallResponse) ReplyTo() int {
	return v.replyTo
}
func (v *channelsArchiveCallResponse) Error() *objects.ErrorResponse {
	return v.error
}
func (v *channelsArchiveCallResponse) Timestamp() string {
	return v.ts
}
func (b *ChannelsArchiveCallResponseBuilder) OK(v bool) *ChannelsArchiveCallResponseBuilder {
	b.resp.ok = v
	return b
}
func (b *ChannelsArchiveCallResponseBuilder) ReplyTo(v int) *ChannelsArchiveCallResponseBuilder {
	b.resp.replyTo = v
	return b
}
func (b *ChannelsArchiveCallResponseBuilder) Error(v *objects.ErrorResponse) *ChannelsArchiveCallResponseBuilder {
	b.resp.error = v
	return b
}
func (b *ChannelsArchiveCallResponseBuilder) Timestamp(v string) *ChannelsArchiveCallResponseBuilder {
	b.resp.ts = v
	return b
}
func (b *ChannelsArchiveCallResponseBuilder) Build() ChannelsArchiveCallResponse {
	v := b.resp
	b.resp = &channelsArchiveCallResponse{}
	return v
}
func (r *channelsArchiveCallResponseProxy) parse(data []byte) error {
	if err := json.Unmarshal(data, r); err != nil {
		return errors.Wrap(err, `failed to unmarshal ChannelsArchiveCallResponse`)
	}
	r.Payload0 = data
	return nil
}

// Do executes the call to access channels.archive endpoint
func (c *ChannelsArchiveCall) Do(ctx context.Context) error {
	const endpoint = "channels.archive"
	v, err := c.Values()
	if err != nil {
		return err
	}
	var res channelsArchiveCallResponseProxy
	if err := c.service.client.postForm(ctx, endpoint, v, &res); err != nil {
		return errors.Wrap(err, `failed to post to channels.archive`)
	}
	if !res.OK {
		var err error
		if errresp := res.Error; errresp != nil {
			err = errors.New(errresp.String())
		} else {
			err = errors.New(`unknown error while posting to channels.archive`)
		}
		return err
	}

	return nil
}

// FromValues parses the data in v and populates `c`
func (c *ChannelsArchiveCall) FromValues(v url.Values) error {
	var tmp ChannelsArchiveCall
	if raw := strings.TrimSpace(v.Get("channel")); len(raw) > 0 {
		tmp.channel = raw
	}
	*c = tmp
	return nil
}

// Create creates a ChannelsCreateCall object in preparation for accessing the channels.create endpoint
func (s *ChannelsService) Create(name string) *ChannelsCreateCall {
	var call ChannelsCreateCall
	call.service = s
	call.name = name
	return &call
}

// Validate sets the value for optional validate parameter
func (c *ChannelsCreateCall) Validate(validate bool) *ChannelsCreateCall {
	c.validate = validate
	return c
}

// ValidateArgs checks that all required fields are set in the ChannelsCreateCall object
func (c *ChannelsCreateCall) ValidateArgs() error {
	if len(c.name) <= 0 {
		return errors.New(`required field name not initialized`)
	}
	return nil
}

// Values returns the ChannelsCreateCall object as url.Values
func (c *ChannelsCreateCall) Values() (url.Values, error) {
	if err := c.ValidateArgs(); err != nil {
		return nil, errors.Wrap(err, `failed validation`)
	}
	v := url.Values{}
	v.Set(`token`, c.service.token)

	v.Set("name", c.name)

	if c.validate {
		v.Set("validate", "true")
	}
	return v, nil
}

type ChannelsCreateCallResponse interface {
	OK() bool
	ReplyTo() int
	Error() *objects.ErrorResponse
	Timestamp() string
}

type channelsCreateCallResponseProxy struct {
	OK        bool                   `json:"ok"`
	ReplyTo   int                    `json:"reply_to"`
	Error     *objects.ErrorResponse `json:"error"`
	Timestamp string                 `json:"ts"`
	Payload0  json.RawMessage        `json:"-"`
}
type channelsCreateCallResponse struct {
	ok      bool
	replyTo int
	error   *objects.ErrorResponse
	ts      string
}
type ChannelsCreateCallResponseBuilder struct {
	resp *channelsCreateCallResponse
}

func BuildChannelsCreateCallResponse() *ChannelsCreateCallResponseBuilder {
	return &ChannelsCreateCallResponseBuilder{resp: &channelsCreateCallResponse{}}
}
func (v *channelsCreateCallResponse) OK() bool {
	return v.ok
}
func (v *channelsCreateCallResponse) ReplyTo() int {
	return v.replyTo
}
func (v *channelsCreateCallResponse) Error() *objects.ErrorResponse {
	return v.error
}
func (v *channelsCreateCallResponse) Timestamp() string {
	return v.ts
}
func (b *ChannelsCreateCallResponseBuilder) OK(v bool) *ChannelsCreateCallResponseBuilder {
	b.resp.ok = v
	return b
}
func (b *ChannelsCreateCallResponseBuilder) ReplyTo(v int) *ChannelsCreateCallResponseBuilder {
	b.resp.replyTo = v
	return b
}
func (b *ChannelsCreateCallResponseBuilder) Error(v *objects.ErrorResponse) *ChannelsCreateCallResponseBuilder {
	b.resp.error = v
	return b
}
func (b *ChannelsCreateCallResponseBuilder) Timestamp(v string) *ChannelsCreateCallResponseBuilder {
	b.resp.ts = v
	return b
}
func (b *ChannelsCreateCallResponseBuilder) Build() ChannelsCreateCallResponse {
	v := b.resp
	b.resp = &channelsCreateCallResponse{}
	return v
}
func (r *channelsCreateCallResponseProxy) parse(data []byte) error {
	if err := json.Unmarshal(data, r); err != nil {
		return errors.Wrap(err, `failed to unmarshal ChannelsCreateCallResponse`)
	}
	r.Payload0 = data
	return nil
}

// Do executes the call to access channels.create endpoint
func (c *ChannelsCreateCall) Do(ctx context.Context) error {
	const endpoint = "channels.create"
	v, err := c.Values()
	if err != nil {
		return err
	}
	var res channelsCreateCallResponseProxy
	if err := c.service.client.postForm(ctx, endpoint, v, &res); err != nil {
		return errors.Wrap(err, `failed to post to channels.create`)
	}
	if !res.OK {
		var err error
		if errresp := res.Error; errresp != nil {
			err = errors.New(errresp.String())
		} else {
			err = errors.New(`unknown error while posting to channels.create`)
		}
		return err
	}

	return nil
}

// FromValues parses the data in v and populates `c`
func (c *ChannelsCreateCall) FromValues(v url.Values) error {
	var tmp ChannelsCreateCall
	if raw := strings.TrimSpace(v.Get("name")); len(raw) > 0 {
		tmp.name = raw
	}
	if raw := strings.TrimSpace(v.Get("validate")); len(raw) > 0 {
		parsed, err := strconv.ParseBool(raw)
		if err != nil {
			return errors.Wrap(err, `failed to parse boolean value "validate"`)
		}
		tmp.validate = parsed
	}
	*c = tmp
	return nil
}

// History creates a ChannelsHistoryCall object in preparation for accessing the channels.history endpoint
func (s *ChannelsService) History(channel string) *ChannelsHistoryCall {
	var call ChannelsHistoryCall
	call.service = s
	call.channel = channel
	return &call
}

// Count sets the value for optional count parameter
func (c *ChannelsHistoryCall) Count(count int) *ChannelsHistoryCall {
	c.count = count
	return c
}

// Inclusive sets the value for optional inclusive parameter
func (c *ChannelsHistoryCall) Inclusive(inclusive bool) *ChannelsHistoryCall {
	c.inclusive = inclusive
	return c
}

// Latest sets the value for optional latest parameter
func (c *ChannelsHistoryCall) Latest(latest string) *ChannelsHistoryCall {
	c.latest = latest
	return c
}

// Oldest sets the value for optional oldest parameter
func (c *ChannelsHistoryCall) Oldest(oldest string) *ChannelsHistoryCall {
	c.oldest = oldest
	return c
}

// Timestamp sets the value for optional timestamp parameter
func (c *ChannelsHistoryCall) Timestamp(timestamp string) *ChannelsHistoryCall {
	c.timestamp = timestamp
	return c
}

// Unreads sets the value for optional unreads parameter
func (c *ChannelsHistoryCall) Unreads(unreads bool) *ChannelsHistoryCall {
	c.unreads = unreads
	return c
}

// ValidateArgs checks that all required fields are set in the ChannelsHistoryCall object
func (c *ChannelsHistoryCall) ValidateArgs() error {
	if len(c.channel) <= 0 {
		return errors.New(`required field channel not initialized`)
	}
	return nil
}

// Values returns the ChannelsHistoryCall object as url.Values
func (c *ChannelsHistoryCall) Values() (url.Values, error) {
	if err := c.ValidateArgs(); err != nil {
		return nil, errors.Wrap(err, `failed validation`)
	}
	v := url.Values{}
	v.Set(`token`, c.service.token)

	v.Set("channel", c.channel)

	if c.count > 0 {
		v.Set("count", strconv.Itoa(c.count))
	}

	if c.inclusive {
		v.Set("inclusive", "true")
	}

	if len(c.latest) > 0 {
		v.Set("latest", c.latest)
	}

	if len(c.oldest) > 0 {
		v.Set("oldest", c.oldest)
	}

	if len(c.timestamp) > 0 {
		v.Set("ts", c.timestamp)
	}

	if c.unreads {
		v.Set("unreads", "true")
	}
	return v, nil
}

type ChannelsHistoryCallResponse interface {
	OK() bool
	ReplyTo() int
	Error() *objects.ErrorResponse
	Timestamp() string
}

type channelsHistoryCallResponseProxy struct {
	OK        bool                   `json:"ok"`
	ReplyTo   int                    `json:"reply_to"`
	Error     *objects.ErrorResponse `json:"error"`
	Timestamp string                 `json:"ts"`
	Payload0  json.RawMessage        `json:"-"`
}
type channelsHistoryCallResponse struct {
	ok      bool
	replyTo int
	error   *objects.ErrorResponse
	ts      string
}
type ChannelsHistoryCallResponseBuilder struct {
	resp *channelsHistoryCallResponse
}

func BuildChannelsHistoryCallResponse() *ChannelsHistoryCallResponseBuilder {
	return &ChannelsHistoryCallResponseBuilder{resp: &channelsHistoryCallResponse{}}
}
func (v *channelsHistoryCallResponse) OK() bool {
	return v.ok
}
func (v *channelsHistoryCallResponse) ReplyTo() int {
	return v.replyTo
}
func (v *channelsHistoryCallResponse) Error() *objects.ErrorResponse {
	return v.error
}
func (v *channelsHistoryCallResponse) Timestamp() string {
	return v.ts
}
func (b *ChannelsHistoryCallResponseBuilder) OK(v bool) *ChannelsHistoryCallResponseBuilder {
	b.resp.ok = v
	return b
}
func (b *ChannelsHistoryCallResponseBuilder) ReplyTo(v int) *ChannelsHistoryCallResponseBuilder {
	b.resp.replyTo = v
	return b
}
func (b *ChannelsHistoryCallResponseBuilder) Error(v *objects.ErrorResponse) *ChannelsHistoryCallResponseBuilder {
	b.resp.error = v
	return b
}
func (b *ChannelsHistoryCallResponseBuilder) Timestamp(v string) *ChannelsHistoryCallResponseBuilder {
	b.resp.ts = v
	return b
}
func (b *ChannelsHistoryCallResponseBuilder) Build() ChannelsHistoryCallResponse {
	v := b.resp
	b.resp = &channelsHistoryCallResponse{}
	return v
}
func (r *channelsHistoryCallResponseProxy) parse(data []byte) error {
	if err := json.Unmarshal(data, r); err != nil {
		return errors.Wrap(err, `failed to unmarshal ChannelsHistoryCallResponse`)
	}
	r.Payload0 = data
	return nil
}
func (r *channelsHistoryCallResponseProxy) payload() (*objects.ChannelsHistoryResponse, error) {
	var res0 objects.ChannelsHistoryResponse
	if err := json.Unmarshal(r.Payload0, &res0); err != nil {
		return nil, errors.Wrap(err, `failed to ummarshal objects.ChannelsHistoryResponse from response`)
	}
	return &res0, nil
}

// Do executes the call to access channels.history endpoint
func (c *ChannelsHistoryCall) Do(ctx context.Context) (*objects.ChannelsHistoryResponse, error) {
	const endpoint = "channels.history"
	v, err := c.Values()
	if err != nil {
		return nil, err
	}
	var res channelsHistoryCallResponseProxy
	if err := c.service.client.postForm(ctx, endpoint, v, &res); err != nil {
		return nil, errors.Wrap(err, `failed to post to channels.history`)
	}
	if !res.OK {
		var err error
		if errresp := res.Error; errresp != nil {
			err = errors.New(errresp.String())
		} else {
			err = errors.New(`unknown error while posting to channels.history`)
		}
		return nil, err
	}

	return res.payload()
}

// FromValues parses the data in v and populates `c`
func (c *ChannelsHistoryCall) FromValues(v url.Values) error {
	var tmp ChannelsHistoryCall
	if raw := strings.TrimSpace(v.Get("channel")); len(raw) > 0 {
		tmp.channel = raw
	}
	if raw := strings.TrimSpace(v.Get("count")); len(raw) > 0 {
		parsed, err := strconv.ParseInt(raw, 10, 64)
		if err != nil {
			return errors.Wrap(err, `failed to parse integer value "count"`)
		}
		tmp.count = int(parsed)
	}
	if raw := strings.TrimSpace(v.Get("inclusive")); len(raw) > 0 {
		parsed, err := strconv.ParseBool(raw)
		if err != nil {
			return errors.Wrap(err, `failed to parse boolean value "inclusive"`)
		}
		tmp.inclusive = parsed
	}
	if raw := strings.TrimSpace(v.Get("latest")); len(raw) > 0 {
		tmp.latest = raw
	}
	if raw := strings.TrimSpace(v.Get("oldest")); len(raw) > 0 {
		tmp.oldest = raw
	}
	if raw := strings.TrimSpace(v.Get("ts")); len(raw) > 0 {
		tmp.timestamp = raw
	}
	if raw := strings.TrimSpace(v.Get("unreads")); len(raw) > 0 {
		parsed, err := strconv.ParseBool(raw)
		if err != nil {
			return errors.Wrap(err, `failed to parse boolean value "unreads"`)
		}
		tmp.unreads = parsed
	}
	*c = tmp
	return nil
}

// Info creates a ChannelsInfoCall object in preparation for accessing the channels.info endpoint
func (s *ChannelsService) Info(channel string) *ChannelsInfoCall {
	var call ChannelsInfoCall
	call.service = s
	call.channel = channel
	return &call
}

// IncludeLocale sets the value for optional includeLocale parameter
func (c *ChannelsInfoCall) IncludeLocale(includeLocale bool) *ChannelsInfoCall {
	c.includeLocale = includeLocale
	return c
}

// ValidateArgs checks that all required fields are set in the ChannelsInfoCall object
func (c *ChannelsInfoCall) ValidateArgs() error {
	if len(c.channel) <= 0 {
		return errors.New(`required field channel not initialized`)
	}
	return nil
}

// Values returns the ChannelsInfoCall object as url.Values
func (c *ChannelsInfoCall) Values() (url.Values, error) {
	if err := c.ValidateArgs(); err != nil {
		return nil, errors.Wrap(err, `failed validation`)
	}
	v := url.Values{}
	v.Set(`token`, c.service.token)

	v.Set("channel", c.channel)

	if c.includeLocale {
		v.Set("include_locale", "true")
	}
	return v, nil
}

type ChannelsInfoCallResponse interface {
	OK() bool
	ReplyTo() int
	Error() *objects.ErrorResponse
	Timestamp() string
	Channel() *objects.Channel
}

type channelsInfoCallResponseProxy struct {
	OK        bool                   `json:"ok"`
	ReplyTo   int                    `json:"reply_to"`
	Error     *objects.ErrorResponse `json:"error"`
	Timestamp string                 `json:"ts"`
	Payload0  json.RawMessage        `json:"-"`
	Payload1  json.RawMessage        `json:"channel"`
}
type channelsInfoCallResponse struct {
	ok      bool
	replyTo int
	error   *objects.ErrorResponse
	ts      string
	channel *objects.Channel
}
type ChannelsInfoCallResponseBuilder struct {
	resp *channelsInfoCallResponse
}

func BuildChannelsInfoCallResponse() *ChannelsInfoCallResponseBuilder {
	return &ChannelsInfoCallResponseBuilder{resp: &channelsInfoCallResponse{}}
}
func (v *channelsInfoCallResponse) OK() bool {
	return v.ok
}
func (v *channelsInfoCallResponse) ReplyTo() int {
	return v.replyTo
}
func (v *channelsInfoCallResponse) Error() *objects.ErrorResponse {
	return v.error
}
func (v *channelsInfoCallResponse) Timestamp() string {
	return v.ts
}
func (v *channelsInfoCallResponse) Channel() *objects.Channel {
	return v.channel
}
func (b *ChannelsInfoCallResponseBuilder) OK(v bool) *ChannelsInfoCallResponseBuilder {
	b.resp.ok = v
	return b
}
func (b *ChannelsInfoCallResponseBuilder) ReplyTo(v int) *ChannelsInfoCallResponseBuilder {
	b.resp.replyTo = v
	return b
}
func (b *ChannelsInfoCallResponseBuilder) Error(v *objects.ErrorResponse) *ChannelsInfoCallResponseBuilder {
	b.resp.error = v
	return b
}
func (b *ChannelsInfoCallResponseBuilder) Timestamp(v string) *ChannelsInfoCallResponseBuilder {
	b.resp.ts = v
	return b
}
func (b *ChannelsInfoCallResponseBuilder) Channel(v *objects.Channel) *ChannelsInfoCallResponseBuilder {
	b.resp.channel = v
	return b
}
func (b *ChannelsInfoCallResponseBuilder) Build() ChannelsInfoCallResponse {
	v := b.resp
	b.resp = &channelsInfoCallResponse{}
	return v
}
func (r *channelsInfoCallResponseProxy) parse(data []byte) error {
	if err := json.Unmarshal(data, r); err != nil {
		return errors.Wrap(err, `failed to unmarshal ChannelsInfoCallResponse`)
	}
	r.Payload0 = data
	return nil
}
func (r *channelsInfoCallResponseProxy) payload() (*objects.Channel, error) {
	var res1 objects.Channel
	if err := json.Unmarshal(r.Payload1, &res1); err != nil {
		return nil, errors.Wrap(err, `failed to ummarshal objects.Channel from response`)
	}
	return &res1, nil
}

// Do executes the call to access channels.info endpoint
func (c *ChannelsInfoCall) Do(ctx context.Context) (*objects.Channel, error) {
	const endpoint = "channels.info"
	v, err := c.Values()
	if err != nil {
		return nil, err
	}
	var res channelsInfoCallResponseProxy
	if err := c.service.client.postForm(ctx, endpoint, v, &res); err != nil {
		return nil, errors.Wrap(err, `failed to post to channels.info`)
	}
	if !res.OK {
		var err error
		if errresp := res.Error; errresp != nil {
			err = errors.New(errresp.String())
		} else {
			err = errors.New(`unknown error while posting to channels.info`)
		}
		return nil, err
	}

	return res.payload()
}

// FromValues parses the data in v and populates `c`
func (c *ChannelsInfoCall) FromValues(v url.Values) error {
	var tmp ChannelsInfoCall
	if raw := strings.TrimSpace(v.Get("channel")); len(raw) > 0 {
		tmp.channel = raw
	}
	if raw := strings.TrimSpace(v.Get("include_locale")); len(raw) > 0 {
		parsed, err := strconv.ParseBool(raw)
		if err != nil {
			return errors.Wrap(err, `failed to parse boolean value "include_locale"`)
		}
		tmp.includeLocale = parsed
	}
	*c = tmp
	return nil
}

// Invite creates a ChannelsInviteCall object in preparation for accessing the channels.invite endpoint
func (s *ChannelsService) Invite(channel string, user string) *ChannelsInviteCall {
	var call ChannelsInviteCall
	call.service = s
	call.channel = channel
	call.user = user
	return &call
}

// ValidateArgs checks that all required fields are set in the ChannelsInviteCall object
func (c *ChannelsInviteCall) ValidateArgs() error {
	if len(c.channel) <= 0 {
		return errors.New(`required field channel not initialized`)
	}
	if len(c.user) <= 0 {
		return errors.New(`required field user not initialized`)
	}
	return nil
}

// Values returns the ChannelsInviteCall object as url.Values
func (c *ChannelsInviteCall) Values() (url.Values, error) {
	if err := c.ValidateArgs(); err != nil {
		return nil, errors.Wrap(err, `failed validation`)
	}
	v := url.Values{}
	v.Set(`token`, c.service.token)

	v.Set("channel", c.channel)

	v.Set("user", c.user)
	return v, nil
}

type ChannelsInviteCallResponse interface {
	OK() bool
	ReplyTo() int
	Error() *objects.ErrorResponse
	Timestamp() string
	Channel() *objects.Channel
}

type channelsInviteCallResponseProxy struct {
	OK        bool                   `json:"ok"`
	ReplyTo   int                    `json:"reply_to"`
	Error     *objects.ErrorResponse `json:"error"`
	Timestamp string                 `json:"ts"`
	Payload0  json.RawMessage        `json:"-"`
	Payload1  json.RawMessage        `json:"channel"`
}
type channelsInviteCallResponse struct {
	ok      bool
	replyTo int
	error   *objects.ErrorResponse
	ts      string
	channel *objects.Channel
}
type ChannelsInviteCallResponseBuilder struct {
	resp *channelsInviteCallResponse
}

func BuildChannelsInviteCallResponse() *ChannelsInviteCallResponseBuilder {
	return &ChannelsInviteCallResponseBuilder{resp: &channelsInviteCallResponse{}}
}
func (v *channelsInviteCallResponse) OK() bool {
	return v.ok
}
func (v *channelsInviteCallResponse) ReplyTo() int {
	return v.replyTo
}
func (v *channelsInviteCallResponse) Error() *objects.ErrorResponse {
	return v.error
}
func (v *channelsInviteCallResponse) Timestamp() string {
	return v.ts
}
func (v *channelsInviteCallResponse) Channel() *objects.Channel {
	return v.channel
}
func (b *ChannelsInviteCallResponseBuilder) OK(v bool) *ChannelsInviteCallResponseBuilder {
	b.resp.ok = v
	return b
}
func (b *ChannelsInviteCallResponseBuilder) ReplyTo(v int) *ChannelsInviteCallResponseBuilder {
	b.resp.replyTo = v
	return b
}
func (b *ChannelsInviteCallResponseBuilder) Error(v *objects.ErrorResponse) *ChannelsInviteCallResponseBuilder {
	b.resp.error = v
	return b
}
func (b *ChannelsInviteCallResponseBuilder) Timestamp(v string) *ChannelsInviteCallResponseBuilder {
	b.resp.ts = v
	return b
}
func (b *ChannelsInviteCallResponseBuilder) Channel(v *objects.Channel) *ChannelsInviteCallResponseBuilder {
	b.resp.channel = v
	return b
}
func (b *ChannelsInviteCallResponseBuilder) Build() ChannelsInviteCallResponse {
	v := b.resp
	b.resp = &channelsInviteCallResponse{}
	return v
}
func (r *channelsInviteCallResponseProxy) parse(data []byte) error {
	if err := json.Unmarshal(data, r); err != nil {
		return errors.Wrap(err, `failed to unmarshal ChannelsInviteCallResponse`)
	}
	r.Payload0 = data
	return nil
}
func (r *channelsInviteCallResponseProxy) payload() (*objects.Channel, error) {
	var res1 objects.Channel
	if err := json.Unmarshal(r.Payload1, &res1); err != nil {
		return nil, errors.Wrap(err, `failed to ummarshal objects.Channel from response`)
	}
	return &res1, nil
}

// Do executes the call to access channels.invite endpoint
func (c *ChannelsInviteCall) Do(ctx context.Context) (*objects.Channel, error) {
	const endpoint = "channels.invite"
	v, err := c.Values()
	if err != nil {
		return nil, err
	}
	var res channelsInviteCallResponseProxy
	if err := c.service.client.postForm(ctx, endpoint, v, &res); err != nil {
		return nil, errors.Wrap(err, `failed to post to channels.invite`)
	}
	if !res.OK {
		var err error
		if errresp := res.Error; errresp != nil {
			err = errors.New(errresp.String())
		} else {
			err = errors.New(`unknown error while posting to channels.invite`)
		}
		return nil, err
	}

	return res.payload()
}

// FromValues parses the data in v and populates `c`
func (c *ChannelsInviteCall) FromValues(v url.Values) error {
	var tmp ChannelsInviteCall
	if raw := strings.TrimSpace(v.Get("channel")); len(raw) > 0 {
		tmp.channel = raw
	}
	if raw := strings.TrimSpace(v.Get("user")); len(raw) > 0 {
		tmp.user = raw
	}
	*c = tmp
	return nil
}

// Join creates a ChannelsJoinCall object in preparation for accessing the channels.join endpoint
func (s *ChannelsService) Join(name string) *ChannelsJoinCall {
	var call ChannelsJoinCall
	call.service = s
	call.name = name
	return &call
}

// Validate sets the value for optional validate parameter
func (c *ChannelsJoinCall) Validate(validate bool) *ChannelsJoinCall {
	c.validate = validate
	return c
}

// ValidateArgs checks that all required fields are set in the ChannelsJoinCall object
func (c *ChannelsJoinCall) ValidateArgs() error {
	if len(c.name) <= 0 {
		return errors.New(`required field name not initialized`)
	}
	return nil
}

// Values returns the ChannelsJoinCall object as url.Values
func (c *ChannelsJoinCall) Values() (url.Values, error) {
	if err := c.ValidateArgs(); err != nil {
		return nil, errors.Wrap(err, `failed validation`)
	}
	v := url.Values{}
	v.Set(`token`, c.service.token)

	v.Set("name", c.name)

	if c.validate {
		v.Set("validate", "true")
	}
	return v, nil
}

type ChannelsJoinCallResponse interface {
	OK() bool
	ReplyTo() int
	Error() *objects.ErrorResponse
	Timestamp() string
}

type channelsJoinCallResponseProxy struct {
	OK        bool                   `json:"ok"`
	ReplyTo   int                    `json:"reply_to"`
	Error     *objects.ErrorResponse `json:"error"`
	Timestamp string                 `json:"ts"`
	Payload0  json.RawMessage        `json:"-"`
}
type channelsJoinCallResponse struct {
	ok      bool
	replyTo int
	error   *objects.ErrorResponse
	ts      string
}
type ChannelsJoinCallResponseBuilder struct {
	resp *channelsJoinCallResponse
}

func BuildChannelsJoinCallResponse() *ChannelsJoinCallResponseBuilder {
	return &ChannelsJoinCallResponseBuilder{resp: &channelsJoinCallResponse{}}
}
func (v *channelsJoinCallResponse) OK() bool {
	return v.ok
}
func (v *channelsJoinCallResponse) ReplyTo() int {
	return v.replyTo
}
func (v *channelsJoinCallResponse) Error() *objects.ErrorResponse {
	return v.error
}
func (v *channelsJoinCallResponse) Timestamp() string {
	return v.ts
}
func (b *ChannelsJoinCallResponseBuilder) OK(v bool) *ChannelsJoinCallResponseBuilder {
	b.resp.ok = v
	return b
}
func (b *ChannelsJoinCallResponseBuilder) ReplyTo(v int) *ChannelsJoinCallResponseBuilder {
	b.resp.replyTo = v
	return b
}
func (b *ChannelsJoinCallResponseBuilder) Error(v *objects.ErrorResponse) *ChannelsJoinCallResponseBuilder {
	b.resp.error = v
	return b
}
func (b *ChannelsJoinCallResponseBuilder) Timestamp(v string) *ChannelsJoinCallResponseBuilder {
	b.resp.ts = v
	return b
}
func (b *ChannelsJoinCallResponseBuilder) Build() ChannelsJoinCallResponse {
	v := b.resp
	b.resp = &channelsJoinCallResponse{}
	return v
}
func (r *channelsJoinCallResponseProxy) parse(data []byte) error {
	if err := json.Unmarshal(data, r); err != nil {
		return errors.Wrap(err, `failed to unmarshal ChannelsJoinCallResponse`)
	}
	r.Payload0 = data
	return nil
}
func (r *channelsJoinCallResponseProxy) payload() (*objects.Channel, error) {
	var res0 objects.Channel
	if err := json.Unmarshal(r.Payload0, &res0); err != nil {
		return nil, errors.Wrap(err, `failed to ummarshal objects.Channel from response`)
	}
	return &res0, nil
}

// Do executes the call to access channels.join endpoint
func (c *ChannelsJoinCall) Do(ctx context.Context) (*objects.Channel, error) {
	const endpoint = "channels.join"
	v, err := c.Values()
	if err != nil {
		return nil, err
	}
	var res channelsJoinCallResponseProxy
	if err := c.service.client.postForm(ctx, endpoint, v, &res); err != nil {
		return nil, errors.Wrap(err, `failed to post to channels.join`)
	}
	if !res.OK {
		var err error
		if errresp := res.Error; errresp != nil {
			err = errors.New(errresp.String())
		} else {
			err = errors.New(`unknown error while posting to channels.join`)
		}
		return nil, err
	}

	return res.payload()
}

// FromValues parses the data in v and populates `c`
func (c *ChannelsJoinCall) FromValues(v url.Values) error {
	var tmp ChannelsJoinCall
	if raw := strings.TrimSpace(v.Get("name")); len(raw) > 0 {
		tmp.name = raw
	}
	if raw := strings.TrimSpace(v.Get("validate")); len(raw) > 0 {
		parsed, err := strconv.ParseBool(raw)
		if err != nil {
			return errors.Wrap(err, `failed to parse boolean value "validate"`)
		}
		tmp.validate = parsed
	}
	*c = tmp
	return nil
}

// Kick creates a ChannelsKickCall object in preparation for accessing the channels.kick endpoint
func (s *ChannelsService) Kick(channel string, user string) *ChannelsKickCall {
	var call ChannelsKickCall
	call.service = s
	call.channel = channel
	call.user = user
	return &call
}

// ValidateArgs checks that all required fields are set in the ChannelsKickCall object
func (c *ChannelsKickCall) ValidateArgs() error {
	if len(c.channel) <= 0 {
		return errors.New(`required field channel not initialized`)
	}
	if len(c.user) <= 0 {
		return errors.New(`required field user not initialized`)
	}
	return nil
}

// Values returns the ChannelsKickCall object as url.Values
func (c *ChannelsKickCall) Values() (url.Values, error) {
	if err := c.ValidateArgs(); err != nil {
		return nil, errors.Wrap(err, `failed validation`)
	}
	v := url.Values{}
	v.Set(`token`, c.service.token)

	v.Set("channel", c.channel)

	v.Set("user", c.user)
	return v, nil
}

type ChannelsKickCallResponse interface {
	OK() bool
	ReplyTo() int
	Error() *objects.ErrorResponse
	Timestamp() string
}

type channelsKickCallResponseProxy struct {
	OK        bool                   `json:"ok"`
	ReplyTo   int                    `json:"reply_to"`
	Error     *objects.ErrorResponse `json:"error"`
	Timestamp string                 `json:"ts"`
	Payload0  json.RawMessage        `json:"-"`
}
type channelsKickCallResponse struct {
	ok      bool
	replyTo int
	error   *objects.ErrorResponse
	ts      string
}
type ChannelsKickCallResponseBuilder struct {
	resp *channelsKickCallResponse
}

func BuildChannelsKickCallResponse() *ChannelsKickCallResponseBuilder {
	return &ChannelsKickCallResponseBuilder{resp: &channelsKickCallResponse{}}
}
func (v *channelsKickCallResponse) OK() bool {
	return v.ok
}
func (v *channelsKickCallResponse) ReplyTo() int {
	return v.replyTo
}
func (v *channelsKickCallResponse) Error() *objects.ErrorResponse {
	return v.error
}
func (v *channelsKickCallResponse) Timestamp() string {
	return v.ts
}
func (b *ChannelsKickCallResponseBuilder) OK(v bool) *ChannelsKickCallResponseBuilder {
	b.resp.ok = v
	return b
}
func (b *ChannelsKickCallResponseBuilder) ReplyTo(v int) *ChannelsKickCallResponseBuilder {
	b.resp.replyTo = v
	return b
}
func (b *ChannelsKickCallResponseBuilder) Error(v *objects.ErrorResponse) *ChannelsKickCallResponseBuilder {
	b.resp.error = v
	return b
}
func (b *ChannelsKickCallResponseBuilder) Timestamp(v string) *ChannelsKickCallResponseBuilder {
	b.resp.ts = v
	return b
}
func (b *ChannelsKickCallResponseBuilder) Build() ChannelsKickCallResponse {
	v := b.resp
	b.resp = &channelsKickCallResponse{}
	return v
}
func (r *channelsKickCallResponseProxy) parse(data []byte) error {
	if err := json.Unmarshal(data, r); err != nil {
		return errors.Wrap(err, `failed to unmarshal ChannelsKickCallResponse`)
	}
	r.Payload0 = data
	return nil
}

// Do executes the call to access channels.kick endpoint
func (c *ChannelsKickCall) Do(ctx context.Context) error {
	const endpoint = "channels.kick"
	v, err := c.Values()
	if err != nil {
		return err
	}
	var res channelsKickCallResponseProxy
	if err := c.service.client.postForm(ctx, endpoint, v, &res); err != nil {
		return errors.Wrap(err, `failed to post to channels.kick`)
	}
	if !res.OK {
		var err error
		if errresp := res.Error; errresp != nil {
			err = errors.New(errresp.String())
		} else {
			err = errors.New(`unknown error while posting to channels.kick`)
		}
		return err
	}

	return nil
}

// FromValues parses the data in v and populates `c`
func (c *ChannelsKickCall) FromValues(v url.Values) error {
	var tmp ChannelsKickCall
	if raw := strings.TrimSpace(v.Get("channel")); len(raw) > 0 {
		tmp.channel = raw
	}
	if raw := strings.TrimSpace(v.Get("user")); len(raw) > 0 {
		tmp.user = raw
	}
	*c = tmp
	return nil
}

// Leave creates a ChannelsLeaveCall object in preparation for accessing the channels.leave endpoint
func (s *ChannelsService) Leave(channel string) *ChannelsLeaveCall {
	var call ChannelsLeaveCall
	call.service = s
	call.channel = channel
	return &call
}

// ValidateArgs checks that all required fields are set in the ChannelsLeaveCall object
func (c *ChannelsLeaveCall) ValidateArgs() error {
	if len(c.channel) <= 0 {
		return errors.New(`required field channel not initialized`)
	}
	return nil
}

// Values returns the ChannelsLeaveCall object as url.Values
func (c *ChannelsLeaveCall) Values() (url.Values, error) {
	if err := c.ValidateArgs(); err != nil {
		return nil, errors.Wrap(err, `failed validation`)
	}
	v := url.Values{}
	v.Set(`token`, c.service.token)

	v.Set("channel", c.channel)
	return v, nil
}

type ChannelsLeaveCallResponse interface {
	OK() bool
	ReplyTo() int
	Error() *objects.ErrorResponse
	Timestamp() string
}

type channelsLeaveCallResponseProxy struct {
	OK        bool                   `json:"ok"`
	ReplyTo   int                    `json:"reply_to"`
	Error     *objects.ErrorResponse `json:"error"`
	Timestamp string                 `json:"ts"`
	Payload0  json.RawMessage        `json:"-"`
}
type channelsLeaveCallResponse struct {
	ok      bool
	replyTo int
	error   *objects.ErrorResponse
	ts      string
}
type ChannelsLeaveCallResponseBuilder struct {
	resp *channelsLeaveCallResponse
}

func BuildChannelsLeaveCallResponse() *ChannelsLeaveCallResponseBuilder {
	return &ChannelsLeaveCallResponseBuilder{resp: &channelsLeaveCallResponse{}}
}
func (v *channelsLeaveCallResponse) OK() bool {
	return v.ok
}
func (v *channelsLeaveCallResponse) ReplyTo() int {
	return v.replyTo
}
func (v *channelsLeaveCallResponse) Error() *objects.ErrorResponse {
	return v.error
}
func (v *channelsLeaveCallResponse) Timestamp() string {
	return v.ts
}
func (b *ChannelsLeaveCallResponseBuilder) OK(v bool) *ChannelsLeaveCallResponseBuilder {
	b.resp.ok = v
	return b
}
func (b *ChannelsLeaveCallResponseBuilder) ReplyTo(v int) *ChannelsLeaveCallResponseBuilder {
	b.resp.replyTo = v
	return b
}
func (b *ChannelsLeaveCallResponseBuilder) Error(v *objects.ErrorResponse) *ChannelsLeaveCallResponseBuilder {
	b.resp.error = v
	return b
}
func (b *ChannelsLeaveCallResponseBuilder) Timestamp(v string) *ChannelsLeaveCallResponseBuilder {
	b.resp.ts = v
	return b
}
func (b *ChannelsLeaveCallResponseBuilder) Build() ChannelsLeaveCallResponse {
	v := b.resp
	b.resp = &channelsLeaveCallResponse{}
	return v
}
func (r *channelsLeaveCallResponseProxy) parse(data []byte) error {
	if err := json.Unmarshal(data, r); err != nil {
		return errors.Wrap(err, `failed to unmarshal ChannelsLeaveCallResponse`)
	}
	r.Payload0 = data
	return nil
}

// Do executes the call to access channels.leave endpoint
func (c *ChannelsLeaveCall) Do(ctx context.Context) error {
	const endpoint = "channels.leave"
	v, err := c.Values()
	if err != nil {
		return err
	}
	var res channelsLeaveCallResponseProxy
	if err := c.service.client.postForm(ctx, endpoint, v, &res); err != nil {
		return errors.Wrap(err, `failed to post to channels.leave`)
	}
	if !res.OK {
		var err error
		if errresp := res.Error; errresp != nil {
			err = errors.New(errresp.String())
		} else {
			err = errors.New(`unknown error while posting to channels.leave`)
		}
		return err
	}

	return nil
}

// FromValues parses the data in v and populates `c`
func (c *ChannelsLeaveCall) FromValues(v url.Values) error {
	var tmp ChannelsLeaveCall
	if raw := strings.TrimSpace(v.Get("channel")); len(raw) > 0 {
		tmp.channel = raw
	}
	*c = tmp
	return nil
}

// List creates a ChannelsListCall object in preparation for accessing the channels.list endpoint
func (s *ChannelsService) List() *ChannelsListCall {
	var call ChannelsListCall
	call.service = s
	return &call
}

// ExcludeArchive sets the value for optional excludeArchive parameter
func (c *ChannelsListCall) ExcludeArchive(excludeArchive bool) *ChannelsListCall {
	c.excludeArchive = excludeArchive
	return c
}

// ExcludeMembers sets the value for optional excludeMembers parameter
func (c *ChannelsListCall) ExcludeMembers(excludeMembers bool) *ChannelsListCall {
	c.excludeMembers = excludeMembers
	return c
}

// Limit sets the value for optional limit parameter
func (c *ChannelsListCall) Limit(limit int) *ChannelsListCall {
	c.limit = limit
	return c
}

// ValidateArgs checks that all required fields are set in the ChannelsListCall object
func (c *ChannelsListCall) ValidateArgs() error {
	return nil
}

// Values returns the ChannelsListCall object as url.Values
func (c *ChannelsListCall) Values() (url.Values, error) {
	if err := c.ValidateArgs(); err != nil {
		return nil, errors.Wrap(err, `failed validation`)
	}
	v := url.Values{}
	v.Set(`token`, c.service.token)

	if c.excludeArchive {
		v.Set("exclude_archive", "true")
	}

	if c.excludeMembers {
		v.Set("exclude_members", "true")
	}

	if c.limit > 0 {
		v.Set("limit", strconv.Itoa(c.limit))
	}
	return v, nil
}

type ChannelsListCallResponse interface {
	OK() bool
	ReplyTo() int
	Error() *objects.ErrorResponse
	Timestamp() string
	Channels() *objects.ChannelList
}

type channelsListCallResponseProxy struct {
	OK        bool                   `json:"ok"`
	ReplyTo   int                    `json:"reply_to"`
	Error     *objects.ErrorResponse `json:"error"`
	Timestamp string                 `json:"ts"`
	Payload0  json.RawMessage        `json:"-"`
	Payload1  json.RawMessage        `json:"channels"`
}
type channelsListCallResponse struct {
	ok       bool
	replyTo  int
	error    *objects.ErrorResponse
	ts       string
	channels *objects.ChannelList
}
type ChannelsListCallResponseBuilder struct {
	resp *channelsListCallResponse
}

func BuildChannelsListCallResponse() *ChannelsListCallResponseBuilder {
	return &ChannelsListCallResponseBuilder{resp: &channelsListCallResponse{}}
}
func (v *channelsListCallResponse) OK() bool {
	return v.ok
}
func (v *channelsListCallResponse) ReplyTo() int {
	return v.replyTo
}
func (v *channelsListCallResponse) Error() *objects.ErrorResponse {
	return v.error
}
func (v *channelsListCallResponse) Timestamp() string {
	return v.ts
}
func (v *channelsListCallResponse) Channels() *objects.ChannelList {
	return v.channels
}
func (b *ChannelsListCallResponseBuilder) OK(v bool) *ChannelsListCallResponseBuilder {
	b.resp.ok = v
	return b
}
func (b *ChannelsListCallResponseBuilder) ReplyTo(v int) *ChannelsListCallResponseBuilder {
	b.resp.replyTo = v
	return b
}
func (b *ChannelsListCallResponseBuilder) Error(v *objects.ErrorResponse) *ChannelsListCallResponseBuilder {
	b.resp.error = v
	return b
}
func (b *ChannelsListCallResponseBuilder) Timestamp(v string) *ChannelsListCallResponseBuilder {
	b.resp.ts = v
	return b
}
func (b *ChannelsListCallResponseBuilder) Channels(v *objects.ChannelList) *ChannelsListCallResponseBuilder {
	b.resp.channels = v
	return b
}
func (b *ChannelsListCallResponseBuilder) Build() ChannelsListCallResponse {
	v := b.resp
	b.resp = &channelsListCallResponse{}
	return v
}
func (r *channelsListCallResponseProxy) parse(data []byte) error {
	if err := json.Unmarshal(data, r); err != nil {
		return errors.Wrap(err, `failed to unmarshal ChannelsListCallResponse`)
	}
	r.Payload0 = data
	return nil
}
func (r *channelsListCallResponseProxy) payload() (objects.ChannelList, error) {
	var res1 objects.ChannelList
	if err := json.Unmarshal(r.Payload1, &res1); err != nil {
		return nil, errors.Wrap(err, `failed to ummarshal objects.ChannelList from response`)
	}
	return res1, nil
}

// Do executes the call to access channels.list endpoint
func (c *ChannelsListCall) Do(ctx context.Context) (objects.ChannelList, error) {
	const endpoint = "channels.list"
	v, err := c.Values()
	if err != nil {
		return nil, err
	}
	var res channelsListCallResponseProxy
	if err := c.service.client.postForm(ctx, endpoint, v, &res); err != nil {
		return nil, errors.Wrap(err, `failed to post to channels.list`)
	}
	if !res.OK {
		var err error
		if errresp := res.Error; errresp != nil {
			err = errors.New(errresp.String())
		} else {
			err = errors.New(`unknown error while posting to channels.list`)
		}
		return nil, err
	}

	return res.payload()
}

// FromValues parses the data in v and populates `c`
func (c *ChannelsListCall) FromValues(v url.Values) error {
	var tmp ChannelsListCall
	if raw := strings.TrimSpace(v.Get("exclude_archive")); len(raw) > 0 {
		parsed, err := strconv.ParseBool(raw)
		if err != nil {
			return errors.Wrap(err, `failed to parse boolean value "exclude_archive"`)
		}
		tmp.excludeArchive = parsed
	}
	if raw := strings.TrimSpace(v.Get("exclude_members")); len(raw) > 0 {
		parsed, err := strconv.ParseBool(raw)
		if err != nil {
			return errors.Wrap(err, `failed to parse boolean value "exclude_members"`)
		}
		tmp.excludeMembers = parsed
	}
	if raw := strings.TrimSpace(v.Get("limit")); len(raw) > 0 {
		parsed, err := strconv.ParseInt(raw, 10, 64)
		if err != nil {
			return errors.Wrap(err, `failed to parse integer value "limit"`)
		}
		tmp.limit = int(parsed)
	}
	*c = tmp
	return nil
}

// Mark creates a ChannelsMarkCall object in preparation for accessing the channels.mark endpoint
func (s *ChannelsService) Mark(channel string) *ChannelsMarkCall {
	var call ChannelsMarkCall
	call.service = s
	call.channel = channel
	return &call
}

// Timestamp sets the value for optional timestamp parameter
func (c *ChannelsMarkCall) Timestamp(timestamp string) *ChannelsMarkCall {
	c.timestamp = timestamp
	return c
}

// ValidateArgs checks that all required fields are set in the ChannelsMarkCall object
func (c *ChannelsMarkCall) ValidateArgs() error {
	if len(c.channel) <= 0 {
		return errors.New(`required field channel not initialized`)
	}
	return nil
}

// Values returns the ChannelsMarkCall object as url.Values
func (c *ChannelsMarkCall) Values() (url.Values, error) {
	if err := c.ValidateArgs(); err != nil {
		return nil, errors.Wrap(err, `failed validation`)
	}
	v := url.Values{}
	v.Set(`token`, c.service.token)

	v.Set("channel", c.channel)

	if len(c.timestamp) > 0 {
		v.Set("ts", c.timestamp)
	}
	return v, nil
}

type ChannelsMarkCallResponse interface {
	OK() bool
	ReplyTo() int
	Error() *objects.ErrorResponse
	Timestamp() string
}

type channelsMarkCallResponseProxy struct {
	OK        bool                   `json:"ok"`
	ReplyTo   int                    `json:"reply_to"`
	Error     *objects.ErrorResponse `json:"error"`
	Timestamp string                 `json:"ts"`
	Payload0  json.RawMessage        `json:"-"`
}
type channelsMarkCallResponse struct {
	ok      bool
	replyTo int
	error   *objects.ErrorResponse
	ts      string
}
type ChannelsMarkCallResponseBuilder struct {
	resp *channelsMarkCallResponse
}

func BuildChannelsMarkCallResponse() *ChannelsMarkCallResponseBuilder {
	return &ChannelsMarkCallResponseBuilder{resp: &channelsMarkCallResponse{}}
}
func (v *channelsMarkCallResponse) OK() bool {
	return v.ok
}
func (v *channelsMarkCallResponse) ReplyTo() int {
	return v.replyTo
}
func (v *channelsMarkCallResponse) Error() *objects.ErrorResponse {
	return v.error
}
func (v *channelsMarkCallResponse) Timestamp() string {
	return v.ts
}
func (b *ChannelsMarkCallResponseBuilder) OK(v bool) *ChannelsMarkCallResponseBuilder {
	b.resp.ok = v
	return b
}
func (b *ChannelsMarkCallResponseBuilder) ReplyTo(v int) *ChannelsMarkCallResponseBuilder {
	b.resp.replyTo = v
	return b
}
func (b *ChannelsMarkCallResponseBuilder) Error(v *objects.ErrorResponse) *ChannelsMarkCallResponseBuilder {
	b.resp.error = v
	return b
}
func (b *ChannelsMarkCallResponseBuilder) Timestamp(v string) *ChannelsMarkCallResponseBuilder {
	b.resp.ts = v
	return b
}
func (b *ChannelsMarkCallResponseBuilder) Build() ChannelsMarkCallResponse {
	v := b.resp
	b.resp = &channelsMarkCallResponse{}
	return v
}
func (r *channelsMarkCallResponseProxy) parse(data []byte) error {
	if err := json.Unmarshal(data, r); err != nil {
		return errors.Wrap(err, `failed to unmarshal ChannelsMarkCallResponse`)
	}
	r.Payload0 = data
	return nil
}

// Do executes the call to access channels.mark endpoint
func (c *ChannelsMarkCall) Do(ctx context.Context) error {
	const endpoint = "channels.mark"
	v, err := c.Values()
	if err != nil {
		return err
	}
	var res channelsMarkCallResponseProxy
	if err := c.service.client.postForm(ctx, endpoint, v, &res); err != nil {
		return errors.Wrap(err, `failed to post to channels.mark`)
	}
	if !res.OK {
		var err error
		if errresp := res.Error; errresp != nil {
			err = errors.New(errresp.String())
		} else {
			err = errors.New(`unknown error while posting to channels.mark`)
		}
		return err
	}

	return nil
}

// FromValues parses the data in v and populates `c`
func (c *ChannelsMarkCall) FromValues(v url.Values) error {
	var tmp ChannelsMarkCall
	if raw := strings.TrimSpace(v.Get("channel")); len(raw) > 0 {
		tmp.channel = raw
	}
	if raw := strings.TrimSpace(v.Get("ts")); len(raw) > 0 {
		tmp.timestamp = raw
	}
	*c = tmp
	return nil
}

// Rename creates a ChannelsRenameCall object in preparation for accessing the channels.rename endpoint
func (s *ChannelsService) Rename(channel string, name string) *ChannelsRenameCall {
	var call ChannelsRenameCall
	call.service = s
	call.channel = channel
	call.name = name
	return &call
}

// Validate sets the value for optional validate parameter
func (c *ChannelsRenameCall) Validate(validate bool) *ChannelsRenameCall {
	c.validate = validate
	return c
}

// ValidateArgs checks that all required fields are set in the ChannelsRenameCall object
func (c *ChannelsRenameCall) ValidateArgs() error {
	if len(c.channel) <= 0 {
		return errors.New(`required field channel not initialized`)
	}
	if len(c.name) <= 0 {
		return errors.New(`required field name not initialized`)
	}
	return nil
}

// Values returns the ChannelsRenameCall object as url.Values
func (c *ChannelsRenameCall) Values() (url.Values, error) {
	if err := c.ValidateArgs(); err != nil {
		return nil, errors.Wrap(err, `failed validation`)
	}
	v := url.Values{}
	v.Set(`token`, c.service.token)

	v.Set("channel", c.channel)

	v.Set("name", c.name)

	if c.validate {
		v.Set("validate", "true")
	}
	return v, nil
}

type ChannelsRenameCallResponse interface {
	OK() bool
	ReplyTo() int
	Error() *objects.ErrorResponse
	Timestamp() string
	Channel() *objects.Channel
}

type channelsRenameCallResponseProxy struct {
	OK        bool                   `json:"ok"`
	ReplyTo   int                    `json:"reply_to"`
	Error     *objects.ErrorResponse `json:"error"`
	Timestamp string                 `json:"ts"`
	Payload0  json.RawMessage        `json:"-"`
	Payload1  json.RawMessage        `json:"channel"`
}
type channelsRenameCallResponse struct {
	ok      bool
	replyTo int
	error   *objects.ErrorResponse
	ts      string
	channel *objects.Channel
}
type ChannelsRenameCallResponseBuilder struct {
	resp *channelsRenameCallResponse
}

func BuildChannelsRenameCallResponse() *ChannelsRenameCallResponseBuilder {
	return &ChannelsRenameCallResponseBuilder{resp: &channelsRenameCallResponse{}}
}
func (v *channelsRenameCallResponse) OK() bool {
	return v.ok
}
func (v *channelsRenameCallResponse) ReplyTo() int {
	return v.replyTo
}
func (v *channelsRenameCallResponse) Error() *objects.ErrorResponse {
	return v.error
}
func (v *channelsRenameCallResponse) Timestamp() string {
	return v.ts
}
func (v *channelsRenameCallResponse) Channel() *objects.Channel {
	return v.channel
}
func (b *ChannelsRenameCallResponseBuilder) OK(v bool) *ChannelsRenameCallResponseBuilder {
	b.resp.ok = v
	return b
}
func (b *ChannelsRenameCallResponseBuilder) ReplyTo(v int) *ChannelsRenameCallResponseBuilder {
	b.resp.replyTo = v
	return b
}
func (b *ChannelsRenameCallResponseBuilder) Error(v *objects.ErrorResponse) *ChannelsRenameCallResponseBuilder {
	b.resp.error = v
	return b
}
func (b *ChannelsRenameCallResponseBuilder) Timestamp(v string) *ChannelsRenameCallResponseBuilder {
	b.resp.ts = v
	return b
}
func (b *ChannelsRenameCallResponseBuilder) Channel(v *objects.Channel) *ChannelsRenameCallResponseBuilder {
	b.resp.channel = v
	return b
}
func (b *ChannelsRenameCallResponseBuilder) Build() ChannelsRenameCallResponse {
	v := b.resp
	b.resp = &channelsRenameCallResponse{}
	return v
}
func (r *channelsRenameCallResponseProxy) parse(data []byte) error {
	if err := json.Unmarshal(data, r); err != nil {
		return errors.Wrap(err, `failed to unmarshal ChannelsRenameCallResponse`)
	}
	r.Payload0 = data
	return nil
}
func (r *channelsRenameCallResponseProxy) payload() (*objects.Channel, error) {
	var res1 objects.Channel
	if err := json.Unmarshal(r.Payload1, &res1); err != nil {
		return nil, errors.Wrap(err, `failed to ummarshal objects.Channel from response`)
	}
	return &res1, nil
}

// Do executes the call to access channels.rename endpoint
func (c *ChannelsRenameCall) Do(ctx context.Context) (*objects.Channel, error) {
	const endpoint = "channels.rename"
	v, err := c.Values()
	if err != nil {
		return nil, err
	}
	var res channelsRenameCallResponseProxy
	if err := c.service.client.postForm(ctx, endpoint, v, &res); err != nil {
		return nil, errors.Wrap(err, `failed to post to channels.rename`)
	}
	if !res.OK {
		var err error
		if errresp := res.Error; errresp != nil {
			err = errors.New(errresp.String())
		} else {
			err = errors.New(`unknown error while posting to channels.rename`)
		}
		return nil, err
	}

	return res.payload()
}

// FromValues parses the data in v and populates `c`
func (c *ChannelsRenameCall) FromValues(v url.Values) error {
	var tmp ChannelsRenameCall
	if raw := strings.TrimSpace(v.Get("channel")); len(raw) > 0 {
		tmp.channel = raw
	}
	if raw := strings.TrimSpace(v.Get("name")); len(raw) > 0 {
		tmp.name = raw
	}
	if raw := strings.TrimSpace(v.Get("validate")); len(raw) > 0 {
		parsed, err := strconv.ParseBool(raw)
		if err != nil {
			return errors.Wrap(err, `failed to parse boolean value "validate"`)
		}
		tmp.validate = parsed
	}
	*c = tmp
	return nil
}

// Replies creates a ChannelsRepliesCall object in preparation for accessing the channels.replies endpoint
func (s *ChannelsService) Replies(channel string, threadTimestamp string) *ChannelsRepliesCall {
	var call ChannelsRepliesCall
	call.service = s
	call.channel = channel
	call.threadTimestamp = threadTimestamp
	return &call
}

// ValidateArgs checks that all required fields are set in the ChannelsRepliesCall object
func (c *ChannelsRepliesCall) ValidateArgs() error {
	if len(c.channel) <= 0 {
		return errors.New(`required field channel not initialized`)
	}
	if len(c.threadTimestamp) <= 0 {
		return errors.New(`required field threadTimestamp not initialized`)
	}
	return nil
}

// Values returns the ChannelsRepliesCall object as url.Values
func (c *ChannelsRepliesCall) Values() (url.Values, error) {
	if err := c.ValidateArgs(); err != nil {
		return nil, errors.Wrap(err, `failed validation`)
	}
	v := url.Values{}
	v.Set(`token`, c.service.token)

	v.Set("channel", c.channel)

	v.Set("thread_ts", c.threadTimestamp)
	return v, nil
}

type ChannelsRepliesCallResponse interface {
	OK() bool
	ReplyTo() int
	Error() *objects.ErrorResponse
	Timestamp() string
	Messages() *objects.MessageList
}

type channelsRepliesCallResponseProxy struct {
	OK        bool                   `json:"ok"`
	ReplyTo   int                    `json:"reply_to"`
	Error     *objects.ErrorResponse `json:"error"`
	Timestamp string                 `json:"ts"`
	Payload0  json.RawMessage        `json:"-"`
	Payload1  json.RawMessage        `json:"messages"`
}
type channelsRepliesCallResponse struct {
	ok       bool
	replyTo  int
	error    *objects.ErrorResponse
	ts       string
	messages *objects.MessageList
}
type ChannelsRepliesCallResponseBuilder struct {
	resp *channelsRepliesCallResponse
}

func BuildChannelsRepliesCallResponse() *ChannelsRepliesCallResponseBuilder {
	return &ChannelsRepliesCallResponseBuilder{resp: &channelsRepliesCallResponse{}}
}
func (v *channelsRepliesCallResponse) OK() bool {
	return v.ok
}
func (v *channelsRepliesCallResponse) ReplyTo() int {
	return v.replyTo
}
func (v *channelsRepliesCallResponse) Error() *objects.ErrorResponse {
	return v.error
}
func (v *channelsRepliesCallResponse) Timestamp() string {
	return v.ts
}
func (v *channelsRepliesCallResponse) Messages() *objects.MessageList {
	return v.messages
}
func (b *ChannelsRepliesCallResponseBuilder) OK(v bool) *ChannelsRepliesCallResponseBuilder {
	b.resp.ok = v
	return b
}
func (b *ChannelsRepliesCallResponseBuilder) ReplyTo(v int) *ChannelsRepliesCallResponseBuilder {
	b.resp.replyTo = v
	return b
}
func (b *ChannelsRepliesCallResponseBuilder) Error(v *objects.ErrorResponse) *ChannelsRepliesCallResponseBuilder {
	b.resp.error = v
	return b
}
func (b *ChannelsRepliesCallResponseBuilder) Timestamp(v string) *ChannelsRepliesCallResponseBuilder {
	b.resp.ts = v
	return b
}
func (b *ChannelsRepliesCallResponseBuilder) Messages(v *objects.MessageList) *ChannelsRepliesCallResponseBuilder {
	b.resp.messages = v
	return b
}
func (b *ChannelsRepliesCallResponseBuilder) Build() ChannelsRepliesCallResponse {
	v := b.resp
	b.resp = &channelsRepliesCallResponse{}
	return v
}
func (r *channelsRepliesCallResponseProxy) parse(data []byte) error {
	if err := json.Unmarshal(data, r); err != nil {
		return errors.Wrap(err, `failed to unmarshal ChannelsRepliesCallResponse`)
	}
	r.Payload0 = data
	return nil
}
func (r *channelsRepliesCallResponseProxy) payload() (objects.MessageList, error) {
	var res1 objects.MessageList
	if err := json.Unmarshal(r.Payload1, &res1); err != nil {
		return nil, errors.Wrap(err, `failed to ummarshal objects.MessageList from response`)
	}
	return res1, nil
}

// Do executes the call to access channels.replies endpoint
func (c *ChannelsRepliesCall) Do(ctx context.Context) (objects.MessageList, error) {
	const endpoint = "channels.replies"
	v, err := c.Values()
	if err != nil {
		return nil, err
	}
	var res channelsRepliesCallResponseProxy
	if err := c.service.client.postForm(ctx, endpoint, v, &res); err != nil {
		return nil, errors.Wrap(err, `failed to post to channels.replies`)
	}
	if !res.OK {
		var err error
		if errresp := res.Error; errresp != nil {
			err = errors.New(errresp.String())
		} else {
			err = errors.New(`unknown error while posting to channels.replies`)
		}
		return nil, err
	}

	return res.payload()
}

// FromValues parses the data in v and populates `c`
func (c *ChannelsRepliesCall) FromValues(v url.Values) error {
	var tmp ChannelsRepliesCall
	if raw := strings.TrimSpace(v.Get("channel")); len(raw) > 0 {
		tmp.channel = raw
	}
	if raw := strings.TrimSpace(v.Get("thread_ts")); len(raw) > 0 {
		tmp.threadTimestamp = raw
	}
	*c = tmp
	return nil
}

// SetPurpose creates a ChannelsSetPurposeCall object in preparation for accessing the channels.setPurpose endpoint
func (s *ChannelsService) SetPurpose(channel string, purpose string) *ChannelsSetPurposeCall {
	var call ChannelsSetPurposeCall
	call.service = s
	call.channel = channel
	call.purpose = purpose
	return &call
}

// ValidateArgs checks that all required fields are set in the ChannelsSetPurposeCall object
func (c *ChannelsSetPurposeCall) ValidateArgs() error {
	if len(c.channel) <= 0 {
		return errors.New(`required field channel not initialized`)
	}
	if len(c.purpose) <= 0 {
		return errors.New(`required field purpose not initialized`)
	}
	return nil
}

// Values returns the ChannelsSetPurposeCall object as url.Values
func (c *ChannelsSetPurposeCall) Values() (url.Values, error) {
	if err := c.ValidateArgs(); err != nil {
		return nil, errors.Wrap(err, `failed validation`)
	}
	v := url.Values{}
	v.Set(`token`, c.service.token)

	v.Set("channel", c.channel)

	v.Set("purpose", c.purpose)
	return v, nil
}

type ChannelsSetPurposeCallResponse interface {
	OK() bool
	ReplyTo() int
	Error() *objects.ErrorResponse
	Timestamp() string
	Purpose() *string
}

type channelsSetPurposeCallResponseProxy struct {
	OK        bool                   `json:"ok"`
	ReplyTo   int                    `json:"reply_to"`
	Error     *objects.ErrorResponse `json:"error"`
	Timestamp string                 `json:"ts"`
	Payload0  json.RawMessage        `json:"-"`
	Payload1  json.RawMessage        `json:"purpose"`
}
type channelsSetPurposeCallResponse struct {
	ok      bool
	replyTo int
	error   *objects.ErrorResponse
	ts      string
	purpose *string
}
type ChannelsSetPurposeCallResponseBuilder struct {
	resp *channelsSetPurposeCallResponse
}

func BuildChannelsSetPurposeCallResponse() *ChannelsSetPurposeCallResponseBuilder {
	return &ChannelsSetPurposeCallResponseBuilder{resp: &channelsSetPurposeCallResponse{}}
}
func (v *channelsSetPurposeCallResponse) OK() bool {
	return v.ok
}
func (v *channelsSetPurposeCallResponse) ReplyTo() int {
	return v.replyTo
}
func (v *channelsSetPurposeCallResponse) Error() *objects.ErrorResponse {
	return v.error
}
func (v *channelsSetPurposeCallResponse) Timestamp() string {
	return v.ts
}
func (v *channelsSetPurposeCallResponse) Purpose() *string {
	return v.purpose
}
func (b *ChannelsSetPurposeCallResponseBuilder) OK(v bool) *ChannelsSetPurposeCallResponseBuilder {
	b.resp.ok = v
	return b
}
func (b *ChannelsSetPurposeCallResponseBuilder) ReplyTo(v int) *ChannelsSetPurposeCallResponseBuilder {
	b.resp.replyTo = v
	return b
}
func (b *ChannelsSetPurposeCallResponseBuilder) Error(v *objects.ErrorResponse) *ChannelsSetPurposeCallResponseBuilder {
	b.resp.error = v
	return b
}
func (b *ChannelsSetPurposeCallResponseBuilder) Timestamp(v string) *ChannelsSetPurposeCallResponseBuilder {
	b.resp.ts = v
	return b
}
func (b *ChannelsSetPurposeCallResponseBuilder) Purpose(v *string) *ChannelsSetPurposeCallResponseBuilder {
	b.resp.purpose = v
	return b
}
func (b *ChannelsSetPurposeCallResponseBuilder) Build() ChannelsSetPurposeCallResponse {
	v := b.resp
	b.resp = &channelsSetPurposeCallResponse{}
	return v
}
func (r *channelsSetPurposeCallResponseProxy) parse(data []byte) error {
	if err := json.Unmarshal(data, r); err != nil {
		return errors.Wrap(err, `failed to unmarshal ChannelsSetPurposeCallResponse`)
	}
	r.Payload0 = data
	return nil
}
func (r *channelsSetPurposeCallResponseProxy) payload() (string, error) {
	var res1 string
	if err := json.Unmarshal(r.Payload1, &res1); err != nil {
		return "", errors.Wrap(err, `failed to ummarshal string from response`)
	}
	return res1, nil
}

// Do executes the call to access channels.setPurpose endpoint
func (c *ChannelsSetPurposeCall) Do(ctx context.Context) (string, error) {
	const endpoint = "channels.setPurpose"
	v, err := c.Values()
	if err != nil {
		return "", err
	}
	var res channelsSetPurposeCallResponseProxy
	if err := c.service.client.postForm(ctx, endpoint, v, &res); err != nil {
		return "", errors.Wrap(err, `failed to post to channels.setPurpose`)
	}
	if !res.OK {
		var err error
		if errresp := res.Error; errresp != nil {
			err = errors.New(errresp.String())
		} else {
			err = errors.New(`unknown error while posting to channels.setPurpose`)
		}
		return "", err
	}

	return res.payload()
}

// FromValues parses the data in v and populates `c`
func (c *ChannelsSetPurposeCall) FromValues(v url.Values) error {
	var tmp ChannelsSetPurposeCall
	if raw := strings.TrimSpace(v.Get("channel")); len(raw) > 0 {
		tmp.channel = raw
	}
	if raw := strings.TrimSpace(v.Get("purpose")); len(raw) > 0 {
		tmp.purpose = raw
	}
	*c = tmp
	return nil
}

// SetTopic creates a ChannelsSetTopicCall object in preparation for accessing the channels.setTopic endpoint
func (s *ChannelsService) SetTopic(channel string, topic string) *ChannelsSetTopicCall {
	var call ChannelsSetTopicCall
	call.service = s
	call.channel = channel
	call.topic = topic
	return &call
}

// ValidateArgs checks that all required fields are set in the ChannelsSetTopicCall object
func (c *ChannelsSetTopicCall) ValidateArgs() error {
	if len(c.channel) <= 0 {
		return errors.New(`required field channel not initialized`)
	}
	if len(c.topic) <= 0 {
		return errors.New(`required field topic not initialized`)
	}
	return nil
}

// Values returns the ChannelsSetTopicCall object as url.Values
func (c *ChannelsSetTopicCall) Values() (url.Values, error) {
	if err := c.ValidateArgs(); err != nil {
		return nil, errors.Wrap(err, `failed validation`)
	}
	v := url.Values{}
	v.Set(`token`, c.service.token)

	v.Set("channel", c.channel)

	v.Set("topic", c.topic)
	return v, nil
}

type ChannelsSetTopicCallResponse interface {
	OK() bool
	ReplyTo() int
	Error() *objects.ErrorResponse
	Timestamp() string
	Topic() *string
}

type channelsSetTopicCallResponseProxy struct {
	OK        bool                   `json:"ok"`
	ReplyTo   int                    `json:"reply_to"`
	Error     *objects.ErrorResponse `json:"error"`
	Timestamp string                 `json:"ts"`
	Payload0  json.RawMessage        `json:"-"`
	Payload1  json.RawMessage        `json:"topic"`
}
type channelsSetTopicCallResponse struct {
	ok      bool
	replyTo int
	error   *objects.ErrorResponse
	ts      string
	topic   *string
}
type ChannelsSetTopicCallResponseBuilder struct {
	resp *channelsSetTopicCallResponse
}

func BuildChannelsSetTopicCallResponse() *ChannelsSetTopicCallResponseBuilder {
	return &ChannelsSetTopicCallResponseBuilder{resp: &channelsSetTopicCallResponse{}}
}
func (v *channelsSetTopicCallResponse) OK() bool {
	return v.ok
}
func (v *channelsSetTopicCallResponse) ReplyTo() int {
	return v.replyTo
}
func (v *channelsSetTopicCallResponse) Error() *objects.ErrorResponse {
	return v.error
}
func (v *channelsSetTopicCallResponse) Timestamp() string {
	return v.ts
}
func (v *channelsSetTopicCallResponse) Topic() *string {
	return v.topic
}
func (b *ChannelsSetTopicCallResponseBuilder) OK(v bool) *ChannelsSetTopicCallResponseBuilder {
	b.resp.ok = v
	return b
}
func (b *ChannelsSetTopicCallResponseBuilder) ReplyTo(v int) *ChannelsSetTopicCallResponseBuilder {
	b.resp.replyTo = v
	return b
}
func (b *ChannelsSetTopicCallResponseBuilder) Error(v *objects.ErrorResponse) *ChannelsSetTopicCallResponseBuilder {
	b.resp.error = v
	return b
}
func (b *ChannelsSetTopicCallResponseBuilder) Timestamp(v string) *ChannelsSetTopicCallResponseBuilder {
	b.resp.ts = v
	return b
}
func (b *ChannelsSetTopicCallResponseBuilder) Topic(v *string) *ChannelsSetTopicCallResponseBuilder {
	b.resp.topic = v
	return b
}
func (b *ChannelsSetTopicCallResponseBuilder) Build() ChannelsSetTopicCallResponse {
	v := b.resp
	b.resp = &channelsSetTopicCallResponse{}
	return v
}
func (r *channelsSetTopicCallResponseProxy) parse(data []byte) error {
	if err := json.Unmarshal(data, r); err != nil {
		return errors.Wrap(err, `failed to unmarshal ChannelsSetTopicCallResponse`)
	}
	r.Payload0 = data
	return nil
}
func (r *channelsSetTopicCallResponseProxy) payload() (string, error) {
	var res1 string
	if err := json.Unmarshal(r.Payload1, &res1); err != nil {
		return "", errors.Wrap(err, `failed to ummarshal string from response`)
	}
	return res1, nil
}

// Do executes the call to access channels.setTopic endpoint
func (c *ChannelsSetTopicCall) Do(ctx context.Context) (string, error) {
	const endpoint = "channels.setTopic"
	v, err := c.Values()
	if err != nil {
		return "", err
	}
	var res channelsSetTopicCallResponseProxy
	if err := c.service.client.postForm(ctx, endpoint, v, &res); err != nil {
		return "", errors.Wrap(err, `failed to post to channels.setTopic`)
	}
	if !res.OK {
		var err error
		if errresp := res.Error; errresp != nil {
			err = errors.New(errresp.String())
		} else {
			err = errors.New(`unknown error while posting to channels.setTopic`)
		}
		return "", err
	}

	return res.payload()
}

// FromValues parses the data in v and populates `c`
func (c *ChannelsSetTopicCall) FromValues(v url.Values) error {
	var tmp ChannelsSetTopicCall
	if raw := strings.TrimSpace(v.Get("channel")); len(raw) > 0 {
		tmp.channel = raw
	}
	if raw := strings.TrimSpace(v.Get("topic")); len(raw) > 0 {
		tmp.topic = raw
	}
	*c = tmp
	return nil
}

// Unarchive creates a ChannelsUnarchiveCall object in preparation for accessing the channels.unarchive endpoint
func (s *ChannelsService) Unarchive(channel string) *ChannelsUnarchiveCall {
	var call ChannelsUnarchiveCall
	call.service = s
	call.channel = channel
	return &call
}

// ValidateArgs checks that all required fields are set in the ChannelsUnarchiveCall object
func (c *ChannelsUnarchiveCall) ValidateArgs() error {
	if len(c.channel) <= 0 {
		return errors.New(`required field channel not initialized`)
	}
	return nil
}

// Values returns the ChannelsUnarchiveCall object as url.Values
func (c *ChannelsUnarchiveCall) Values() (url.Values, error) {
	if err := c.ValidateArgs(); err != nil {
		return nil, errors.Wrap(err, `failed validation`)
	}
	v := url.Values{}
	v.Set(`token`, c.service.token)

	v.Set("channel", c.channel)
	return v, nil
}

type ChannelsUnarchiveCallResponse interface {
	OK() bool
	ReplyTo() int
	Error() *objects.ErrorResponse
	Timestamp() string
}

type channelsUnarchiveCallResponseProxy struct {
	OK        bool                   `json:"ok"`
	ReplyTo   int                    `json:"reply_to"`
	Error     *objects.ErrorResponse `json:"error"`
	Timestamp string                 `json:"ts"`
	Payload0  json.RawMessage        `json:"-"`
}
type channelsUnarchiveCallResponse struct {
	ok      bool
	replyTo int
	error   *objects.ErrorResponse
	ts      string
}
type ChannelsUnarchiveCallResponseBuilder struct {
	resp *channelsUnarchiveCallResponse
}

func BuildChannelsUnarchiveCallResponse() *ChannelsUnarchiveCallResponseBuilder {
	return &ChannelsUnarchiveCallResponseBuilder{resp: &channelsUnarchiveCallResponse{}}
}
func (v *channelsUnarchiveCallResponse) OK() bool {
	return v.ok
}
func (v *channelsUnarchiveCallResponse) ReplyTo() int {
	return v.replyTo
}
func (v *channelsUnarchiveCallResponse) Error() *objects.ErrorResponse {
	return v.error
}
func (v *channelsUnarchiveCallResponse) Timestamp() string {
	return v.ts
}
func (b *ChannelsUnarchiveCallResponseBuilder) OK(v bool) *ChannelsUnarchiveCallResponseBuilder {
	b.resp.ok = v
	return b
}
func (b *ChannelsUnarchiveCallResponseBuilder) ReplyTo(v int) *ChannelsUnarchiveCallResponseBuilder {
	b.resp.replyTo = v
	return b
}
func (b *ChannelsUnarchiveCallResponseBuilder) Error(v *objects.ErrorResponse) *ChannelsUnarchiveCallResponseBuilder {
	b.resp.error = v
	return b
}
func (b *ChannelsUnarchiveCallResponseBuilder) Timestamp(v string) *ChannelsUnarchiveCallResponseBuilder {
	b.resp.ts = v
	return b
}
func (b *ChannelsUnarchiveCallResponseBuilder) Build() ChannelsUnarchiveCallResponse {
	v := b.resp
	b.resp = &channelsUnarchiveCallResponse{}
	return v
}
func (r *channelsUnarchiveCallResponseProxy) parse(data []byte) error {
	if err := json.Unmarshal(data, r); err != nil {
		return errors.Wrap(err, `failed to unmarshal ChannelsUnarchiveCallResponse`)
	}
	r.Payload0 = data
	return nil
}

// Do executes the call to access channels.unarchive endpoint
func (c *ChannelsUnarchiveCall) Do(ctx context.Context) error {
	const endpoint = "channels.unarchive"
	v, err := c.Values()
	if err != nil {
		return err
	}
	var res channelsUnarchiveCallResponseProxy
	if err := c.service.client.postForm(ctx, endpoint, v, &res); err != nil {
		return errors.Wrap(err, `failed to post to channels.unarchive`)
	}
	if !res.OK {
		var err error
		if errresp := res.Error; errresp != nil {
			err = errors.New(errresp.String())
		} else {
			err = errors.New(`unknown error while posting to channels.unarchive`)
		}
		return err
	}

	return nil
}

// FromValues parses the data in v and populates `c`
func (c *ChannelsUnarchiveCall) FromValues(v url.Values) error {
	var tmp ChannelsUnarchiveCall
	if raw := strings.TrimSpace(v.Get("channel")); len(raw) > 0 {
		tmp.channel = raw
	}
	*c = tmp
	return nil
}
